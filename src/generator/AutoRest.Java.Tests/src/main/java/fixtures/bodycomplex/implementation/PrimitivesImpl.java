/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package fixtures.bodycomplex.implementation;

import retrofit2.Retrofit;
import fixtures.bodycomplex.Primitives;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.ServiceCall;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseBuilder;
import com.microsoft.rest.Validator;
import fixtures.bodycomplex.models.BooleanWrapper;
import fixtures.bodycomplex.models.ByteWrapper;
import fixtures.bodycomplex.models.Datetimerfc1123Wrapper;
import fixtures.bodycomplex.models.DatetimeWrapper;
import fixtures.bodycomplex.models.DateWrapper;
import fixtures.bodycomplex.models.DoubleWrapper;
import fixtures.bodycomplex.models.DurationWrapper;
import fixtures.bodycomplex.models.ErrorException;
import fixtures.bodycomplex.models.FloatWrapper;
import fixtures.bodycomplex.models.IntWrapper;
import fixtures.bodycomplex.models.LongWrapper;
import fixtures.bodycomplex.models.StringWrapper;
import java.io.IOException;
import okhttp3.ResponseBody;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.PUT;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Primitives.
 */
public final class PrimitivesImpl implements Primitives {
    /** The Retrofit service to perform REST calls. */
    private PrimitivesService service;
    /** The service client containing this operation class. */
    private AutoRestComplexTestServiceImpl client;

    /**
     * Initializes an instance of Primitives.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public PrimitivesImpl(Retrofit retrofit, AutoRestComplexTestServiceImpl client) {
        this.service = retrofit.create(PrimitivesService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Primitives to be
     * used by Retrofit to perform actually REST calls.
     */
    interface PrimitivesService {
        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("complex/primitive/integer")
        Observable<Response<ResponseBody>> getInt();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("complex/primitive/integer")
        Observable<Response<ResponseBody>> putInt(@Body IntWrapper complexBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("complex/primitive/long")
        Observable<Response<ResponseBody>> getLong();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("complex/primitive/long")
        Observable<Response<ResponseBody>> putLong(@Body LongWrapper complexBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("complex/primitive/float")
        Observable<Response<ResponseBody>> getFloat();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("complex/primitive/float")
        Observable<Response<ResponseBody>> putFloat(@Body FloatWrapper complexBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("complex/primitive/double")
        Observable<Response<ResponseBody>> getDouble();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("complex/primitive/double")
        Observable<Response<ResponseBody>> putDouble(@Body DoubleWrapper complexBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("complex/primitive/bool")
        Observable<Response<ResponseBody>> getBool();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("complex/primitive/bool")
        Observable<Response<ResponseBody>> putBool(@Body BooleanWrapper complexBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("complex/primitive/string")
        Observable<Response<ResponseBody>> getString();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("complex/primitive/string")
        Observable<Response<ResponseBody>> putString(@Body StringWrapper complexBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("complex/primitive/date")
        Observable<Response<ResponseBody>> getDate();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("complex/primitive/date")
        Observable<Response<ResponseBody>> putDate(@Body DateWrapper complexBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("complex/primitive/datetime")
        Observable<Response<ResponseBody>> getDateTime();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("complex/primitive/datetime")
        Observable<Response<ResponseBody>> putDateTime(@Body DatetimeWrapper complexBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("complex/primitive/datetimerfc1123")
        Observable<Response<ResponseBody>> getDateTimeRfc1123();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("complex/primitive/datetimerfc1123")
        Observable<Response<ResponseBody>> putDateTimeRfc1123(@Body Datetimerfc1123Wrapper complexBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("complex/primitive/duration")
        Observable<Response<ResponseBody>> getDuration();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("complex/primitive/duration")
        Observable<Response<ResponseBody>> putDuration(@Body DurationWrapper complexBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("complex/primitive/byte")
        Observable<Response<ResponseBody>> getByte();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("complex/primitive/byte")
        Observable<Response<ResponseBody>> putByte(@Body ByteWrapper complexBody);

    }

    /**
     * Get complex types with integer properties.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the IntWrapper object wrapped in {@link ServiceResponse} if successful.
     */
    public IntWrapper getInt() throws ErrorException, IOException {
        return getIntAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get complex types with integer properties.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<IntWrapper> getIntAsync(final ServiceCallback<IntWrapper> serviceCallback) {
        return ServiceCall.create(getIntAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get complex types with integer properties.
     *
     * @return the observable to the IntWrapper object
     */
    public Observable<IntWrapper> getIntAsync() {
        return getIntAsyncWithServiceResponse().map(new Func1<ServiceResponse<IntWrapper>, IntWrapper>() {
            @Override
            public IntWrapper call(ServiceResponse<IntWrapper> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get complex types with integer properties.
     *
     * @return the observable to the IntWrapper object
     */
    public Observable<ServiceResponse<IntWrapper>> getIntAsyncWithServiceResponse() {
        return service.getInt()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<IntWrapper>>>() {
                @Override
                public Observable<ServiceResponse<IntWrapper>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<IntWrapper> clientResponse = getIntDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<IntWrapper> getIntDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<IntWrapper, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<IntWrapper>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Put complex types with integer properties.
     *
     * @param complexBody Please put -1 and 2
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putInt(IntWrapper complexBody) throws ErrorException, IOException, IllegalArgumentException {
        putIntAsyncWithServiceResponse(complexBody).toBlocking().single().getBody();
    }

    /**
     * Put complex types with integer properties.
     *
     * @param complexBody Please put -1 and 2
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putIntAsync(IntWrapper complexBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putIntAsyncWithServiceResponse(complexBody), serviceCallback);
    }

    /**
     * Put complex types with integer properties.
     *
     * @param complexBody Please put -1 and 2
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putIntAsync(IntWrapper complexBody) {
        return putIntAsyncWithServiceResponse(complexBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Put complex types with integer properties.
     *
     * @param complexBody Please put -1 and 2
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putIntAsyncWithServiceResponse(IntWrapper complexBody) {
        if (complexBody == null) {
            throw new IllegalArgumentException("Parameter complexBody is required and cannot be null.");
        }
        Validator.validate(complexBody);
        return service.putInt(complexBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putIntDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putIntDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get complex types with long properties.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the LongWrapper object wrapped in {@link ServiceResponse} if successful.
     */
    public LongWrapper getLong() throws ErrorException, IOException {
        return getLongAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get complex types with long properties.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<LongWrapper> getLongAsync(final ServiceCallback<LongWrapper> serviceCallback) {
        return ServiceCall.create(getLongAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get complex types with long properties.
     *
     * @return the observable to the LongWrapper object
     */
    public Observable<LongWrapper> getLongAsync() {
        return getLongAsyncWithServiceResponse().map(new Func1<ServiceResponse<LongWrapper>, LongWrapper>() {
            @Override
            public LongWrapper call(ServiceResponse<LongWrapper> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get complex types with long properties.
     *
     * @return the observable to the LongWrapper object
     */
    public Observable<ServiceResponse<LongWrapper>> getLongAsyncWithServiceResponse() {
        return service.getLong()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<LongWrapper>>>() {
                @Override
                public Observable<ServiceResponse<LongWrapper>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<LongWrapper> clientResponse = getLongDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<LongWrapper> getLongDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<LongWrapper, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<LongWrapper>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Put complex types with long properties.
     *
     * @param complexBody Please put 1099511627775 and -999511627788
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putLong(LongWrapper complexBody) throws ErrorException, IOException, IllegalArgumentException {
        putLongAsyncWithServiceResponse(complexBody).toBlocking().single().getBody();
    }

    /**
     * Put complex types with long properties.
     *
     * @param complexBody Please put 1099511627775 and -999511627788
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putLongAsync(LongWrapper complexBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putLongAsyncWithServiceResponse(complexBody), serviceCallback);
    }

    /**
     * Put complex types with long properties.
     *
     * @param complexBody Please put 1099511627775 and -999511627788
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putLongAsync(LongWrapper complexBody) {
        return putLongAsyncWithServiceResponse(complexBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Put complex types with long properties.
     *
     * @param complexBody Please put 1099511627775 and -999511627788
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putLongAsyncWithServiceResponse(LongWrapper complexBody) {
        if (complexBody == null) {
            throw new IllegalArgumentException("Parameter complexBody is required and cannot be null.");
        }
        Validator.validate(complexBody);
        return service.putLong(complexBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putLongDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putLongDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get complex types with float properties.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the FloatWrapper object wrapped in {@link ServiceResponse} if successful.
     */
    public FloatWrapper getFloat() throws ErrorException, IOException {
        return getFloatAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get complex types with float properties.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<FloatWrapper> getFloatAsync(final ServiceCallback<FloatWrapper> serviceCallback) {
        return ServiceCall.create(getFloatAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get complex types with float properties.
     *
     * @return the observable to the FloatWrapper object
     */
    public Observable<FloatWrapper> getFloatAsync() {
        return getFloatAsyncWithServiceResponse().map(new Func1<ServiceResponse<FloatWrapper>, FloatWrapper>() {
            @Override
            public FloatWrapper call(ServiceResponse<FloatWrapper> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get complex types with float properties.
     *
     * @return the observable to the FloatWrapper object
     */
    public Observable<ServiceResponse<FloatWrapper>> getFloatAsyncWithServiceResponse() {
        return service.getFloat()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<FloatWrapper>>>() {
                @Override
                public Observable<ServiceResponse<FloatWrapper>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<FloatWrapper> clientResponse = getFloatDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<FloatWrapper> getFloatDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<FloatWrapper, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<FloatWrapper>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Put complex types with float properties.
     *
     * @param complexBody Please put 1.05 and -0.003
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putFloat(FloatWrapper complexBody) throws ErrorException, IOException, IllegalArgumentException {
        putFloatAsyncWithServiceResponse(complexBody).toBlocking().single().getBody();
    }

    /**
     * Put complex types with float properties.
     *
     * @param complexBody Please put 1.05 and -0.003
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putFloatAsync(FloatWrapper complexBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putFloatAsyncWithServiceResponse(complexBody), serviceCallback);
    }

    /**
     * Put complex types with float properties.
     *
     * @param complexBody Please put 1.05 and -0.003
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putFloatAsync(FloatWrapper complexBody) {
        return putFloatAsyncWithServiceResponse(complexBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Put complex types with float properties.
     *
     * @param complexBody Please put 1.05 and -0.003
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putFloatAsyncWithServiceResponse(FloatWrapper complexBody) {
        if (complexBody == null) {
            throw new IllegalArgumentException("Parameter complexBody is required and cannot be null.");
        }
        Validator.validate(complexBody);
        return service.putFloat(complexBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putFloatDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putFloatDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get complex types with double properties.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the DoubleWrapper object wrapped in {@link ServiceResponse} if successful.
     */
    public DoubleWrapper getDouble() throws ErrorException, IOException {
        return getDoubleAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get complex types with double properties.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DoubleWrapper> getDoubleAsync(final ServiceCallback<DoubleWrapper> serviceCallback) {
        return ServiceCall.create(getDoubleAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get complex types with double properties.
     *
     * @return the observable to the DoubleWrapper object
     */
    public Observable<DoubleWrapper> getDoubleAsync() {
        return getDoubleAsyncWithServiceResponse().map(new Func1<ServiceResponse<DoubleWrapper>, DoubleWrapper>() {
            @Override
            public DoubleWrapper call(ServiceResponse<DoubleWrapper> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get complex types with double properties.
     *
     * @return the observable to the DoubleWrapper object
     */
    public Observable<ServiceResponse<DoubleWrapper>> getDoubleAsyncWithServiceResponse() {
        return service.getDouble()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DoubleWrapper>>>() {
                @Override
                public Observable<ServiceResponse<DoubleWrapper>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DoubleWrapper> clientResponse = getDoubleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DoubleWrapper> getDoubleDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<DoubleWrapper, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DoubleWrapper>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Put complex types with double properties.
     *
     * @param complexBody Please put 3e-100 and -0.000000000000000000000000000000000000000000000000000000005
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putDouble(DoubleWrapper complexBody) throws ErrorException, IOException, IllegalArgumentException {
        putDoubleAsyncWithServiceResponse(complexBody).toBlocking().single().getBody();
    }

    /**
     * Put complex types with double properties.
     *
     * @param complexBody Please put 3e-100 and -0.000000000000000000000000000000000000000000000000000000005
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putDoubleAsync(DoubleWrapper complexBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putDoubleAsyncWithServiceResponse(complexBody), serviceCallback);
    }

    /**
     * Put complex types with double properties.
     *
     * @param complexBody Please put 3e-100 and -0.000000000000000000000000000000000000000000000000000000005
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putDoubleAsync(DoubleWrapper complexBody) {
        return putDoubleAsyncWithServiceResponse(complexBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Put complex types with double properties.
     *
     * @param complexBody Please put 3e-100 and -0.000000000000000000000000000000000000000000000000000000005
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putDoubleAsyncWithServiceResponse(DoubleWrapper complexBody) {
        if (complexBody == null) {
            throw new IllegalArgumentException("Parameter complexBody is required and cannot be null.");
        }
        Validator.validate(complexBody);
        return service.putDouble(complexBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putDoubleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putDoubleDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get complex types with bool properties.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the BooleanWrapper object wrapped in {@link ServiceResponse} if successful.
     */
    public BooleanWrapper getBool() throws ErrorException, IOException {
        return getBoolAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get complex types with bool properties.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<BooleanWrapper> getBoolAsync(final ServiceCallback<BooleanWrapper> serviceCallback) {
        return ServiceCall.create(getBoolAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get complex types with bool properties.
     *
     * @return the observable to the BooleanWrapper object
     */
    public Observable<BooleanWrapper> getBoolAsync() {
        return getBoolAsyncWithServiceResponse().map(new Func1<ServiceResponse<BooleanWrapper>, BooleanWrapper>() {
            @Override
            public BooleanWrapper call(ServiceResponse<BooleanWrapper> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get complex types with bool properties.
     *
     * @return the observable to the BooleanWrapper object
     */
    public Observable<ServiceResponse<BooleanWrapper>> getBoolAsyncWithServiceResponse() {
        return service.getBool()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<BooleanWrapper>>>() {
                @Override
                public Observable<ServiceResponse<BooleanWrapper>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<BooleanWrapper> clientResponse = getBoolDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<BooleanWrapper> getBoolDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<BooleanWrapper, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<BooleanWrapper>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Put complex types with bool properties.
     *
     * @param complexBody Please put true and false
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putBool(BooleanWrapper complexBody) throws ErrorException, IOException, IllegalArgumentException {
        putBoolAsyncWithServiceResponse(complexBody).toBlocking().single().getBody();
    }

    /**
     * Put complex types with bool properties.
     *
     * @param complexBody Please put true and false
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putBoolAsync(BooleanWrapper complexBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putBoolAsyncWithServiceResponse(complexBody), serviceCallback);
    }

    /**
     * Put complex types with bool properties.
     *
     * @param complexBody Please put true and false
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putBoolAsync(BooleanWrapper complexBody) {
        return putBoolAsyncWithServiceResponse(complexBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Put complex types with bool properties.
     *
     * @param complexBody Please put true and false
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putBoolAsyncWithServiceResponse(BooleanWrapper complexBody) {
        if (complexBody == null) {
            throw new IllegalArgumentException("Parameter complexBody is required and cannot be null.");
        }
        Validator.validate(complexBody);
        return service.putBool(complexBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putBoolDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putBoolDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get complex types with string properties.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the StringWrapper object wrapped in {@link ServiceResponse} if successful.
     */
    public StringWrapper getString() throws ErrorException, IOException {
        return getStringAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get complex types with string properties.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<StringWrapper> getStringAsync(final ServiceCallback<StringWrapper> serviceCallback) {
        return ServiceCall.create(getStringAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get complex types with string properties.
     *
     * @return the observable to the StringWrapper object
     */
    public Observable<StringWrapper> getStringAsync() {
        return getStringAsyncWithServiceResponse().map(new Func1<ServiceResponse<StringWrapper>, StringWrapper>() {
            @Override
            public StringWrapper call(ServiceResponse<StringWrapper> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get complex types with string properties.
     *
     * @return the observable to the StringWrapper object
     */
    public Observable<ServiceResponse<StringWrapper>> getStringAsyncWithServiceResponse() {
        return service.getString()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<StringWrapper>>>() {
                @Override
                public Observable<ServiceResponse<StringWrapper>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<StringWrapper> clientResponse = getStringDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<StringWrapper> getStringDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<StringWrapper, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<StringWrapper>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Put complex types with string properties.
     *
     * @param complexBody Please put 'goodrequest', '', and null
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putString(StringWrapper complexBody) throws ErrorException, IOException, IllegalArgumentException {
        putStringAsyncWithServiceResponse(complexBody).toBlocking().single().getBody();
    }

    /**
     * Put complex types with string properties.
     *
     * @param complexBody Please put 'goodrequest', '', and null
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putStringAsync(StringWrapper complexBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putStringAsyncWithServiceResponse(complexBody), serviceCallback);
    }

    /**
     * Put complex types with string properties.
     *
     * @param complexBody Please put 'goodrequest', '', and null
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putStringAsync(StringWrapper complexBody) {
        return putStringAsyncWithServiceResponse(complexBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Put complex types with string properties.
     *
     * @param complexBody Please put 'goodrequest', '', and null
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putStringAsyncWithServiceResponse(StringWrapper complexBody) {
        if (complexBody == null) {
            throw new IllegalArgumentException("Parameter complexBody is required and cannot be null.");
        }
        Validator.validate(complexBody);
        return service.putString(complexBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putStringDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putStringDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get complex types with date properties.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the DateWrapper object wrapped in {@link ServiceResponse} if successful.
     */
    public DateWrapper getDate() throws ErrorException, IOException {
        return getDateAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get complex types with date properties.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DateWrapper> getDateAsync(final ServiceCallback<DateWrapper> serviceCallback) {
        return ServiceCall.create(getDateAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get complex types with date properties.
     *
     * @return the observable to the DateWrapper object
     */
    public Observable<DateWrapper> getDateAsync() {
        return getDateAsyncWithServiceResponse().map(new Func1<ServiceResponse<DateWrapper>, DateWrapper>() {
            @Override
            public DateWrapper call(ServiceResponse<DateWrapper> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get complex types with date properties.
     *
     * @return the observable to the DateWrapper object
     */
    public Observable<ServiceResponse<DateWrapper>> getDateAsyncWithServiceResponse() {
        return service.getDate()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DateWrapper>>>() {
                @Override
                public Observable<ServiceResponse<DateWrapper>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DateWrapper> clientResponse = getDateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DateWrapper> getDateDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<DateWrapper, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DateWrapper>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Put complex types with date properties.
     *
     * @param complexBody Please put '0001-01-01' and '2016-02-29'
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putDate(DateWrapper complexBody) throws ErrorException, IOException, IllegalArgumentException {
        putDateAsyncWithServiceResponse(complexBody).toBlocking().single().getBody();
    }

    /**
     * Put complex types with date properties.
     *
     * @param complexBody Please put '0001-01-01' and '2016-02-29'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putDateAsync(DateWrapper complexBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putDateAsyncWithServiceResponse(complexBody), serviceCallback);
    }

    /**
     * Put complex types with date properties.
     *
     * @param complexBody Please put '0001-01-01' and '2016-02-29'
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putDateAsync(DateWrapper complexBody) {
        return putDateAsyncWithServiceResponse(complexBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Put complex types with date properties.
     *
     * @param complexBody Please put '0001-01-01' and '2016-02-29'
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putDateAsyncWithServiceResponse(DateWrapper complexBody) {
        if (complexBody == null) {
            throw new IllegalArgumentException("Parameter complexBody is required and cannot be null.");
        }
        Validator.validate(complexBody);
        return service.putDate(complexBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putDateDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putDateDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get complex types with datetime properties.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the DatetimeWrapper object wrapped in {@link ServiceResponse} if successful.
     */
    public DatetimeWrapper getDateTime() throws ErrorException, IOException {
        return getDateTimeAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get complex types with datetime properties.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DatetimeWrapper> getDateTimeAsync(final ServiceCallback<DatetimeWrapper> serviceCallback) {
        return ServiceCall.create(getDateTimeAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get complex types with datetime properties.
     *
     * @return the observable to the DatetimeWrapper object
     */
    public Observable<DatetimeWrapper> getDateTimeAsync() {
        return getDateTimeAsyncWithServiceResponse().map(new Func1<ServiceResponse<DatetimeWrapper>, DatetimeWrapper>() {
            @Override
            public DatetimeWrapper call(ServiceResponse<DatetimeWrapper> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get complex types with datetime properties.
     *
     * @return the observable to the DatetimeWrapper object
     */
    public Observable<ServiceResponse<DatetimeWrapper>> getDateTimeAsyncWithServiceResponse() {
        return service.getDateTime()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DatetimeWrapper>>>() {
                @Override
                public Observable<ServiceResponse<DatetimeWrapper>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DatetimeWrapper> clientResponse = getDateTimeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DatetimeWrapper> getDateTimeDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<DatetimeWrapper, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DatetimeWrapper>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Put complex types with datetime properties.
     *
     * @param complexBody Please put '0001-01-01T12:00:00-04:00' and '2015-05-18T11:38:00-08:00'
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putDateTime(DatetimeWrapper complexBody) throws ErrorException, IOException, IllegalArgumentException {
        putDateTimeAsyncWithServiceResponse(complexBody).toBlocking().single().getBody();
    }

    /**
     * Put complex types with datetime properties.
     *
     * @param complexBody Please put '0001-01-01T12:00:00-04:00' and '2015-05-18T11:38:00-08:00'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putDateTimeAsync(DatetimeWrapper complexBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putDateTimeAsyncWithServiceResponse(complexBody), serviceCallback);
    }

    /**
     * Put complex types with datetime properties.
     *
     * @param complexBody Please put '0001-01-01T12:00:00-04:00' and '2015-05-18T11:38:00-08:00'
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putDateTimeAsync(DatetimeWrapper complexBody) {
        return putDateTimeAsyncWithServiceResponse(complexBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Put complex types with datetime properties.
     *
     * @param complexBody Please put '0001-01-01T12:00:00-04:00' and '2015-05-18T11:38:00-08:00'
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putDateTimeAsyncWithServiceResponse(DatetimeWrapper complexBody) {
        if (complexBody == null) {
            throw new IllegalArgumentException("Parameter complexBody is required and cannot be null.");
        }
        Validator.validate(complexBody);
        return service.putDateTime(complexBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putDateTimeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putDateTimeDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get complex types with datetimeRfc1123 properties.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Datetimerfc1123Wrapper object wrapped in {@link ServiceResponse} if successful.
     */
    public Datetimerfc1123Wrapper getDateTimeRfc1123() throws ErrorException, IOException {
        return getDateTimeRfc1123AsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get complex types with datetimeRfc1123 properties.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Datetimerfc1123Wrapper> getDateTimeRfc1123Async(final ServiceCallback<Datetimerfc1123Wrapper> serviceCallback) {
        return ServiceCall.create(getDateTimeRfc1123AsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get complex types with datetimeRfc1123 properties.
     *
     * @return the observable to the Datetimerfc1123Wrapper object
     */
    public Observable<Datetimerfc1123Wrapper> getDateTimeRfc1123Async() {
        return getDateTimeRfc1123AsyncWithServiceResponse().map(new Func1<ServiceResponse<Datetimerfc1123Wrapper>, Datetimerfc1123Wrapper>() {
            @Override
            public Datetimerfc1123Wrapper call(ServiceResponse<Datetimerfc1123Wrapper> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get complex types with datetimeRfc1123 properties.
     *
     * @return the observable to the Datetimerfc1123Wrapper object
     */
    public Observable<ServiceResponse<Datetimerfc1123Wrapper>> getDateTimeRfc1123AsyncWithServiceResponse() {
        return service.getDateTimeRfc1123()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Datetimerfc1123Wrapper>>>() {
                @Override
                public Observable<ServiceResponse<Datetimerfc1123Wrapper>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Datetimerfc1123Wrapper> clientResponse = getDateTimeRfc1123Delegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Datetimerfc1123Wrapper> getDateTimeRfc1123Delegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Datetimerfc1123Wrapper, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Datetimerfc1123Wrapper>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Put complex types with datetimeRfc1123 properties.
     *
     * @param complexBody Please put 'Mon, 01 Jan 0001 12:00:00 GMT' and 'Mon, 18 May 2015 11:38:00 GMT'
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putDateTimeRfc1123(Datetimerfc1123Wrapper complexBody) throws ErrorException, IOException, IllegalArgumentException {
        putDateTimeRfc1123AsyncWithServiceResponse(complexBody).toBlocking().single().getBody();
    }

    /**
     * Put complex types with datetimeRfc1123 properties.
     *
     * @param complexBody Please put 'Mon, 01 Jan 0001 12:00:00 GMT' and 'Mon, 18 May 2015 11:38:00 GMT'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putDateTimeRfc1123Async(Datetimerfc1123Wrapper complexBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putDateTimeRfc1123AsyncWithServiceResponse(complexBody), serviceCallback);
    }

    /**
     * Put complex types with datetimeRfc1123 properties.
     *
     * @param complexBody Please put 'Mon, 01 Jan 0001 12:00:00 GMT' and 'Mon, 18 May 2015 11:38:00 GMT'
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putDateTimeRfc1123Async(Datetimerfc1123Wrapper complexBody) {
        return putDateTimeRfc1123AsyncWithServiceResponse(complexBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Put complex types with datetimeRfc1123 properties.
     *
     * @param complexBody Please put 'Mon, 01 Jan 0001 12:00:00 GMT' and 'Mon, 18 May 2015 11:38:00 GMT'
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putDateTimeRfc1123AsyncWithServiceResponse(Datetimerfc1123Wrapper complexBody) {
        if (complexBody == null) {
            throw new IllegalArgumentException("Parameter complexBody is required and cannot be null.");
        }
        Validator.validate(complexBody);
        return service.putDateTimeRfc1123(complexBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putDateTimeRfc1123Delegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putDateTimeRfc1123Delegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get complex types with duration properties.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the DurationWrapper object wrapped in {@link ServiceResponse} if successful.
     */
    public DurationWrapper getDuration() throws ErrorException, IOException {
        return getDurationAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get complex types with duration properties.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<DurationWrapper> getDurationAsync(final ServiceCallback<DurationWrapper> serviceCallback) {
        return ServiceCall.create(getDurationAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get complex types with duration properties.
     *
     * @return the observable to the DurationWrapper object
     */
    public Observable<DurationWrapper> getDurationAsync() {
        return getDurationAsyncWithServiceResponse().map(new Func1<ServiceResponse<DurationWrapper>, DurationWrapper>() {
            @Override
            public DurationWrapper call(ServiceResponse<DurationWrapper> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get complex types with duration properties.
     *
     * @return the observable to the DurationWrapper object
     */
    public Observable<ServiceResponse<DurationWrapper>> getDurationAsyncWithServiceResponse() {
        return service.getDuration()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<DurationWrapper>>>() {
                @Override
                public Observable<ServiceResponse<DurationWrapper>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<DurationWrapper> clientResponse = getDurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<DurationWrapper> getDurationDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<DurationWrapper, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<DurationWrapper>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Put complex types with duration properties.
     *
     * @param complexBody Please put 'P123DT22H14M12.011S'
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putDuration(DurationWrapper complexBody) throws ErrorException, IOException, IllegalArgumentException {
        putDurationAsyncWithServiceResponse(complexBody).toBlocking().single().getBody();
    }

    /**
     * Put complex types with duration properties.
     *
     * @param complexBody Please put 'P123DT22H14M12.011S'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putDurationAsync(DurationWrapper complexBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putDurationAsyncWithServiceResponse(complexBody), serviceCallback);
    }

    /**
     * Put complex types with duration properties.
     *
     * @param complexBody Please put 'P123DT22H14M12.011S'
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putDurationAsync(DurationWrapper complexBody) {
        return putDurationAsyncWithServiceResponse(complexBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Put complex types with duration properties.
     *
     * @param complexBody Please put 'P123DT22H14M12.011S'
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putDurationAsyncWithServiceResponse(DurationWrapper complexBody) {
        if (complexBody == null) {
            throw new IllegalArgumentException("Parameter complexBody is required and cannot be null.");
        }
        Validator.validate(complexBody);
        return service.putDuration(complexBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putDurationDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putDurationDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get complex types with byte properties.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the ByteWrapper object wrapped in {@link ServiceResponse} if successful.
     */
    public ByteWrapper getByte() throws ErrorException, IOException {
        return getByteAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get complex types with byte properties.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<ByteWrapper> getByteAsync(final ServiceCallback<ByteWrapper> serviceCallback) {
        return ServiceCall.create(getByteAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get complex types with byte properties.
     *
     * @return the observable to the ByteWrapper object
     */
    public Observable<ByteWrapper> getByteAsync() {
        return getByteAsyncWithServiceResponse().map(new Func1<ServiceResponse<ByteWrapper>, ByteWrapper>() {
            @Override
            public ByteWrapper call(ServiceResponse<ByteWrapper> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get complex types with byte properties.
     *
     * @return the observable to the ByteWrapper object
     */
    public Observable<ServiceResponse<ByteWrapper>> getByteAsyncWithServiceResponse() {
        return service.getByte()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ByteWrapper>>>() {
                @Override
                public Observable<ServiceResponse<ByteWrapper>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ByteWrapper> clientResponse = getByteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<ByteWrapper> getByteDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<ByteWrapper, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<ByteWrapper>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Put complex types with byte properties.
     *
     * @param complexBody Please put non-ascii byte string hex(FF FE FD FC 00 FA F9 F8 F7 F6)
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putByte(ByteWrapper complexBody) throws ErrorException, IOException, IllegalArgumentException {
        putByteAsyncWithServiceResponse(complexBody).toBlocking().single().getBody();
    }

    /**
     * Put complex types with byte properties.
     *
     * @param complexBody Please put non-ascii byte string hex(FF FE FD FC 00 FA F9 F8 F7 F6)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putByteAsync(ByteWrapper complexBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putByteAsyncWithServiceResponse(complexBody), serviceCallback);
    }

    /**
     * Put complex types with byte properties.
     *
     * @param complexBody Please put non-ascii byte string hex(FF FE FD FC 00 FA F9 F8 F7 F6)
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putByteAsync(ByteWrapper complexBody) {
        return putByteAsyncWithServiceResponse(complexBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Put complex types with byte properties.
     *
     * @param complexBody Please put non-ascii byte string hex(FF FE FD FC 00 FA F9 F8 F7 F6)
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putByteAsyncWithServiceResponse(ByteWrapper complexBody) {
        if (complexBody == null) {
            throw new IllegalArgumentException("Parameter complexBody is required and cannot be null.");
        }
        Validator.validate(complexBody);
        return service.putByte(complexBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putByteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putByteDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

}
