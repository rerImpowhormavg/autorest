/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package fixtures.url.implementation;

import retrofit2.Retrofit;
import fixtures.url.Queries;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.serializer.CollectionFormat;
import com.microsoft.rest.ServiceCall;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseBuilder;
import com.microsoft.rest.Validator;
import fixtures.url.models.ErrorException;
import fixtures.url.models.UriColor;
import java.io.IOException;
import java.util.List;
import okhttp3.ResponseBody;
import org.apache.commons.codec.binary.Base64;
import org.joda.time.DateTime;
import org.joda.time.LocalDate;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.Query;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Queries.
 */
public final class QueriesImpl implements Queries {
    /** The Retrofit service to perform REST calls. */
    private QueriesService service;
    /** The service client containing this operation class. */
    private AutoRestUrlTestServiceImpl client;

    /**
     * Initializes an instance of Queries.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public QueriesImpl(Retrofit retrofit, AutoRestUrlTestServiceImpl client) {
        this.service = retrofit.create(QueriesService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Queries to be
     * used by Retrofit to perform actually REST calls.
     */
    interface QueriesService {
        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/bool/true")
        Observable<Response<ResponseBody>> getBooleanTrue(@Query("boolQuery") boolean boolQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/bool/false")
        Observable<Response<ResponseBody>> getBooleanFalse(@Query("boolQuery") boolean boolQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/bool/null")
        Observable<Response<ResponseBody>> getBooleanNull(@Query("boolQuery") Boolean boolQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/int/1000000")
        Observable<Response<ResponseBody>> getIntOneMillion(@Query("intQuery") int intQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/int/-1000000")
        Observable<Response<ResponseBody>> getIntNegativeOneMillion(@Query("intQuery") int intQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/int/null")
        Observable<Response<ResponseBody>> getIntNull(@Query("intQuery") Integer intQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/long/10000000000")
        Observable<Response<ResponseBody>> getTenBillion(@Query("longQuery") long longQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/long/-10000000000")
        Observable<Response<ResponseBody>> getNegativeTenBillion(@Query("longQuery") long longQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/long/null")
        Observable<Response<ResponseBody>> getLongNull(@Query("longQuery") Long longQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/float/1.034E+20")
        Observable<Response<ResponseBody>> floatScientificPositive(@Query("floatQuery") double floatQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/float/-1.034E-20")
        Observable<Response<ResponseBody>> floatScientificNegative(@Query("floatQuery") double floatQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/float/null")
        Observable<Response<ResponseBody>> floatNull(@Query("floatQuery") Double floatQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/double/9999999.999")
        Observable<Response<ResponseBody>> doubleDecimalPositive(@Query("doubleQuery") double doubleQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/double/-9999999.999")
        Observable<Response<ResponseBody>> doubleDecimalNegative(@Query("doubleQuery") double doubleQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/double/null")
        Observable<Response<ResponseBody>> doubleNull(@Query("doubleQuery") Double doubleQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/string/unicode/")
        Observable<Response<ResponseBody>> stringUnicode(@Query("stringQuery") String stringQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/string/begin%21%2A%27%28%29%3B%3A%40%20%26%3D%2B%24%2C%2F%3F%23%5B%5Dend")
        Observable<Response<ResponseBody>> stringUrlEncoded(@Query("stringQuery") String stringQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/string/empty")
        Observable<Response<ResponseBody>> stringEmpty(@Query("stringQuery") String stringQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/string/null")
        Observable<Response<ResponseBody>> stringNull(@Query("stringQuery") String stringQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/enum/green%20color")
        Observable<Response<ResponseBody>> enumValid(@Query("enumQuery") UriColor enumQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/enum/null")
        Observable<Response<ResponseBody>> enumNull(@Query("enumQuery") UriColor enumQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/byte/multibyte")
        Observable<Response<ResponseBody>> byteMultiByte(@Query("byteQuery") String byteQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/byte/empty")
        Observable<Response<ResponseBody>> byteEmpty(@Query("byteQuery") String byteQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/byte/null")
        Observable<Response<ResponseBody>> byteNull(@Query("byteQuery") String byteQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/date/2012-01-01")
        Observable<Response<ResponseBody>> dateValid(@Query("dateQuery") LocalDate dateQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/date/null")
        Observable<Response<ResponseBody>> dateNull(@Query("dateQuery") LocalDate dateQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/datetime/2012-01-01T01%3A01%3A01Z")
        Observable<Response<ResponseBody>> dateTimeValid(@Query("dateTimeQuery") DateTime dateTimeQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/datetime/null")
        Observable<Response<ResponseBody>> dateTimeNull(@Query("dateTimeQuery") DateTime dateTimeQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/array/csv/string/valid")
        Observable<Response<ResponseBody>> arrayStringCsvValid(@Query("arrayQuery") String arrayQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/array/csv/string/null")
        Observable<Response<ResponseBody>> arrayStringCsvNull(@Query("arrayQuery") String arrayQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/array/csv/string/empty")
        Observable<Response<ResponseBody>> arrayStringCsvEmpty(@Query("arrayQuery") String arrayQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/array/ssv/string/valid")
        Observable<Response<ResponseBody>> arrayStringSsvValid(@Query("arrayQuery") String arrayQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/array/tsv/string/valid")
        Observable<Response<ResponseBody>> arrayStringTsvValid(@Query("arrayQuery") String arrayQuery);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("queries/array/pipes/string/valid")
        Observable<Response<ResponseBody>> arrayStringPipesValid(@Query("arrayQuery") String arrayQuery);

    }

    /**
     * Get true Boolean value on path.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void getBooleanTrue() throws ErrorException, IOException {
        getBooleanTrueAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get true Boolean value on path.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> getBooleanTrueAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(getBooleanTrueAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get true Boolean value on path.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> getBooleanTrueAsync() {
        return getBooleanTrueAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get true Boolean value on path.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> getBooleanTrueAsyncWithServiceResponse() {
        final boolean boolQuery = true;
        return service.getBooleanTrue(boolQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = getBooleanTrueDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> getBooleanTrueDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get false Boolean value on path.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void getBooleanFalse() throws ErrorException, IOException {
        getBooleanFalseAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get false Boolean value on path.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> getBooleanFalseAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(getBooleanFalseAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get false Boolean value on path.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> getBooleanFalseAsync() {
        return getBooleanFalseAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get false Boolean value on path.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> getBooleanFalseAsyncWithServiceResponse() {
        final boolean boolQuery = false;
        return service.getBooleanFalse(boolQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = getBooleanFalseDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> getBooleanFalseDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get null Boolean value on query (query string should be absent).
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void getBooleanNull() throws ErrorException, IOException {
        getBooleanNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get null Boolean value on query (query string should be absent).
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> getBooleanNullAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(getBooleanNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get null Boolean value on query (query string should be absent).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> getBooleanNullAsync() {
        return getBooleanNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get null Boolean value on query (query string should be absent).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> getBooleanNullAsyncWithServiceResponse() {
        final Boolean boolQuery = null;
        return service.getBooleanNull(boolQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = getBooleanNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get null Boolean value on query (query string should be absent).
     *
     * @param boolQuery null boolean value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void getBooleanNull(Boolean boolQuery) throws ErrorException, IOException {
        getBooleanNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get null Boolean value on query (query string should be absent).
     *
     * @param boolQuery null boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> getBooleanNullAsync(Boolean boolQuery, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(getBooleanNullAsyncWithServiceResponse(boolQuery), serviceCallback);
    }

    /**
     * Get null Boolean value on query (query string should be absent).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> getBooleanNullAsync(Boolean boolQuery) {
        return getBooleanNullAsyncWithServiceResponse(boolQuery).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get null Boolean value on query (query string should be absent).
     *
     * @param boolQuery null boolean value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> getBooleanNullAsyncWithServiceResponse(Boolean boolQuery) {
        return service.getBooleanNull(boolQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = getBooleanNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> getBooleanNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '1000000' integer value.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void getIntOneMillion() throws ErrorException, IOException {
        getIntOneMillionAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get '1000000' integer value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> getIntOneMillionAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(getIntOneMillionAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get '1000000' integer value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> getIntOneMillionAsync() {
        return getIntOneMillionAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get '1000000' integer value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> getIntOneMillionAsyncWithServiceResponse() {
        final int intQuery = 1000000;
        return service.getIntOneMillion(intQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = getIntOneMillionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> getIntOneMillionDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '-1000000' integer value.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void getIntNegativeOneMillion() throws ErrorException, IOException {
        getIntNegativeOneMillionAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get '-1000000' integer value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> getIntNegativeOneMillionAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(getIntNegativeOneMillionAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get '-1000000' integer value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> getIntNegativeOneMillionAsync() {
        return getIntNegativeOneMillionAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get '-1000000' integer value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> getIntNegativeOneMillionAsyncWithServiceResponse() {
        final int intQuery = -1000000;
        return service.getIntNegativeOneMillion(intQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = getIntNegativeOneMillionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> getIntNegativeOneMillionDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get null integer value (no query parameter).
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void getIntNull() throws ErrorException, IOException {
        getIntNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get null integer value (no query parameter).
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> getIntNullAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(getIntNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get null integer value (no query parameter).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> getIntNullAsync() {
        return getIntNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get null integer value (no query parameter).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> getIntNullAsyncWithServiceResponse() {
        final Integer intQuery = null;
        return service.getIntNull(intQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = getIntNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get null integer value (no query parameter).
     *
     * @param intQuery null integer value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void getIntNull(Integer intQuery) throws ErrorException, IOException {
        getIntNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get null integer value (no query parameter).
     *
     * @param intQuery null integer value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> getIntNullAsync(Integer intQuery, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(getIntNullAsyncWithServiceResponse(intQuery), serviceCallback);
    }

    /**
     * Get null integer value (no query parameter).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> getIntNullAsync(Integer intQuery) {
        return getIntNullAsyncWithServiceResponse(intQuery).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get null integer value (no query parameter).
     *
     * @param intQuery null integer value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> getIntNullAsyncWithServiceResponse(Integer intQuery) {
        return service.getIntNull(intQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = getIntNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> getIntNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '10000000000' 64 bit integer value.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void getTenBillion() throws ErrorException, IOException {
        getTenBillionAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get '10000000000' 64 bit integer value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> getTenBillionAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(getTenBillionAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get '10000000000' 64 bit integer value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> getTenBillionAsync() {
        return getTenBillionAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get '10000000000' 64 bit integer value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> getTenBillionAsyncWithServiceResponse() {
        final long longQuery = 10000000000L;
        return service.getTenBillion(longQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = getTenBillionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> getTenBillionDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '-10000000000' 64 bit integer value.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void getNegativeTenBillion() throws ErrorException, IOException {
        getNegativeTenBillionAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get '-10000000000' 64 bit integer value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> getNegativeTenBillionAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(getNegativeTenBillionAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get '-10000000000' 64 bit integer value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> getNegativeTenBillionAsync() {
        return getNegativeTenBillionAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get '-10000000000' 64 bit integer value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> getNegativeTenBillionAsyncWithServiceResponse() {
        final long longQuery = -10000000000L;
        return service.getNegativeTenBillion(longQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = getNegativeTenBillionDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> getNegativeTenBillionDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get 'null 64 bit integer value (no query param in uri).
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void getLongNull() throws ErrorException, IOException {
        getLongNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get 'null 64 bit integer value (no query param in uri).
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> getLongNullAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(getLongNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get 'null 64 bit integer value (no query param in uri).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> getLongNullAsync() {
        return getLongNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get 'null 64 bit integer value (no query param in uri).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> getLongNullAsyncWithServiceResponse() {
        final Long longQuery = null;
        return service.getLongNull(longQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = getLongNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get 'null 64 bit integer value (no query param in uri).
     *
     * @param longQuery null 64 bit integer value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void getLongNull(Long longQuery) throws ErrorException, IOException {
        getLongNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get 'null 64 bit integer value (no query param in uri).
     *
     * @param longQuery null 64 bit integer value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> getLongNullAsync(Long longQuery, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(getLongNullAsyncWithServiceResponse(longQuery), serviceCallback);
    }

    /**
     * Get 'null 64 bit integer value (no query param in uri).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> getLongNullAsync(Long longQuery) {
        return getLongNullAsyncWithServiceResponse(longQuery).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get 'null 64 bit integer value (no query param in uri).
     *
     * @param longQuery null 64 bit integer value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> getLongNullAsyncWithServiceResponse(Long longQuery) {
        return service.getLongNull(longQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = getLongNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> getLongNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '1.034E+20' numeric value.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void floatScientificPositive() throws ErrorException, IOException {
        floatScientificPositiveAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get '1.034E+20' numeric value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> floatScientificPositiveAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(floatScientificPositiveAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get '1.034E+20' numeric value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> floatScientificPositiveAsync() {
        return floatScientificPositiveAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get '1.034E+20' numeric value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> floatScientificPositiveAsyncWithServiceResponse() {
        final double floatQuery = 1.034E+20;
        return service.floatScientificPositive(floatQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = floatScientificPositiveDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> floatScientificPositiveDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '-1.034E-20' numeric value.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void floatScientificNegative() throws ErrorException, IOException {
        floatScientificNegativeAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get '-1.034E-20' numeric value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> floatScientificNegativeAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(floatScientificNegativeAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get '-1.034E-20' numeric value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> floatScientificNegativeAsync() {
        return floatScientificNegativeAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get '-1.034E-20' numeric value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> floatScientificNegativeAsyncWithServiceResponse() {
        final double floatQuery = -1.034E-20;
        return service.floatScientificNegative(floatQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = floatScientificNegativeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> floatScientificNegativeDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void floatNull() throws ErrorException, IOException {
        floatNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> floatNullAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(floatNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> floatNullAsync() {
        return floatNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> floatNullAsyncWithServiceResponse() {
        final Double floatQuery = null;
        return service.floatNull(floatQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = floatNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @param floatQuery null numeric value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void floatNull(Double floatQuery) throws ErrorException, IOException {
        floatNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @param floatQuery null numeric value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> floatNullAsync(Double floatQuery, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(floatNullAsyncWithServiceResponse(floatQuery), serviceCallback);
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> floatNullAsync(Double floatQuery) {
        return floatNullAsyncWithServiceResponse(floatQuery).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @param floatQuery null numeric value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> floatNullAsyncWithServiceResponse(Double floatQuery) {
        return service.floatNull(floatQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = floatNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> floatNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '9999999.999' numeric value.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void doubleDecimalPositive() throws ErrorException, IOException {
        doubleDecimalPositiveAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get '9999999.999' numeric value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> doubleDecimalPositiveAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(doubleDecimalPositiveAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get '9999999.999' numeric value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> doubleDecimalPositiveAsync() {
        return doubleDecimalPositiveAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get '9999999.999' numeric value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> doubleDecimalPositiveAsyncWithServiceResponse() {
        final double doubleQuery = 9999999.999;
        return service.doubleDecimalPositive(doubleQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = doubleDecimalPositiveDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> doubleDecimalPositiveDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '-9999999.999' numeric value.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void doubleDecimalNegative() throws ErrorException, IOException {
        doubleDecimalNegativeAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get '-9999999.999' numeric value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> doubleDecimalNegativeAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(doubleDecimalNegativeAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get '-9999999.999' numeric value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> doubleDecimalNegativeAsync() {
        return doubleDecimalNegativeAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get '-9999999.999' numeric value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> doubleDecimalNegativeAsyncWithServiceResponse() {
        final double doubleQuery = -9999999.999;
        return service.doubleDecimalNegative(doubleQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = doubleDecimalNegativeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> doubleDecimalNegativeDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void doubleNull() throws ErrorException, IOException {
        doubleNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> doubleNullAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(doubleNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> doubleNullAsync() {
        return doubleNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> doubleNullAsyncWithServiceResponse() {
        final Double doubleQuery = null;
        return service.doubleNull(doubleQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = doubleNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @param doubleQuery null numeric value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void doubleNull(Double doubleQuery) throws ErrorException, IOException {
        doubleNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @param doubleQuery null numeric value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> doubleNullAsync(Double doubleQuery, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(doubleNullAsyncWithServiceResponse(doubleQuery), serviceCallback);
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> doubleNullAsync(Double doubleQuery) {
        return doubleNullAsyncWithServiceResponse(doubleQuery).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get null numeric value (no query parameter).
     *
     * @param doubleQuery null numeric value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> doubleNullAsyncWithServiceResponse(Double doubleQuery) {
        return service.doubleNull(doubleQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = doubleNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> doubleNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void stringUnicode() throws ErrorException, IOException {
        stringUnicodeAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> stringUnicodeAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(stringUnicodeAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> stringUnicodeAsync() {
        return stringUnicodeAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> stringUnicodeAsyncWithServiceResponse() {
        final String stringQuery = "啊齄丂狛狜隣郎隣兀﨩";
        return service.stringUnicode(stringQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = stringUnicodeDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> stringUnicodeDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get 'begin!*'();:@ &amp;=+$,/?#[]end.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void stringUrlEncoded() throws ErrorException, IOException {
        stringUrlEncodedAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get 'begin!*'();:@ &amp;=+$,/?#[]end.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> stringUrlEncodedAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(stringUrlEncodedAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get 'begin!*'();:@ &amp;=+$,/?#[]end.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> stringUrlEncodedAsync() {
        return stringUrlEncodedAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get 'begin!*'();:@ &amp;=+$,/?#[]end.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> stringUrlEncodedAsyncWithServiceResponse() {
        final String stringQuery = "begin!*'();:@ &=+$,/?#[]end";
        return service.stringUrlEncoded(stringQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = stringUrlEncodedDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> stringUrlEncodedDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get ''.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void stringEmpty() throws ErrorException, IOException {
        stringEmptyAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get ''.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> stringEmptyAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(stringEmptyAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get ''.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> stringEmptyAsync() {
        return stringEmptyAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get ''.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> stringEmptyAsyncWithServiceResponse() {
        final String stringQuery = "";
        return service.stringEmpty(stringQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = stringEmptyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> stringEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get null (no query parameter in url).
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void stringNull() throws ErrorException, IOException {
        stringNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get null (no query parameter in url).
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> stringNullAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(stringNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get null (no query parameter in url).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> stringNullAsync() {
        return stringNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get null (no query parameter in url).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> stringNullAsyncWithServiceResponse() {
        final String stringQuery = null;
        return service.stringNull(stringQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = stringNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get null (no query parameter in url).
     *
     * @param stringQuery null string value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void stringNull(String stringQuery) throws ErrorException, IOException {
        stringNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get null (no query parameter in url).
     *
     * @param stringQuery null string value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> stringNullAsync(String stringQuery, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(stringNullAsyncWithServiceResponse(stringQuery), serviceCallback);
    }

    /**
     * Get null (no query parameter in url).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> stringNullAsync(String stringQuery) {
        return stringNullAsyncWithServiceResponse(stringQuery).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get null (no query parameter in url).
     *
     * @param stringQuery null string value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> stringNullAsyncWithServiceResponse(String stringQuery) {
        return service.stringNull(stringQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = stringNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> stringNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get using uri with query parameter 'green color'.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void enumValid() throws ErrorException, IOException {
        enumValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get using uri with query parameter 'green color'.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> enumValidAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(enumValidAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get using uri with query parameter 'green color'.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> enumValidAsync() {
        return enumValidAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get using uri with query parameter 'green color'.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> enumValidAsyncWithServiceResponse() {
        final UriColor enumQuery = null;
        return service.enumValid(enumQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = enumValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get using uri with query parameter 'green color'.
     *
     * @param enumQuery 'green color' enum value. Possible values include: 'red color', 'green color', 'blue color'
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void enumValid(UriColor enumQuery) throws ErrorException, IOException {
        enumValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get using uri with query parameter 'green color'.
     *
     * @param enumQuery 'green color' enum value. Possible values include: 'red color', 'green color', 'blue color'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> enumValidAsync(UriColor enumQuery, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(enumValidAsyncWithServiceResponse(enumQuery), serviceCallback);
    }

    /**
     * Get using uri with query parameter 'green color'.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> enumValidAsync(UriColor enumQuery) {
        return enumValidAsyncWithServiceResponse(enumQuery).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get using uri with query parameter 'green color'.
     *
     * @param enumQuery 'green color' enum value. Possible values include: 'red color', 'green color', 'blue color'
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> enumValidAsyncWithServiceResponse(UriColor enumQuery) {
        return service.enumValid(enumQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = enumValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> enumValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get null (no query parameter in url).
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void enumNull() throws ErrorException, IOException {
        enumNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get null (no query parameter in url).
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> enumNullAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(enumNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get null (no query parameter in url).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> enumNullAsync() {
        return enumNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get null (no query parameter in url).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> enumNullAsyncWithServiceResponse() {
        final UriColor enumQuery = null;
        return service.enumNull(enumQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = enumNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get null (no query parameter in url).
     *
     * @param enumQuery null string value. Possible values include: 'red color', 'green color', 'blue color'
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void enumNull(UriColor enumQuery) throws ErrorException, IOException {
        enumNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get null (no query parameter in url).
     *
     * @param enumQuery null string value. Possible values include: 'red color', 'green color', 'blue color'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> enumNullAsync(UriColor enumQuery, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(enumNullAsyncWithServiceResponse(enumQuery), serviceCallback);
    }

    /**
     * Get null (no query parameter in url).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> enumNullAsync(UriColor enumQuery) {
        return enumNullAsyncWithServiceResponse(enumQuery).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get null (no query parameter in url).
     *
     * @param enumQuery null string value. Possible values include: 'red color', 'green color', 'blue color'
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> enumNullAsyncWithServiceResponse(UriColor enumQuery) {
        return service.enumNull(enumQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = enumNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> enumNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void byteMultiByte() throws ErrorException, IOException {
        byteMultiByteAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> byteMultiByteAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(byteMultiByteAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> byteMultiByteAsync() {
        return byteMultiByteAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> byteMultiByteAsyncWithServiceResponse() {
        final byte[] byteQuery = new byte[0];
        String byteQueryConverted = Base64.encodeBase64String(byteQuery);
        return service.byteMultiByte(byteQueryConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = byteMultiByteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @param byteQuery '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void byteMultiByte(byte[] byteQuery) throws ErrorException, IOException {
        byteMultiByteAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @param byteQuery '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> byteMultiByteAsync(byte[] byteQuery, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(byteMultiByteAsyncWithServiceResponse(byteQuery), serviceCallback);
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> byteMultiByteAsync(byte[] byteQuery) {
        return byteMultiByteAsyncWithServiceResponse(byteQuery).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array.
     *
     * @param byteQuery '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> byteMultiByteAsyncWithServiceResponse(byte[] byteQuery) {
        String byteQueryConverted = Base64.encodeBase64String(byteQuery);
        return service.byteMultiByte(byteQueryConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = byteMultiByteDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> byteMultiByteDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '' as byte array.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void byteEmpty() throws ErrorException, IOException {
        byteEmptyAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get '' as byte array.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> byteEmptyAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(byteEmptyAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get '' as byte array.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> byteEmptyAsync() {
        return byteEmptyAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get '' as byte array.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> byteEmptyAsyncWithServiceResponse() {
        final byte[] byteQuery = "".getBytes();
        String byteQueryConverted = Base64.encodeBase64String(byteQuery);
        return service.byteEmpty(byteQueryConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = byteEmptyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> byteEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get null as byte array (no query parameters in uri).
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void byteNull() throws ErrorException, IOException {
        byteNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get null as byte array (no query parameters in uri).
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> byteNullAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(byteNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get null as byte array (no query parameters in uri).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> byteNullAsync() {
        return byteNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get null as byte array (no query parameters in uri).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> byteNullAsyncWithServiceResponse() {
        final byte[] byteQuery = new byte[0];
        String byteQueryConverted = Base64.encodeBase64String(byteQuery);
        return service.byteNull(byteQueryConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = byteNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get null as byte array (no query parameters in uri).
     *
     * @param byteQuery null as byte array (no query parameters in uri)
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void byteNull(byte[] byteQuery) throws ErrorException, IOException {
        byteNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get null as byte array (no query parameters in uri).
     *
     * @param byteQuery null as byte array (no query parameters in uri)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> byteNullAsync(byte[] byteQuery, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(byteNullAsyncWithServiceResponse(byteQuery), serviceCallback);
    }

    /**
     * Get null as byte array (no query parameters in uri).
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> byteNullAsync(byte[] byteQuery) {
        return byteNullAsyncWithServiceResponse(byteQuery).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get null as byte array (no query parameters in uri).
     *
     * @param byteQuery null as byte array (no query parameters in uri)
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> byteNullAsyncWithServiceResponse(byte[] byteQuery) {
        String byteQueryConverted = Base64.encodeBase64String(byteQuery);
        return service.byteNull(byteQueryConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = byteNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> byteNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '2012-01-01' as date.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void dateValid() throws ErrorException, IOException {
        dateValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get '2012-01-01' as date.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> dateValidAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(dateValidAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get '2012-01-01' as date.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> dateValidAsync() {
        return dateValidAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get '2012-01-01' as date.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> dateValidAsyncWithServiceResponse() {
        final LocalDate dateQuery = LocalDate.parse("2012-01-01");
        return service.dateValid(dateQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = dateValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> dateValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get null as date - this should result in no query parameters in uri.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void dateNull() throws ErrorException, IOException {
        dateNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get null as date - this should result in no query parameters in uri.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> dateNullAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(dateNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get null as date - this should result in no query parameters in uri.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> dateNullAsync() {
        return dateNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get null as date - this should result in no query parameters in uri.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> dateNullAsyncWithServiceResponse() {
        final LocalDate dateQuery = null;
        return service.dateNull(dateQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = dateNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get null as date - this should result in no query parameters in uri.
     *
     * @param dateQuery null as date (no query parameters in uri)
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void dateNull(LocalDate dateQuery) throws ErrorException, IOException {
        dateNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get null as date - this should result in no query parameters in uri.
     *
     * @param dateQuery null as date (no query parameters in uri)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> dateNullAsync(LocalDate dateQuery, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(dateNullAsyncWithServiceResponse(dateQuery), serviceCallback);
    }

    /**
     * Get null as date - this should result in no query parameters in uri.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> dateNullAsync(LocalDate dateQuery) {
        return dateNullAsyncWithServiceResponse(dateQuery).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get null as date - this should result in no query parameters in uri.
     *
     * @param dateQuery null as date (no query parameters in uri)
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> dateNullAsyncWithServiceResponse(LocalDate dateQuery) {
        return service.dateNull(dateQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = dateNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> dateNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get '2012-01-01T01:01:01Z' as date-time.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void dateTimeValid() throws ErrorException, IOException {
        dateTimeValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get '2012-01-01T01:01:01Z' as date-time.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> dateTimeValidAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(dateTimeValidAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get '2012-01-01T01:01:01Z' as date-time.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> dateTimeValidAsync() {
        return dateTimeValidAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get '2012-01-01T01:01:01Z' as date-time.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> dateTimeValidAsyncWithServiceResponse() {
        final DateTime dateTimeQuery = DateTime.parse("2012-01-01T01:01:01Z");
        return service.dateTimeValid(dateTimeQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = dateTimeValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> dateTimeValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get null as date-time, should result in no query parameters in uri.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void dateTimeNull() throws ErrorException, IOException {
        dateTimeNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get null as date-time, should result in no query parameters in uri.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> dateTimeNullAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(dateTimeNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get null as date-time, should result in no query parameters in uri.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> dateTimeNullAsync() {
        return dateTimeNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get null as date-time, should result in no query parameters in uri.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> dateTimeNullAsyncWithServiceResponse() {
        final DateTime dateTimeQuery = null;
        return service.dateTimeNull(dateTimeQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = dateTimeNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get null as date-time, should result in no query parameters in uri.
     *
     * @param dateTimeQuery null as date-time (no query parameters)
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void dateTimeNull(DateTime dateTimeQuery) throws ErrorException, IOException {
        dateTimeNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get null as date-time, should result in no query parameters in uri.
     *
     * @param dateTimeQuery null as date-time (no query parameters)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> dateTimeNullAsync(DateTime dateTimeQuery, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(dateTimeNullAsyncWithServiceResponse(dateTimeQuery), serviceCallback);
    }

    /**
     * Get null as date-time, should result in no query parameters in uri.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> dateTimeNullAsync(DateTime dateTimeQuery) {
        return dateTimeNullAsyncWithServiceResponse(dateTimeQuery).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get null as date-time, should result in no query parameters in uri.
     *
     * @param dateTimeQuery null as date-time (no query parameters)
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> dateTimeNullAsyncWithServiceResponse(DateTime dateTimeQuery) {
        return service.dateTimeNull(dateTimeQuery)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = dateTimeNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> dateTimeNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void arrayStringCsvValid() throws ErrorException, IOException {
        arrayStringCsvValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> arrayStringCsvValidAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(arrayStringCsvValidAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> arrayStringCsvValidAsync() {
        return arrayStringCsvValidAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> arrayStringCsvValidAsyncWithServiceResponse() {
        final List<String> arrayQuery = null;
        String arrayQueryConverted = this.client.mapperAdapter().serializeList(arrayQuery, CollectionFormat.CSV);
        return service.arrayStringCsvValid(arrayQueryConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = arrayStringCsvValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void arrayStringCsvValid(List<String> arrayQuery) throws ErrorException, IOException {
        arrayStringCsvValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> arrayStringCsvValidAsync(List<String> arrayQuery, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(arrayStringCsvValidAsyncWithServiceResponse(arrayQuery), serviceCallback);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> arrayStringCsvValidAsync(List<String> arrayQuery) {
        return arrayStringCsvValidAsyncWithServiceResponse(arrayQuery).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the csv-array format
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> arrayStringCsvValidAsyncWithServiceResponse(List<String> arrayQuery) {
        Validator.validate(arrayQuery);
        String arrayQueryConverted = this.client.mapperAdapter().serializeList(arrayQuery, CollectionFormat.CSV);
        return service.arrayStringCsvValid(arrayQueryConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = arrayStringCsvValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> arrayStringCsvValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get a null array of string using the csv-array format.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void arrayStringCsvNull() throws ErrorException, IOException {
        arrayStringCsvNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get a null array of string using the csv-array format.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> arrayStringCsvNullAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(arrayStringCsvNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get a null array of string using the csv-array format.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> arrayStringCsvNullAsync() {
        return arrayStringCsvNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get a null array of string using the csv-array format.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> arrayStringCsvNullAsyncWithServiceResponse() {
        final List<String> arrayQuery = null;
        String arrayQueryConverted = this.client.mapperAdapter().serializeList(arrayQuery, CollectionFormat.CSV);
        return service.arrayStringCsvNull(arrayQueryConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = arrayStringCsvNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get a null array of string using the csv-array format.
     *
     * @param arrayQuery a null array of string using the csv-array format
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void arrayStringCsvNull(List<String> arrayQuery) throws ErrorException, IOException {
        arrayStringCsvNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get a null array of string using the csv-array format.
     *
     * @param arrayQuery a null array of string using the csv-array format
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> arrayStringCsvNullAsync(List<String> arrayQuery, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(arrayStringCsvNullAsyncWithServiceResponse(arrayQuery), serviceCallback);
    }

    /**
     * Get a null array of string using the csv-array format.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> arrayStringCsvNullAsync(List<String> arrayQuery) {
        return arrayStringCsvNullAsyncWithServiceResponse(arrayQuery).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get a null array of string using the csv-array format.
     *
     * @param arrayQuery a null array of string using the csv-array format
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> arrayStringCsvNullAsyncWithServiceResponse(List<String> arrayQuery) {
        Validator.validate(arrayQuery);
        String arrayQueryConverted = this.client.mapperAdapter().serializeList(arrayQuery, CollectionFormat.CSV);
        return service.arrayStringCsvNull(arrayQueryConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = arrayStringCsvNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> arrayStringCsvNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an empty array [] of string using the csv-array format.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void arrayStringCsvEmpty() throws ErrorException, IOException {
        arrayStringCsvEmptyAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get an empty array [] of string using the csv-array format.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> arrayStringCsvEmptyAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(arrayStringCsvEmptyAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get an empty array [] of string using the csv-array format.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> arrayStringCsvEmptyAsync() {
        return arrayStringCsvEmptyAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get an empty array [] of string using the csv-array format.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> arrayStringCsvEmptyAsyncWithServiceResponse() {
        final List<String> arrayQuery = null;
        String arrayQueryConverted = this.client.mapperAdapter().serializeList(arrayQuery, CollectionFormat.CSV);
        return service.arrayStringCsvEmpty(arrayQueryConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = arrayStringCsvEmptyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get an empty array [] of string using the csv-array format.
     *
     * @param arrayQuery an empty array [] of string using the csv-array format
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void arrayStringCsvEmpty(List<String> arrayQuery) throws ErrorException, IOException {
        arrayStringCsvEmptyAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get an empty array [] of string using the csv-array format.
     *
     * @param arrayQuery an empty array [] of string using the csv-array format
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> arrayStringCsvEmptyAsync(List<String> arrayQuery, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(arrayStringCsvEmptyAsyncWithServiceResponse(arrayQuery), serviceCallback);
    }

    /**
     * Get an empty array [] of string using the csv-array format.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> arrayStringCsvEmptyAsync(List<String> arrayQuery) {
        return arrayStringCsvEmptyAsyncWithServiceResponse(arrayQuery).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get an empty array [] of string using the csv-array format.
     *
     * @param arrayQuery an empty array [] of string using the csv-array format
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> arrayStringCsvEmptyAsyncWithServiceResponse(List<String> arrayQuery) {
        Validator.validate(arrayQuery);
        String arrayQueryConverted = this.client.mapperAdapter().serializeList(arrayQuery, CollectionFormat.CSV);
        return service.arrayStringCsvEmpty(arrayQueryConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = arrayStringCsvEmptyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> arrayStringCsvEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void arrayStringSsvValid() throws ErrorException, IOException {
        arrayStringSsvValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> arrayStringSsvValidAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(arrayStringSsvValidAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> arrayStringSsvValidAsync() {
        return arrayStringSsvValidAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> arrayStringSsvValidAsyncWithServiceResponse() {
        final List<String> arrayQuery = null;
        String arrayQueryConverted = this.client.mapperAdapter().serializeList(arrayQuery, CollectionFormat.SSV);
        return service.arrayStringSsvValid(arrayQueryConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = arrayStringSsvValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void arrayStringSsvValid(List<String> arrayQuery) throws ErrorException, IOException {
        arrayStringSsvValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> arrayStringSsvValidAsync(List<String> arrayQuery, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(arrayStringSsvValidAsyncWithServiceResponse(arrayQuery), serviceCallback);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> arrayStringSsvValidAsync(List<String> arrayQuery) {
        return arrayStringSsvValidAsyncWithServiceResponse(arrayQuery).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the ssv-array format
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> arrayStringSsvValidAsyncWithServiceResponse(List<String> arrayQuery) {
        Validator.validate(arrayQuery);
        String arrayQueryConverted = this.client.mapperAdapter().serializeList(arrayQuery, CollectionFormat.SSV);
        return service.arrayStringSsvValid(arrayQueryConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = arrayStringSsvValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> arrayStringSsvValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void arrayStringTsvValid() throws ErrorException, IOException {
        arrayStringTsvValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> arrayStringTsvValidAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(arrayStringTsvValidAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> arrayStringTsvValidAsync() {
        return arrayStringTsvValidAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> arrayStringTsvValidAsyncWithServiceResponse() {
        final List<String> arrayQuery = null;
        String arrayQueryConverted = this.client.mapperAdapter().serializeList(arrayQuery, CollectionFormat.TSV);
        return service.arrayStringTsvValid(arrayQueryConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = arrayStringTsvValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void arrayStringTsvValid(List<String> arrayQuery) throws ErrorException, IOException {
        arrayStringTsvValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> arrayStringTsvValidAsync(List<String> arrayQuery, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(arrayStringTsvValidAsyncWithServiceResponse(arrayQuery), serviceCallback);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> arrayStringTsvValidAsync(List<String> arrayQuery) {
        return arrayStringTsvValidAsyncWithServiceResponse(arrayQuery).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the tsv-array format
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> arrayStringTsvValidAsyncWithServiceResponse(List<String> arrayQuery) {
        Validator.validate(arrayQuery);
        String arrayQueryConverted = this.client.mapperAdapter().serializeList(arrayQuery, CollectionFormat.TSV);
        return service.arrayStringTsvValid(arrayQueryConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = arrayStringTsvValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> arrayStringTsvValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void arrayStringPipesValid() throws ErrorException, IOException {
        arrayStringPipesValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> arrayStringPipesValidAsync(final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(arrayStringPipesValidAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> arrayStringPipesValidAsync() {
        return arrayStringPipesValidAsyncWithServiceResponse().map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> arrayStringPipesValidAsyncWithServiceResponse() {
        final List<String> arrayQuery = null;
        String arrayQueryConverted = this.client.mapperAdapter().serializeList(arrayQuery, CollectionFormat.PIPES);
        return service.arrayStringPipesValid(arrayQueryConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = arrayStringPipesValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the {@link ServiceResponse} object if successful.
     */
    public void arrayStringPipesValid(List<String> arrayQuery) throws ErrorException, IOException {
        arrayStringPipesValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> arrayStringPipesValidAsync(List<String> arrayQuery, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(arrayStringPipesValidAsyncWithServiceResponse(arrayQuery), serviceCallback);
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format.
     *
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> arrayStringPipesValidAsync(List<String> arrayQuery) {
        return arrayStringPipesValidAsyncWithServiceResponse(arrayQuery).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format.
     *
     * @param arrayQuery an array of string ['ArrayQuery1', 'begin!*'();:@ &amp;=+$,/?#[]end' , null, ''] using the pipes-array format
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> arrayStringPipesValidAsyncWithServiceResponse(List<String> arrayQuery) {
        Validator.validate(arrayQuery);
        String arrayQueryConverted = this.client.mapperAdapter().serializeList(arrayQuery, CollectionFormat.PIPES);
        return service.arrayStringPipesValid(arrayQueryConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = arrayStringPipesValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> arrayStringPipesValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

}
