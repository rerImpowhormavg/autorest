/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package fixtures.bodydictionary.implementation;

import retrofit2.Retrofit;
import fixtures.bodydictionary.Dictionarys;
import com.google.common.reflect.TypeToken;
import com.microsoft.rest.Base64Url;
import com.microsoft.rest.DateTimeRfc1123;
import com.microsoft.rest.ServiceCall;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseBuilder;
import com.microsoft.rest.Validator;
import fixtures.bodydictionary.models.ErrorException;
import fixtures.bodydictionary.models.Widget;
import java.io.IOException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import okhttp3.ResponseBody;
import org.joda.time.DateTime;
import org.joda.time.LocalDate;
import org.joda.time.Period;
import retrofit2.http.Body;
import retrofit2.http.GET;
import retrofit2.http.Headers;
import retrofit2.http.PUT;
import retrofit2.Response;
import rx.functions.Func1;
import rx.Observable;

/**
 * An instance of this class provides access to all the operations defined
 * in Dictionarys.
 */
public final class DictionarysImpl implements Dictionarys {
    /** The Retrofit service to perform REST calls. */
    private DictionarysService service;
    /** The service client containing this operation class. */
    private AutoRestSwaggerBATdictionaryServiceImpl client;

    /**
     * Initializes an instance of Dictionarys.
     *
     * @param retrofit the Retrofit instance built from a Retrofit Builder.
     * @param client the instance of the service client containing this operation class.
     */
    public DictionarysImpl(Retrofit retrofit, AutoRestSwaggerBATdictionaryServiceImpl client) {
        this.service = retrofit.create(DictionarysService.class);
        this.client = client;
    }

    /**
     * The interface defining all the services for Dictionarys to be
     * used by Retrofit to perform actually REST calls.
     */
    interface DictionarysService {
        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/null")
        Observable<Response<ResponseBody>> getNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/empty")
        Observable<Response<ResponseBody>> getEmpty();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("dictionary/empty")
        Observable<Response<ResponseBody>> putEmpty(@Body Map<String, String> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/nullvalue")
        Observable<Response<ResponseBody>> getNullValue();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/nullkey")
        Observable<Response<ResponseBody>> getNullKey();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/keyemptystring")
        Observable<Response<ResponseBody>> getEmptyStringKey();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/invalid")
        Observable<Response<ResponseBody>> getInvalid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/boolean/tfft")
        Observable<Response<ResponseBody>> getBooleanTfft();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("dictionary/prim/boolean/tfft")
        Observable<Response<ResponseBody>> putBooleanTfft(@Body Map<String, Boolean> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/boolean/true.null.false")
        Observable<Response<ResponseBody>> getBooleanInvalidNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/boolean/true.boolean.false")
        Observable<Response<ResponseBody>> getBooleanInvalidString();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/integer/1.-1.3.300")
        Observable<Response<ResponseBody>> getIntegerValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("dictionary/prim/integer/1.-1.3.300")
        Observable<Response<ResponseBody>> putIntegerValid(@Body Map<String, Integer> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/integer/1.null.zero")
        Observable<Response<ResponseBody>> getIntInvalidNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/integer/1.integer.0")
        Observable<Response<ResponseBody>> getIntInvalidString();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/long/1.-1.3.300")
        Observable<Response<ResponseBody>> getLongValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("dictionary/prim/long/1.-1.3.300")
        Observable<Response<ResponseBody>> putLongValid(@Body Map<String, Long> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/long/1.null.zero")
        Observable<Response<ResponseBody>> getLongInvalidNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/long/1.integer.0")
        Observable<Response<ResponseBody>> getLongInvalidString();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/float/0--0.01-1.2e20")
        Observable<Response<ResponseBody>> getFloatValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("dictionary/prim/float/0--0.01-1.2e20")
        Observable<Response<ResponseBody>> putFloatValid(@Body Map<String, Double> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/float/0.0-null-1.2e20")
        Observable<Response<ResponseBody>> getFloatInvalidNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/float/1.number.0")
        Observable<Response<ResponseBody>> getFloatInvalidString();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/double/0--0.01-1.2e20")
        Observable<Response<ResponseBody>> getDoubleValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("dictionary/prim/double/0--0.01-1.2e20")
        Observable<Response<ResponseBody>> putDoubleValid(@Body Map<String, Double> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/double/0.0-null-1.2e20")
        Observable<Response<ResponseBody>> getDoubleInvalidNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/double/1.number.0")
        Observable<Response<ResponseBody>> getDoubleInvalidString();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/string/foo1.foo2.foo3")
        Observable<Response<ResponseBody>> getStringValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("dictionary/prim/string/foo1.foo2.foo3")
        Observable<Response<ResponseBody>> putStringValid(@Body Map<String, String> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/string/foo.null.foo2")
        Observable<Response<ResponseBody>> getStringWithNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/string/foo.123.foo2")
        Observable<Response<ResponseBody>> getStringWithInvalid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/date/valid")
        Observable<Response<ResponseBody>> getDateValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("dictionary/prim/date/valid")
        Observable<Response<ResponseBody>> putDateValid(@Body Map<String, LocalDate> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/date/invalidnull")
        Observable<Response<ResponseBody>> getDateInvalidNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/date/invalidchars")
        Observable<Response<ResponseBody>> getDateInvalidChars();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/date-time/valid")
        Observable<Response<ResponseBody>> getDateTimeValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("dictionary/prim/date-time/valid")
        Observable<Response<ResponseBody>> putDateTimeValid(@Body Map<String, DateTime> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/date-time/invalidnull")
        Observable<Response<ResponseBody>> getDateTimeInvalidNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/date-time/invalidchars")
        Observable<Response<ResponseBody>> getDateTimeInvalidChars();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/date-time-rfc1123/valid")
        Observable<Response<ResponseBody>> getDateTimeRfc1123Valid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("dictionary/prim/date-time-rfc1123/valid")
        Observable<Response<ResponseBody>> putDateTimeRfc1123Valid(@Body Map<String, DateTimeRfc1123> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/duration/valid")
        Observable<Response<ResponseBody>> getDurationValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("dictionary/prim/duration/valid")
        Observable<Response<ResponseBody>> putDurationValid(@Body Map<String, Period> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/byte/valid")
        Observable<Response<ResponseBody>> getByteValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("dictionary/prim/byte/valid")
        Observable<Response<ResponseBody>> putByteValid(@Body Map<String, byte[]> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/byte/invalidnull")
        Observable<Response<ResponseBody>> getByteInvalidNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/prim/base64url/valid")
        Observable<Response<ResponseBody>> getBase64Url();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/complex/null")
        Observable<Response<ResponseBody>> getComplexNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/complex/empty")
        Observable<Response<ResponseBody>> getComplexEmpty();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/complex/itemnull")
        Observable<Response<ResponseBody>> getComplexItemNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/complex/itemempty")
        Observable<Response<ResponseBody>> getComplexItemEmpty();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/complex/valid")
        Observable<Response<ResponseBody>> getComplexValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("dictionary/complex/valid")
        Observable<Response<ResponseBody>> putComplexValid(@Body Map<String, Widget> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/array/null")
        Observable<Response<ResponseBody>> getArrayNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/array/empty")
        Observable<Response<ResponseBody>> getArrayEmpty();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/array/itemnull")
        Observable<Response<ResponseBody>> getArrayItemNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/array/itemempty")
        Observable<Response<ResponseBody>> getArrayItemEmpty();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/array/valid")
        Observable<Response<ResponseBody>> getArrayValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("dictionary/array/valid")
        Observable<Response<ResponseBody>> putArrayValid(@Body Map<String, List<String>> arrayBody);

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/dictionary/null")
        Observable<Response<ResponseBody>> getDictionaryNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/dictionary/empty")
        Observable<Response<ResponseBody>> getDictionaryEmpty();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/dictionary/itemnull")
        Observable<Response<ResponseBody>> getDictionaryItemNull();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/dictionary/itemempty")
        Observable<Response<ResponseBody>> getDictionaryItemEmpty();

        @Headers("Content-Type: application/json; charset=utf-8")
        @GET("dictionary/dictionary/valid")
        Observable<Response<ResponseBody>> getDictionaryValid();

        @Headers("Content-Type: application/json; charset=utf-8")
        @PUT("dictionary/dictionary/valid")
        Observable<Response<ResponseBody>> putDictionaryValid(@Body Map<String, Map<String, String>> arrayBody);

    }

    /**
     * Get null dictionary value.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Integer&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Integer> getNull() throws ErrorException, IOException {
        return getNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get null dictionary value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Integer>> getNullAsync(final ServiceCallback<Map<String, Integer>> serviceCallback) {
        return ServiceCall.create(getNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get null dictionary value.
     *
     * @return the observable to the Map&lt;String, Integer&gt; object
     */
    public Observable<Map<String, Integer>> getNullAsync() {
        return getNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Integer>>, Map<String, Integer>>() {
            @Override
            public Map<String, Integer> call(ServiceResponse<Map<String, Integer>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get null dictionary value.
     *
     * @return the observable to the Map&lt;String, Integer&gt; object
     */
    public Observable<ServiceResponse<Map<String, Integer>>> getNullAsyncWithServiceResponse() {
        return service.getNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Integer>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Integer>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Integer>> clientResponse = getNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Integer>> getNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Integer>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Integer>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get empty dictionary value {}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Integer&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Integer> getEmpty() throws ErrorException, IOException {
        return getEmptyAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get empty dictionary value {}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Integer>> getEmptyAsync(final ServiceCallback<Map<String, Integer>> serviceCallback) {
        return ServiceCall.create(getEmptyAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get empty dictionary value {}.
     *
     * @return the observable to the Map&lt;String, Integer&gt; object
     */
    public Observable<Map<String, Integer>> getEmptyAsync() {
        return getEmptyAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Integer>>, Map<String, Integer>>() {
            @Override
            public Map<String, Integer> call(ServiceResponse<Map<String, Integer>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get empty dictionary value {}.
     *
     * @return the observable to the Map&lt;String, Integer&gt; object
     */
    public Observable<ServiceResponse<Map<String, Integer>>> getEmptyAsyncWithServiceResponse() {
        return service.getEmpty()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Integer>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Integer>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Integer>> clientResponse = getEmptyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Integer>> getEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Integer>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Integer>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set dictionary value empty {}.
     *
     * @param arrayBody the Map&lt;String, String&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putEmpty(Map<String, String> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        putEmptyAsyncWithServiceResponse(arrayBody).toBlocking().single().getBody();
    }

    /**
     * Set dictionary value empty {}.
     *
     * @param arrayBody the Map&lt;String, String&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putEmptyAsync(Map<String, String> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putEmptyAsyncWithServiceResponse(arrayBody), serviceCallback);
    }

    /**
     * Set dictionary value empty {}.
     *
     * @param arrayBody the Map&lt;String, String&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putEmptyAsync(Map<String, String> arrayBody) {
        return putEmptyAsyncWithServiceResponse(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Set dictionary value empty {}.
     *
     * @param arrayBody the Map&lt;String, String&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putEmptyAsyncWithServiceResponse(Map<String, String> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putEmpty(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putEmptyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get Dictionary with null value.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, String&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, String> getNullValue() throws ErrorException, IOException {
        return getNullValueAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get Dictionary with null value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, String>> getNullValueAsync(final ServiceCallback<Map<String, String>> serviceCallback) {
        return ServiceCall.create(getNullValueAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get Dictionary with null value.
     *
     * @return the observable to the Map&lt;String, String&gt; object
     */
    public Observable<Map<String, String>> getNullValueAsync() {
        return getNullValueAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, String>>, Map<String, String>>() {
            @Override
            public Map<String, String> call(ServiceResponse<Map<String, String>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get Dictionary with null value.
     *
     * @return the observable to the Map&lt;String, String&gt; object
     */
    public Observable<ServiceResponse<Map<String, String>>> getNullValueAsyncWithServiceResponse() {
        return service.getNullValue()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, String>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, String>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, String>> clientResponse = getNullValueDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, String>> getNullValueDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, String>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, String>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get Dictionary with null key.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, String&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, String> getNullKey() throws ErrorException, IOException {
        return getNullKeyAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get Dictionary with null key.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, String>> getNullKeyAsync(final ServiceCallback<Map<String, String>> serviceCallback) {
        return ServiceCall.create(getNullKeyAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get Dictionary with null key.
     *
     * @return the observable to the Map&lt;String, String&gt; object
     */
    public Observable<Map<String, String>> getNullKeyAsync() {
        return getNullKeyAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, String>>, Map<String, String>>() {
            @Override
            public Map<String, String> call(ServiceResponse<Map<String, String>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get Dictionary with null key.
     *
     * @return the observable to the Map&lt;String, String&gt; object
     */
    public Observable<ServiceResponse<Map<String, String>>> getNullKeyAsyncWithServiceResponse() {
        return service.getNullKey()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, String>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, String>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, String>> clientResponse = getNullKeyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, String>> getNullKeyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, String>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, String>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get Dictionary with key as empty string.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, String&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, String> getEmptyStringKey() throws ErrorException, IOException {
        return getEmptyStringKeyAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get Dictionary with key as empty string.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, String>> getEmptyStringKeyAsync(final ServiceCallback<Map<String, String>> serviceCallback) {
        return ServiceCall.create(getEmptyStringKeyAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get Dictionary with key as empty string.
     *
     * @return the observable to the Map&lt;String, String&gt; object
     */
    public Observable<Map<String, String>> getEmptyStringKeyAsync() {
        return getEmptyStringKeyAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, String>>, Map<String, String>>() {
            @Override
            public Map<String, String> call(ServiceResponse<Map<String, String>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get Dictionary with key as empty string.
     *
     * @return the observable to the Map&lt;String, String&gt; object
     */
    public Observable<ServiceResponse<Map<String, String>>> getEmptyStringKeyAsyncWithServiceResponse() {
        return service.getEmptyStringKey()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, String>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, String>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, String>> clientResponse = getEmptyStringKeyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, String>> getEmptyStringKeyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, String>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, String>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get invalid Dictionary value.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, String&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, String> getInvalid() throws ErrorException, IOException {
        return getInvalidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get invalid Dictionary value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, String>> getInvalidAsync(final ServiceCallback<Map<String, String>> serviceCallback) {
        return ServiceCall.create(getInvalidAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get invalid Dictionary value.
     *
     * @return the observable to the Map&lt;String, String&gt; object
     */
    public Observable<Map<String, String>> getInvalidAsync() {
        return getInvalidAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, String>>, Map<String, String>>() {
            @Override
            public Map<String, String> call(ServiceResponse<Map<String, String>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get invalid Dictionary value.
     *
     * @return the observable to the Map&lt;String, String&gt; object
     */
    public Observable<ServiceResponse<Map<String, String>>> getInvalidAsyncWithServiceResponse() {
        return service.getInvalid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, String>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, String>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, String>> clientResponse = getInvalidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, String>> getInvalidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, String>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, String>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get boolean dictionary value {"0": true, "1": false, "2": false, "3": true }.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Boolean&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Boolean> getBooleanTfft() throws ErrorException, IOException {
        return getBooleanTfftAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get boolean dictionary value {"0": true, "1": false, "2": false, "3": true }.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Boolean>> getBooleanTfftAsync(final ServiceCallback<Map<String, Boolean>> serviceCallback) {
        return ServiceCall.create(getBooleanTfftAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get boolean dictionary value {"0": true, "1": false, "2": false, "3": true }.
     *
     * @return the observable to the Map&lt;String, Boolean&gt; object
     */
    public Observable<Map<String, Boolean>> getBooleanTfftAsync() {
        return getBooleanTfftAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Boolean>>, Map<String, Boolean>>() {
            @Override
            public Map<String, Boolean> call(ServiceResponse<Map<String, Boolean>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get boolean dictionary value {"0": true, "1": false, "2": false, "3": true }.
     *
     * @return the observable to the Map&lt;String, Boolean&gt; object
     */
    public Observable<ServiceResponse<Map<String, Boolean>>> getBooleanTfftAsyncWithServiceResponse() {
        return service.getBooleanTfft()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Boolean>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Boolean>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Boolean>> clientResponse = getBooleanTfftDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Boolean>> getBooleanTfftDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Boolean>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Boolean>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set dictionary value empty {"0": true, "1": false, "2": false, "3": true }.
     *
     * @param arrayBody the Map&lt;String, Boolean&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putBooleanTfft(Map<String, Boolean> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        putBooleanTfftAsyncWithServiceResponse(arrayBody).toBlocking().single().getBody();
    }

    /**
     * Set dictionary value empty {"0": true, "1": false, "2": false, "3": true }.
     *
     * @param arrayBody the Map&lt;String, Boolean&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putBooleanTfftAsync(Map<String, Boolean> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putBooleanTfftAsyncWithServiceResponse(arrayBody), serviceCallback);
    }

    /**
     * Set dictionary value empty {"0": true, "1": false, "2": false, "3": true }.
     *
     * @param arrayBody the Map&lt;String, Boolean&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putBooleanTfftAsync(Map<String, Boolean> arrayBody) {
        return putBooleanTfftAsyncWithServiceResponse(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Set dictionary value empty {"0": true, "1": false, "2": false, "3": true }.
     *
     * @param arrayBody the Map&lt;String, Boolean&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putBooleanTfftAsyncWithServiceResponse(Map<String, Boolean> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putBooleanTfft(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putBooleanTfftDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putBooleanTfftDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get boolean dictionary value {"0": true, "1": null, "2": false }.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Boolean&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Boolean> getBooleanInvalidNull() throws ErrorException, IOException {
        return getBooleanInvalidNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get boolean dictionary value {"0": true, "1": null, "2": false }.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Boolean>> getBooleanInvalidNullAsync(final ServiceCallback<Map<String, Boolean>> serviceCallback) {
        return ServiceCall.create(getBooleanInvalidNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get boolean dictionary value {"0": true, "1": null, "2": false }.
     *
     * @return the observable to the Map&lt;String, Boolean&gt; object
     */
    public Observable<Map<String, Boolean>> getBooleanInvalidNullAsync() {
        return getBooleanInvalidNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Boolean>>, Map<String, Boolean>>() {
            @Override
            public Map<String, Boolean> call(ServiceResponse<Map<String, Boolean>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get boolean dictionary value {"0": true, "1": null, "2": false }.
     *
     * @return the observable to the Map&lt;String, Boolean&gt; object
     */
    public Observable<ServiceResponse<Map<String, Boolean>>> getBooleanInvalidNullAsyncWithServiceResponse() {
        return service.getBooleanInvalidNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Boolean>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Boolean>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Boolean>> clientResponse = getBooleanInvalidNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Boolean>> getBooleanInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Boolean>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Boolean>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get boolean dictionary value '{"0": true, "1": "boolean", "2": false}'.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Boolean&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Boolean> getBooleanInvalidString() throws ErrorException, IOException {
        return getBooleanInvalidStringAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get boolean dictionary value '{"0": true, "1": "boolean", "2": false}'.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Boolean>> getBooleanInvalidStringAsync(final ServiceCallback<Map<String, Boolean>> serviceCallback) {
        return ServiceCall.create(getBooleanInvalidStringAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get boolean dictionary value '{"0": true, "1": "boolean", "2": false}'.
     *
     * @return the observable to the Map&lt;String, Boolean&gt; object
     */
    public Observable<Map<String, Boolean>> getBooleanInvalidStringAsync() {
        return getBooleanInvalidStringAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Boolean>>, Map<String, Boolean>>() {
            @Override
            public Map<String, Boolean> call(ServiceResponse<Map<String, Boolean>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get boolean dictionary value '{"0": true, "1": "boolean", "2": false}'.
     *
     * @return the observable to the Map&lt;String, Boolean&gt; object
     */
    public Observable<ServiceResponse<Map<String, Boolean>>> getBooleanInvalidStringAsyncWithServiceResponse() {
        return service.getBooleanInvalidString()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Boolean>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Boolean>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Boolean>> clientResponse = getBooleanInvalidStringDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Boolean>> getBooleanInvalidStringDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Boolean>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Boolean>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Integer&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Integer> getIntegerValid() throws ErrorException, IOException {
        return getIntegerValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Integer>> getIntegerValidAsync(final ServiceCallback<Map<String, Integer>> serviceCallback) {
        return ServiceCall.create(getIntegerValidAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @return the observable to the Map&lt;String, Integer&gt; object
     */
    public Observable<Map<String, Integer>> getIntegerValidAsync() {
        return getIntegerValidAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Integer>>, Map<String, Integer>>() {
            @Override
            public Map<String, Integer> call(ServiceResponse<Map<String, Integer>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @return the observable to the Map&lt;String, Integer&gt; object
     */
    public Observable<ServiceResponse<Map<String, Integer>>> getIntegerValidAsyncWithServiceResponse() {
        return service.getIntegerValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Integer>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Integer>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Integer>> clientResponse = getIntegerValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Integer>> getIntegerValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Integer>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Integer>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @param arrayBody the Map&lt;String, Integer&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putIntegerValid(Map<String, Integer> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        putIntegerValidAsyncWithServiceResponse(arrayBody).toBlocking().single().getBody();
    }

    /**
     * Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @param arrayBody the Map&lt;String, Integer&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putIntegerValidAsync(Map<String, Integer> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putIntegerValidAsyncWithServiceResponse(arrayBody), serviceCallback);
    }

    /**
     * Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @param arrayBody the Map&lt;String, Integer&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putIntegerValidAsync(Map<String, Integer> arrayBody) {
        return putIntegerValidAsyncWithServiceResponse(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @param arrayBody the Map&lt;String, Integer&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putIntegerValidAsyncWithServiceResponse(Map<String, Integer> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putIntegerValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putIntegerValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putIntegerValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get integer dictionary value {"0": 1, "1": null, "2": 0}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Integer&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Integer> getIntInvalidNull() throws ErrorException, IOException {
        return getIntInvalidNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get integer dictionary value {"0": 1, "1": null, "2": 0}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Integer>> getIntInvalidNullAsync(final ServiceCallback<Map<String, Integer>> serviceCallback) {
        return ServiceCall.create(getIntInvalidNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get integer dictionary value {"0": 1, "1": null, "2": 0}.
     *
     * @return the observable to the Map&lt;String, Integer&gt; object
     */
    public Observable<Map<String, Integer>> getIntInvalidNullAsync() {
        return getIntInvalidNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Integer>>, Map<String, Integer>>() {
            @Override
            public Map<String, Integer> call(ServiceResponse<Map<String, Integer>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get integer dictionary value {"0": 1, "1": null, "2": 0}.
     *
     * @return the observable to the Map&lt;String, Integer&gt; object
     */
    public Observable<ServiceResponse<Map<String, Integer>>> getIntInvalidNullAsyncWithServiceResponse() {
        return service.getIntInvalidNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Integer>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Integer>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Integer>> clientResponse = getIntInvalidNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Integer>> getIntInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Integer>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Integer>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get integer dictionary value {"0": 1, "1": "integer", "2": 0}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Integer&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Integer> getIntInvalidString() throws ErrorException, IOException {
        return getIntInvalidStringAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get integer dictionary value {"0": 1, "1": "integer", "2": 0}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Integer>> getIntInvalidStringAsync(final ServiceCallback<Map<String, Integer>> serviceCallback) {
        return ServiceCall.create(getIntInvalidStringAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get integer dictionary value {"0": 1, "1": "integer", "2": 0}.
     *
     * @return the observable to the Map&lt;String, Integer&gt; object
     */
    public Observable<Map<String, Integer>> getIntInvalidStringAsync() {
        return getIntInvalidStringAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Integer>>, Map<String, Integer>>() {
            @Override
            public Map<String, Integer> call(ServiceResponse<Map<String, Integer>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get integer dictionary value {"0": 1, "1": "integer", "2": 0}.
     *
     * @return the observable to the Map&lt;String, Integer&gt; object
     */
    public Observable<ServiceResponse<Map<String, Integer>>> getIntInvalidStringAsyncWithServiceResponse() {
        return service.getIntInvalidString()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Integer>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Integer>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Integer>> clientResponse = getIntInvalidStringDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Integer>> getIntInvalidStringDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Integer>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Integer>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Long&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Long> getLongValid() throws ErrorException, IOException {
        return getLongValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Long>> getLongValidAsync(final ServiceCallback<Map<String, Long>> serviceCallback) {
        return ServiceCall.create(getLongValidAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @return the observable to the Map&lt;String, Long&gt; object
     */
    public Observable<Map<String, Long>> getLongValidAsync() {
        return getLongValidAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Long>>, Map<String, Long>>() {
            @Override
            public Map<String, Long> call(ServiceResponse<Map<String, Long>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @return the observable to the Map&lt;String, Long&gt; object
     */
    public Observable<ServiceResponse<Map<String, Long>>> getLongValidAsyncWithServiceResponse() {
        return service.getLongValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Long>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Long>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Long>> clientResponse = getLongValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Long>> getLongValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Long>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Long>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @param arrayBody the Map&lt;String, Long&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putLongValid(Map<String, Long> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        putLongValidAsyncWithServiceResponse(arrayBody).toBlocking().single().getBody();
    }

    /**
     * Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @param arrayBody the Map&lt;String, Long&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putLongValidAsync(Map<String, Long> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putLongValidAsyncWithServiceResponse(arrayBody), serviceCallback);
    }

    /**
     * Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @param arrayBody the Map&lt;String, Long&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putLongValidAsync(Map<String, Long> arrayBody) {
        return putLongValidAsyncWithServiceResponse(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}.
     *
     * @param arrayBody the Map&lt;String, Long&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putLongValidAsyncWithServiceResponse(Map<String, Long> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putLongValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putLongValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putLongValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get long dictionary value {"0": 1, "1": null, "2": 0}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Long&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Long> getLongInvalidNull() throws ErrorException, IOException {
        return getLongInvalidNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get long dictionary value {"0": 1, "1": null, "2": 0}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Long>> getLongInvalidNullAsync(final ServiceCallback<Map<String, Long>> serviceCallback) {
        return ServiceCall.create(getLongInvalidNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get long dictionary value {"0": 1, "1": null, "2": 0}.
     *
     * @return the observable to the Map&lt;String, Long&gt; object
     */
    public Observable<Map<String, Long>> getLongInvalidNullAsync() {
        return getLongInvalidNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Long>>, Map<String, Long>>() {
            @Override
            public Map<String, Long> call(ServiceResponse<Map<String, Long>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get long dictionary value {"0": 1, "1": null, "2": 0}.
     *
     * @return the observable to the Map&lt;String, Long&gt; object
     */
    public Observable<ServiceResponse<Map<String, Long>>> getLongInvalidNullAsyncWithServiceResponse() {
        return service.getLongInvalidNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Long>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Long>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Long>> clientResponse = getLongInvalidNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Long>> getLongInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Long>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Long>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get long dictionary value {"0": 1, "1": "integer", "2": 0}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Long&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Long> getLongInvalidString() throws ErrorException, IOException {
        return getLongInvalidStringAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get long dictionary value {"0": 1, "1": "integer", "2": 0}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Long>> getLongInvalidStringAsync(final ServiceCallback<Map<String, Long>> serviceCallback) {
        return ServiceCall.create(getLongInvalidStringAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get long dictionary value {"0": 1, "1": "integer", "2": 0}.
     *
     * @return the observable to the Map&lt;String, Long&gt; object
     */
    public Observable<Map<String, Long>> getLongInvalidStringAsync() {
        return getLongInvalidStringAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Long>>, Map<String, Long>>() {
            @Override
            public Map<String, Long> call(ServiceResponse<Map<String, Long>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get long dictionary value {"0": 1, "1": "integer", "2": 0}.
     *
     * @return the observable to the Map&lt;String, Long&gt; object
     */
    public Observable<ServiceResponse<Map<String, Long>>> getLongInvalidStringAsyncWithServiceResponse() {
        return service.getLongInvalidString()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Long>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Long>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Long>> clientResponse = getLongInvalidStringDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Long>> getLongInvalidStringDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Long>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Long>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Double&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Double> getFloatValid() throws ErrorException, IOException {
        return getFloatValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Double>> getFloatValidAsync(final ServiceCallback<Map<String, Double>> serviceCallback) {
        return ServiceCall.create(getFloatValidAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @return the observable to the Map&lt;String, Double&gt; object
     */
    public Observable<Map<String, Double>> getFloatValidAsync() {
        return getFloatValidAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Double>>, Map<String, Double>>() {
            @Override
            public Map<String, Double> call(ServiceResponse<Map<String, Double>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @return the observable to the Map&lt;String, Double&gt; object
     */
    public Observable<ServiceResponse<Map<String, Double>>> getFloatValidAsyncWithServiceResponse() {
        return service.getFloatValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Double>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Double>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Double>> clientResponse = getFloatValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Double>> getFloatValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Double>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Double>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @param arrayBody the Map&lt;String, Double&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putFloatValid(Map<String, Double> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        putFloatValidAsyncWithServiceResponse(arrayBody).toBlocking().single().getBody();
    }

    /**
     * Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @param arrayBody the Map&lt;String, Double&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putFloatValidAsync(Map<String, Double> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putFloatValidAsyncWithServiceResponse(arrayBody), serviceCallback);
    }

    /**
     * Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @param arrayBody the Map&lt;String, Double&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putFloatValidAsync(Map<String, Double> arrayBody) {
        return putFloatValidAsyncWithServiceResponse(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @param arrayBody the Map&lt;String, Double&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putFloatValidAsyncWithServiceResponse(Map<String, Double> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putFloatValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putFloatValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putFloatValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Double&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Double> getFloatInvalidNull() throws ErrorException, IOException {
        return getFloatInvalidNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Double>> getFloatInvalidNullAsync(final ServiceCallback<Map<String, Double>> serviceCallback) {
        return ServiceCall.create(getFloatInvalidNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}.
     *
     * @return the observable to the Map&lt;String, Double&gt; object
     */
    public Observable<Map<String, Double>> getFloatInvalidNullAsync() {
        return getFloatInvalidNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Double>>, Map<String, Double>>() {
            @Override
            public Map<String, Double> call(ServiceResponse<Map<String, Double>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}.
     *
     * @return the observable to the Map&lt;String, Double&gt; object
     */
    public Observable<ServiceResponse<Map<String, Double>>> getFloatInvalidNullAsyncWithServiceResponse() {
        return service.getFloatInvalidNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Double>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Double>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Double>> clientResponse = getFloatInvalidNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Double>> getFloatInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Double>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Double>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Double&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Double> getFloatInvalidString() throws ErrorException, IOException {
        return getFloatInvalidStringAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Double>> getFloatInvalidStringAsync(final ServiceCallback<Map<String, Double>> serviceCallback) {
        return ServiceCall.create(getFloatInvalidStringAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}.
     *
     * @return the observable to the Map&lt;String, Double&gt; object
     */
    public Observable<Map<String, Double>> getFloatInvalidStringAsync() {
        return getFloatInvalidStringAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Double>>, Map<String, Double>>() {
            @Override
            public Map<String, Double> call(ServiceResponse<Map<String, Double>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}.
     *
     * @return the observable to the Map&lt;String, Double&gt; object
     */
    public Observable<ServiceResponse<Map<String, Double>>> getFloatInvalidStringAsyncWithServiceResponse() {
        return service.getFloatInvalidString()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Double>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Double>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Double>> clientResponse = getFloatInvalidStringDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Double>> getFloatInvalidStringDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Double>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Double>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Double&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Double> getDoubleValid() throws ErrorException, IOException {
        return getDoubleValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Double>> getDoubleValidAsync(final ServiceCallback<Map<String, Double>> serviceCallback) {
        return ServiceCall.create(getDoubleValidAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @return the observable to the Map&lt;String, Double&gt; object
     */
    public Observable<Map<String, Double>> getDoubleValidAsync() {
        return getDoubleValidAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Double>>, Map<String, Double>>() {
            @Override
            public Map<String, Double> call(ServiceResponse<Map<String, Double>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @return the observable to the Map&lt;String, Double&gt; object
     */
    public Observable<ServiceResponse<Map<String, Double>>> getDoubleValidAsyncWithServiceResponse() {
        return service.getDoubleValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Double>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Double>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Double>> clientResponse = getDoubleValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Double>> getDoubleValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Double>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Double>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @param arrayBody the Map&lt;String, Double&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putDoubleValid(Map<String, Double> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        putDoubleValidAsyncWithServiceResponse(arrayBody).toBlocking().single().getBody();
    }

    /**
     * Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @param arrayBody the Map&lt;String, Double&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putDoubleValidAsync(Map<String, Double> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putDoubleValidAsyncWithServiceResponse(arrayBody), serviceCallback);
    }

    /**
     * Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @param arrayBody the Map&lt;String, Double&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putDoubleValidAsync(Map<String, Double> arrayBody) {
        return putDoubleValidAsyncWithServiceResponse(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}.
     *
     * @param arrayBody the Map&lt;String, Double&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putDoubleValidAsyncWithServiceResponse(Map<String, Double> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putDoubleValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putDoubleValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putDoubleValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Double&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Double> getDoubleInvalidNull() throws ErrorException, IOException {
        return getDoubleInvalidNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Double>> getDoubleInvalidNullAsync(final ServiceCallback<Map<String, Double>> serviceCallback) {
        return ServiceCall.create(getDoubleInvalidNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}.
     *
     * @return the observable to the Map&lt;String, Double&gt; object
     */
    public Observable<Map<String, Double>> getDoubleInvalidNullAsync() {
        return getDoubleInvalidNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Double>>, Map<String, Double>>() {
            @Override
            public Map<String, Double> call(ServiceResponse<Map<String, Double>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}.
     *
     * @return the observable to the Map&lt;String, Double&gt; object
     */
    public Observable<ServiceResponse<Map<String, Double>>> getDoubleInvalidNullAsyncWithServiceResponse() {
        return service.getDoubleInvalidNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Double>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Double>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Double>> clientResponse = getDoubleInvalidNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Double>> getDoubleInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Double>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Double>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Double&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Double> getDoubleInvalidString() throws ErrorException, IOException {
        return getDoubleInvalidStringAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Double>> getDoubleInvalidStringAsync(final ServiceCallback<Map<String, Double>> serviceCallback) {
        return ServiceCall.create(getDoubleInvalidStringAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}.
     *
     * @return the observable to the Map&lt;String, Double&gt; object
     */
    public Observable<Map<String, Double>> getDoubleInvalidStringAsync() {
        return getDoubleInvalidStringAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Double>>, Map<String, Double>>() {
            @Override
            public Map<String, Double> call(ServiceResponse<Map<String, Double>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}.
     *
     * @return the observable to the Map&lt;String, Double&gt; object
     */
    public Observable<ServiceResponse<Map<String, Double>>> getDoubleInvalidStringAsyncWithServiceResponse() {
        return service.getDoubleInvalidString()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Double>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Double>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Double>> clientResponse = getDoubleInvalidStringDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Double>> getDoubleInvalidStringDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Double>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Double>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get string dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, String&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, String> getStringValid() throws ErrorException, IOException {
        return getStringValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get string dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, String>> getStringValidAsync(final ServiceCallback<Map<String, String>> serviceCallback) {
        return ServiceCall.create(getStringValidAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get string dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}.
     *
     * @return the observable to the Map&lt;String, String&gt; object
     */
    public Observable<Map<String, String>> getStringValidAsync() {
        return getStringValidAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, String>>, Map<String, String>>() {
            @Override
            public Map<String, String> call(ServiceResponse<Map<String, String>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get string dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}.
     *
     * @return the observable to the Map&lt;String, String&gt; object
     */
    public Observable<ServiceResponse<Map<String, String>>> getStringValidAsyncWithServiceResponse() {
        return service.getStringValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, String>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, String>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, String>> clientResponse = getStringValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, String>> getStringValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, String>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, String>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}.
     *
     * @param arrayBody the Map&lt;String, String&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putStringValid(Map<String, String> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        putStringValidAsyncWithServiceResponse(arrayBody).toBlocking().single().getBody();
    }

    /**
     * Set dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}.
     *
     * @param arrayBody the Map&lt;String, String&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putStringValidAsync(Map<String, String> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putStringValidAsyncWithServiceResponse(arrayBody), serviceCallback);
    }

    /**
     * Set dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}.
     *
     * @param arrayBody the Map&lt;String, String&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putStringValidAsync(Map<String, String> arrayBody) {
        return putStringValidAsyncWithServiceResponse(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Set dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}.
     *
     * @param arrayBody the Map&lt;String, String&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putStringValidAsyncWithServiceResponse(Map<String, String> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putStringValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putStringValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putStringValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get string dictionary value {"0": "foo", "1": null, "2": "foo2"}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, String&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, String> getStringWithNull() throws ErrorException, IOException {
        return getStringWithNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get string dictionary value {"0": "foo", "1": null, "2": "foo2"}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, String>> getStringWithNullAsync(final ServiceCallback<Map<String, String>> serviceCallback) {
        return ServiceCall.create(getStringWithNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get string dictionary value {"0": "foo", "1": null, "2": "foo2"}.
     *
     * @return the observable to the Map&lt;String, String&gt; object
     */
    public Observable<Map<String, String>> getStringWithNullAsync() {
        return getStringWithNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, String>>, Map<String, String>>() {
            @Override
            public Map<String, String> call(ServiceResponse<Map<String, String>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get string dictionary value {"0": "foo", "1": null, "2": "foo2"}.
     *
     * @return the observable to the Map&lt;String, String&gt; object
     */
    public Observable<ServiceResponse<Map<String, String>>> getStringWithNullAsyncWithServiceResponse() {
        return service.getStringWithNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, String>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, String>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, String>> clientResponse = getStringWithNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, String>> getStringWithNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, String>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, String>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get string dictionary value {"0": "foo", "1": 123, "2": "foo2"}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, String&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, String> getStringWithInvalid() throws ErrorException, IOException {
        return getStringWithInvalidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get string dictionary value {"0": "foo", "1": 123, "2": "foo2"}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, String>> getStringWithInvalidAsync(final ServiceCallback<Map<String, String>> serviceCallback) {
        return ServiceCall.create(getStringWithInvalidAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get string dictionary value {"0": "foo", "1": 123, "2": "foo2"}.
     *
     * @return the observable to the Map&lt;String, String&gt; object
     */
    public Observable<Map<String, String>> getStringWithInvalidAsync() {
        return getStringWithInvalidAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, String>>, Map<String, String>>() {
            @Override
            public Map<String, String> call(ServiceResponse<Map<String, String>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get string dictionary value {"0": "foo", "1": 123, "2": "foo2"}.
     *
     * @return the observable to the Map&lt;String, String&gt; object
     */
    public Observable<ServiceResponse<Map<String, String>>> getStringWithInvalidAsyncWithServiceResponse() {
        return service.getStringWithInvalid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, String>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, String>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, String>> clientResponse = getStringWithInvalidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, String>> getStringWithInvalidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, String>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, String>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get integer dictionary value {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, LocalDate&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, LocalDate> getDateValid() throws ErrorException, IOException {
        return getDateValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get integer dictionary value {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, LocalDate>> getDateValidAsync(final ServiceCallback<Map<String, LocalDate>> serviceCallback) {
        return ServiceCall.create(getDateValidAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get integer dictionary value {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}.
     *
     * @return the observable to the Map&lt;String, LocalDate&gt; object
     */
    public Observable<Map<String, LocalDate>> getDateValidAsync() {
        return getDateValidAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, LocalDate>>, Map<String, LocalDate>>() {
            @Override
            public Map<String, LocalDate> call(ServiceResponse<Map<String, LocalDate>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get integer dictionary value {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}.
     *
     * @return the observable to the Map&lt;String, LocalDate&gt; object
     */
    public Observable<ServiceResponse<Map<String, LocalDate>>> getDateValidAsyncWithServiceResponse() {
        return service.getDateValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, LocalDate>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, LocalDate>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, LocalDate>> clientResponse = getDateValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, LocalDate>> getDateValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, LocalDate>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, LocalDate>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set dictionary value  {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}.
     *
     * @param arrayBody the Map&lt;String, LocalDate&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putDateValid(Map<String, LocalDate> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        putDateValidAsyncWithServiceResponse(arrayBody).toBlocking().single().getBody();
    }

    /**
     * Set dictionary value  {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}.
     *
     * @param arrayBody the Map&lt;String, LocalDate&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putDateValidAsync(Map<String, LocalDate> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putDateValidAsyncWithServiceResponse(arrayBody), serviceCallback);
    }

    /**
     * Set dictionary value  {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}.
     *
     * @param arrayBody the Map&lt;String, LocalDate&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putDateValidAsync(Map<String, LocalDate> arrayBody) {
        return putDateValidAsyncWithServiceResponse(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Set dictionary value  {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}.
     *
     * @param arrayBody the Map&lt;String, LocalDate&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putDateValidAsyncWithServiceResponse(Map<String, LocalDate> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putDateValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putDateValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putDateValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get date dictionary value {"0": "2012-01-01", "1": null, "2": "1776-07-04"}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, LocalDate&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, LocalDate> getDateInvalidNull() throws ErrorException, IOException {
        return getDateInvalidNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get date dictionary value {"0": "2012-01-01", "1": null, "2": "1776-07-04"}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, LocalDate>> getDateInvalidNullAsync(final ServiceCallback<Map<String, LocalDate>> serviceCallback) {
        return ServiceCall.create(getDateInvalidNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get date dictionary value {"0": "2012-01-01", "1": null, "2": "1776-07-04"}.
     *
     * @return the observable to the Map&lt;String, LocalDate&gt; object
     */
    public Observable<Map<String, LocalDate>> getDateInvalidNullAsync() {
        return getDateInvalidNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, LocalDate>>, Map<String, LocalDate>>() {
            @Override
            public Map<String, LocalDate> call(ServiceResponse<Map<String, LocalDate>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get date dictionary value {"0": "2012-01-01", "1": null, "2": "1776-07-04"}.
     *
     * @return the observable to the Map&lt;String, LocalDate&gt; object
     */
    public Observable<ServiceResponse<Map<String, LocalDate>>> getDateInvalidNullAsyncWithServiceResponse() {
        return service.getDateInvalidNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, LocalDate>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, LocalDate>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, LocalDate>> clientResponse = getDateInvalidNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, LocalDate>> getDateInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, LocalDate>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, LocalDate>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get date dictionary value {"0": "2011-03-22", "1": "date"}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, LocalDate&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, LocalDate> getDateInvalidChars() throws ErrorException, IOException {
        return getDateInvalidCharsAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get date dictionary value {"0": "2011-03-22", "1": "date"}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, LocalDate>> getDateInvalidCharsAsync(final ServiceCallback<Map<String, LocalDate>> serviceCallback) {
        return ServiceCall.create(getDateInvalidCharsAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get date dictionary value {"0": "2011-03-22", "1": "date"}.
     *
     * @return the observable to the Map&lt;String, LocalDate&gt; object
     */
    public Observable<Map<String, LocalDate>> getDateInvalidCharsAsync() {
        return getDateInvalidCharsAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, LocalDate>>, Map<String, LocalDate>>() {
            @Override
            public Map<String, LocalDate> call(ServiceResponse<Map<String, LocalDate>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get date dictionary value {"0": "2011-03-22", "1": "date"}.
     *
     * @return the observable to the Map&lt;String, LocalDate&gt; object
     */
    public Observable<ServiceResponse<Map<String, LocalDate>>> getDateInvalidCharsAsyncWithServiceResponse() {
        return service.getDateInvalidChars()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, LocalDate>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, LocalDate>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, LocalDate>> clientResponse = getDateInvalidCharsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, LocalDate>> getDateInvalidCharsDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, LocalDate>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, LocalDate>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get date-time dictionary value {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, DateTime&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, DateTime> getDateTimeValid() throws ErrorException, IOException {
        return getDateTimeValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get date-time dictionary value {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, DateTime>> getDateTimeValidAsync(final ServiceCallback<Map<String, DateTime>> serviceCallback) {
        return ServiceCall.create(getDateTimeValidAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get date-time dictionary value {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}.
     *
     * @return the observable to the Map&lt;String, DateTime&gt; object
     */
    public Observable<Map<String, DateTime>> getDateTimeValidAsync() {
        return getDateTimeValidAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, DateTime>>, Map<String, DateTime>>() {
            @Override
            public Map<String, DateTime> call(ServiceResponse<Map<String, DateTime>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get date-time dictionary value {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}.
     *
     * @return the observable to the Map&lt;String, DateTime&gt; object
     */
    public Observable<ServiceResponse<Map<String, DateTime>>> getDateTimeValidAsyncWithServiceResponse() {
        return service.getDateTimeValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, DateTime>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, DateTime>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, DateTime>> clientResponse = getDateTimeValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, DateTime>> getDateTimeValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, DateTime>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, DateTime>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set dictionary value  {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}.
     *
     * @param arrayBody the Map&lt;String, DateTime&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putDateTimeValid(Map<String, DateTime> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        putDateTimeValidAsyncWithServiceResponse(arrayBody).toBlocking().single().getBody();
    }

    /**
     * Set dictionary value  {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}.
     *
     * @param arrayBody the Map&lt;String, DateTime&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putDateTimeValidAsync(Map<String, DateTime> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putDateTimeValidAsyncWithServiceResponse(arrayBody), serviceCallback);
    }

    /**
     * Set dictionary value  {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}.
     *
     * @param arrayBody the Map&lt;String, DateTime&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putDateTimeValidAsync(Map<String, DateTime> arrayBody) {
        return putDateTimeValidAsyncWithServiceResponse(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Set dictionary value  {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}.
     *
     * @param arrayBody the Map&lt;String, DateTime&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putDateTimeValidAsyncWithServiceResponse(Map<String, DateTime> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putDateTimeValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putDateTimeValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putDateTimeValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": null}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, DateTime&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, DateTime> getDateTimeInvalidNull() throws ErrorException, IOException {
        return getDateTimeInvalidNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": null}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, DateTime>> getDateTimeInvalidNullAsync(final ServiceCallback<Map<String, DateTime>> serviceCallback) {
        return ServiceCall.create(getDateTimeInvalidNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": null}.
     *
     * @return the observable to the Map&lt;String, DateTime&gt; object
     */
    public Observable<Map<String, DateTime>> getDateTimeInvalidNullAsync() {
        return getDateTimeInvalidNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, DateTime>>, Map<String, DateTime>>() {
            @Override
            public Map<String, DateTime> call(ServiceResponse<Map<String, DateTime>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": null}.
     *
     * @return the observable to the Map&lt;String, DateTime&gt; object
     */
    public Observable<ServiceResponse<Map<String, DateTime>>> getDateTimeInvalidNullAsyncWithServiceResponse() {
        return service.getDateTimeInvalidNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, DateTime>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, DateTime>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, DateTime>> clientResponse = getDateTimeInvalidNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, DateTime>> getDateTimeInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, DateTime>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, DateTime>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": "date-time"}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, DateTime&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, DateTime> getDateTimeInvalidChars() throws ErrorException, IOException {
        return getDateTimeInvalidCharsAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": "date-time"}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, DateTime>> getDateTimeInvalidCharsAsync(final ServiceCallback<Map<String, DateTime>> serviceCallback) {
        return ServiceCall.create(getDateTimeInvalidCharsAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": "date-time"}.
     *
     * @return the observable to the Map&lt;String, DateTime&gt; object
     */
    public Observable<Map<String, DateTime>> getDateTimeInvalidCharsAsync() {
        return getDateTimeInvalidCharsAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, DateTime>>, Map<String, DateTime>>() {
            @Override
            public Map<String, DateTime> call(ServiceResponse<Map<String, DateTime>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": "date-time"}.
     *
     * @return the observable to the Map&lt;String, DateTime&gt; object
     */
    public Observable<ServiceResponse<Map<String, DateTime>>> getDateTimeInvalidCharsAsyncWithServiceResponse() {
        return service.getDateTimeInvalidChars()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, DateTime>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, DateTime>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, DateTime>> clientResponse = getDateTimeInvalidCharsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, DateTime>> getDateTimeInvalidCharsDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, DateTime>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, DateTime>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get date-time-rfc1123 dictionary value {"0": "Fri, 01 Dec 2000 00:00:01 GMT", "1": "Wed, 02 Jan 1980 00:11:35 GMT", "2": "Wed, 12 Oct 1492 10:15:01 GMT"}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, DateTime&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, DateTime> getDateTimeRfc1123Valid() throws ErrorException, IOException {
        return getDateTimeRfc1123ValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get date-time-rfc1123 dictionary value {"0": "Fri, 01 Dec 2000 00:00:01 GMT", "1": "Wed, 02 Jan 1980 00:11:35 GMT", "2": "Wed, 12 Oct 1492 10:15:01 GMT"}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, DateTime>> getDateTimeRfc1123ValidAsync(final ServiceCallback<Map<String, DateTime>> serviceCallback) {
        return ServiceCall.create(getDateTimeRfc1123ValidAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get date-time-rfc1123 dictionary value {"0": "Fri, 01 Dec 2000 00:00:01 GMT", "1": "Wed, 02 Jan 1980 00:11:35 GMT", "2": "Wed, 12 Oct 1492 10:15:01 GMT"}.
     *
     * @return the observable to the Map&lt;String, DateTime&gt; object
     */
    public Observable<Map<String, DateTime>> getDateTimeRfc1123ValidAsync() {
        return getDateTimeRfc1123ValidAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, DateTime>>, Map<String, DateTime>>() {
            @Override
            public Map<String, DateTime> call(ServiceResponse<Map<String, DateTime>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get date-time-rfc1123 dictionary value {"0": "Fri, 01 Dec 2000 00:00:01 GMT", "1": "Wed, 02 Jan 1980 00:11:35 GMT", "2": "Wed, 12 Oct 1492 10:15:01 GMT"}.
     *
     * @return the observable to the Map&lt;String, DateTime&gt; object
     */
    public Observable<ServiceResponse<Map<String, DateTime>>> getDateTimeRfc1123ValidAsyncWithServiceResponse() {
        return service.getDateTimeRfc1123Valid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, DateTime>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, DateTime>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, DateTimeRfc1123>> result = getDateTimeRfc1123ValidDelegate(response);
                        Map<String, DateTime> body = null;
                        if (result.getBody() != null) {
                            body = new HashMap<String, DateTime>();
                            for (Map.Entry<String, DateTimeRfc1123> entry : result.getBody().entrySet()) {
                                DateTime value;
                                value = entry.getValue().getDateTime();
                                body.put(entry.getKey(), value);
                            }
                        }
                        ServiceResponse<Map<String, DateTime>> clientResponse = new ServiceResponse<Map<String, DateTime>>(body, result.getResponse());
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, DateTimeRfc1123>> getDateTimeRfc1123ValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, DateTimeRfc1123>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, DateTimeRfc1123>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set dictionary value empty {"0": "Fri, 01 Dec 2000 00:00:01 GMT", "1": "Wed, 02 Jan 1980 00:11:35 GMT", "2": "Wed, 12 Oct 1492 10:15:01 GMT"}.
     *
     * @param arrayBody the Map&lt;String, DateTimeRfc1123&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putDateTimeRfc1123Valid(Map<String, DateTime> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        putDateTimeRfc1123ValidAsyncWithServiceResponse(arrayBody).toBlocking().single().getBody();
    }

    /**
     * Set dictionary value empty {"0": "Fri, 01 Dec 2000 00:00:01 GMT", "1": "Wed, 02 Jan 1980 00:11:35 GMT", "2": "Wed, 12 Oct 1492 10:15:01 GMT"}.
     *
     * @param arrayBody the Map&lt;String, DateTimeRfc1123&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putDateTimeRfc1123ValidAsync(Map<String, DateTime> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putDateTimeRfc1123ValidAsyncWithServiceResponse(arrayBody), serviceCallback);
    }

    /**
     * Set dictionary value empty {"0": "Fri, 01 Dec 2000 00:00:01 GMT", "1": "Wed, 02 Jan 1980 00:11:35 GMT", "2": "Wed, 12 Oct 1492 10:15:01 GMT"}.
     *
     * @param arrayBody the Map&lt;String, DateTimeRfc1123&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putDateTimeRfc1123ValidAsync(Map<String, DateTime> arrayBody) {
        return putDateTimeRfc1123ValidAsyncWithServiceResponse(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Set dictionary value empty {"0": "Fri, 01 Dec 2000 00:00:01 GMT", "1": "Wed, 02 Jan 1980 00:11:35 GMT", "2": "Wed, 12 Oct 1492 10:15:01 GMT"}.
     *
     * @param arrayBody the Map&lt;String, DateTimeRfc1123&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putDateTimeRfc1123ValidAsyncWithServiceResponse(Map<String, DateTime> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        Map<String, DateTimeRfc1123> arrayBodyConverted = new HashMap<String, DateTimeRfc1123>();
        for (Map.Entry<String, DateTime> entry : arrayBody.entrySet()) {
            DateTimeRfc1123 value = new DateTimeRfc1123(entry.getValue());
            arrayBodyConverted.put(entry.getKey(), value);
        }
        return service.putDateTimeRfc1123Valid(arrayBodyConverted)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putDateTimeRfc1123ValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putDateTimeRfc1123ValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get duration dictionary value {"0": "P123DT22H14M12.011S", "1": "P5DT1H0M0S"}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Period&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Period> getDurationValid() throws ErrorException, IOException {
        return getDurationValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get duration dictionary value {"0": "P123DT22H14M12.011S", "1": "P5DT1H0M0S"}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Period>> getDurationValidAsync(final ServiceCallback<Map<String, Period>> serviceCallback) {
        return ServiceCall.create(getDurationValidAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get duration dictionary value {"0": "P123DT22H14M12.011S", "1": "P5DT1H0M0S"}.
     *
     * @return the observable to the Map&lt;String, Period&gt; object
     */
    public Observable<Map<String, Period>> getDurationValidAsync() {
        return getDurationValidAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Period>>, Map<String, Period>>() {
            @Override
            public Map<String, Period> call(ServiceResponse<Map<String, Period>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get duration dictionary value {"0": "P123DT22H14M12.011S", "1": "P5DT1H0M0S"}.
     *
     * @return the observable to the Map&lt;String, Period&gt; object
     */
    public Observable<ServiceResponse<Map<String, Period>>> getDurationValidAsyncWithServiceResponse() {
        return service.getDurationValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Period>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Period>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Period>> clientResponse = getDurationValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Period>> getDurationValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Period>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Period>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Set dictionary value  {"0": "P123DT22H14M12.011S", "1": "P5DT1H0M0S"}.
     *
     * @param arrayBody the Map&lt;String, Period&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putDurationValid(Map<String, Period> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        putDurationValidAsyncWithServiceResponse(arrayBody).toBlocking().single().getBody();
    }

    /**
     * Set dictionary value  {"0": "P123DT22H14M12.011S", "1": "P5DT1H0M0S"}.
     *
     * @param arrayBody the Map&lt;String, Period&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putDurationValidAsync(Map<String, Period> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putDurationValidAsyncWithServiceResponse(arrayBody), serviceCallback);
    }

    /**
     * Set dictionary value  {"0": "P123DT22H14M12.011S", "1": "P5DT1H0M0S"}.
     *
     * @param arrayBody the Map&lt;String, Period&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putDurationValidAsync(Map<String, Period> arrayBody) {
        return putDurationValidAsyncWithServiceResponse(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Set dictionary value  {"0": "P123DT22H14M12.011S", "1": "P5DT1H0M0S"}.
     *
     * @param arrayBody the Map&lt;String, Period&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putDurationValidAsyncWithServiceResponse(Map<String, Period> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putDurationValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putDurationValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putDurationValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get byte dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each item encoded in base64.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, byte[]&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, byte[]> getByteValid() throws ErrorException, IOException {
        return getByteValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get byte dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each item encoded in base64.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, byte[]>> getByteValidAsync(final ServiceCallback<Map<String, byte[]>> serviceCallback) {
        return ServiceCall.create(getByteValidAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get byte dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each item encoded in base64.
     *
     * @return the observable to the Map&lt;String, byte[]&gt; object
     */
    public Observable<Map<String, byte[]>> getByteValidAsync() {
        return getByteValidAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, byte[]>>, Map<String, byte[]>>() {
            @Override
            public Map<String, byte[]> call(ServiceResponse<Map<String, byte[]>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get byte dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each item encoded in base64.
     *
     * @return the observable to the Map&lt;String, byte[]&gt; object
     */
    public Observable<ServiceResponse<Map<String, byte[]>>> getByteValidAsyncWithServiceResponse() {
        return service.getByteValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, byte[]>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, byte[]>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, byte[]>> clientResponse = getByteValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, byte[]>> getByteValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, byte[]>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, byte[]>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Put the dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each elementencoded in base 64.
     *
     * @param arrayBody the Map&lt;String, byte[]&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putByteValid(Map<String, byte[]> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        putByteValidAsyncWithServiceResponse(arrayBody).toBlocking().single().getBody();
    }

    /**
     * Put the dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each elementencoded in base 64.
     *
     * @param arrayBody the Map&lt;String, byte[]&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putByteValidAsync(Map<String, byte[]> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putByteValidAsyncWithServiceResponse(arrayBody), serviceCallback);
    }

    /**
     * Put the dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each elementencoded in base 64.
     *
     * @param arrayBody the Map&lt;String, byte[]&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putByteValidAsync(Map<String, byte[]> arrayBody) {
        return putByteValidAsyncWithServiceResponse(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Put the dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each elementencoded in base 64.
     *
     * @param arrayBody the Map&lt;String, byte[]&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putByteValidAsyncWithServiceResponse(Map<String, byte[]> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putByteValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putByteValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putByteValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get byte dictionary value {"0": hex(FF FF FF FA), "1": null} with the first item base64 encoded.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, byte[]&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, byte[]> getByteInvalidNull() throws ErrorException, IOException {
        return getByteInvalidNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get byte dictionary value {"0": hex(FF FF FF FA), "1": null} with the first item base64 encoded.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, byte[]>> getByteInvalidNullAsync(final ServiceCallback<Map<String, byte[]>> serviceCallback) {
        return ServiceCall.create(getByteInvalidNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get byte dictionary value {"0": hex(FF FF FF FA), "1": null} with the first item base64 encoded.
     *
     * @return the observable to the Map&lt;String, byte[]&gt; object
     */
    public Observable<Map<String, byte[]>> getByteInvalidNullAsync() {
        return getByteInvalidNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, byte[]>>, Map<String, byte[]>>() {
            @Override
            public Map<String, byte[]> call(ServiceResponse<Map<String, byte[]>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get byte dictionary value {"0": hex(FF FF FF FA), "1": null} with the first item base64 encoded.
     *
     * @return the observable to the Map&lt;String, byte[]&gt; object
     */
    public Observable<ServiceResponse<Map<String, byte[]>>> getByteInvalidNullAsyncWithServiceResponse() {
        return service.getByteInvalidNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, byte[]>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, byte[]>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, byte[]>> clientResponse = getByteInvalidNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, byte[]>> getByteInvalidNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, byte[]>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, byte[]>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get base64url dictionary value {"0": "a string that gets encoded with base64url", "1": "test string", "2": "Lorem ipsum"}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, byte[]&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, byte[]> getBase64Url() throws ErrorException, IOException {
        return getBase64UrlAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get base64url dictionary value {"0": "a string that gets encoded with base64url", "1": "test string", "2": "Lorem ipsum"}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, byte[]>> getBase64UrlAsync(final ServiceCallback<Map<String, byte[]>> serviceCallback) {
        return ServiceCall.create(getBase64UrlAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get base64url dictionary value {"0": "a string that gets encoded with base64url", "1": "test string", "2": "Lorem ipsum"}.
     *
     * @return the observable to the Map&lt;String, byte[]&gt; object
     */
    public Observable<Map<String, byte[]>> getBase64UrlAsync() {
        return getBase64UrlAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, byte[]>>, Map<String, byte[]>>() {
            @Override
            public Map<String, byte[]> call(ServiceResponse<Map<String, byte[]>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get base64url dictionary value {"0": "a string that gets encoded with base64url", "1": "test string", "2": "Lorem ipsum"}.
     *
     * @return the observable to the Map&lt;String, byte[]&gt; object
     */
    public Observable<ServiceResponse<Map<String, byte[]>>> getBase64UrlAsyncWithServiceResponse() {
        return service.getBase64Url()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, byte[]>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, byte[]>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Base64Url>> result = getBase64UrlDelegate(response);
                        Map<String, byte[]> body = null;
                        if (result.getBody() != null) {
                            body = new HashMap<String, byte[]>();
                            for (Map.Entry<String, Base64Url> entry : result.getBody().entrySet()) {
                                byte[] value;
                                value = entry.getValue().getDecodedBytes();
                                body.put(entry.getKey(), value);
                            }
                        }
                        ServiceResponse<Map<String, byte[]>> clientResponse = new ServiceResponse<Map<String, byte[]>>(body, result.getResponse());
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Base64Url>> getBase64UrlDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Base64Url>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Base64Url>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get dictionary of complex type null value.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Widget&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Widget> getComplexNull() throws ErrorException, IOException {
        return getComplexNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get dictionary of complex type null value.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Widget>> getComplexNullAsync(final ServiceCallback<Map<String, Widget>> serviceCallback) {
        return ServiceCall.create(getComplexNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get dictionary of complex type null value.
     *
     * @return the observable to the Map&lt;String, Widget&gt; object
     */
    public Observable<Map<String, Widget>> getComplexNullAsync() {
        return getComplexNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Widget>>, Map<String, Widget>>() {
            @Override
            public Map<String, Widget> call(ServiceResponse<Map<String, Widget>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get dictionary of complex type null value.
     *
     * @return the observable to the Map&lt;String, Widget&gt; object
     */
    public Observable<ServiceResponse<Map<String, Widget>>> getComplexNullAsyncWithServiceResponse() {
        return service.getComplexNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Widget>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Widget>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Widget>> clientResponse = getComplexNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Widget>> getComplexNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Widget>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Widget>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get empty dictionary of complex type {}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Widget&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Widget> getComplexEmpty() throws ErrorException, IOException {
        return getComplexEmptyAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get empty dictionary of complex type {}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Widget>> getComplexEmptyAsync(final ServiceCallback<Map<String, Widget>> serviceCallback) {
        return ServiceCall.create(getComplexEmptyAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get empty dictionary of complex type {}.
     *
     * @return the observable to the Map&lt;String, Widget&gt; object
     */
    public Observable<Map<String, Widget>> getComplexEmptyAsync() {
        return getComplexEmptyAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Widget>>, Map<String, Widget>>() {
            @Override
            public Map<String, Widget> call(ServiceResponse<Map<String, Widget>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get empty dictionary of complex type {}.
     *
     * @return the observable to the Map&lt;String, Widget&gt; object
     */
    public Observable<ServiceResponse<Map<String, Widget>>> getComplexEmptyAsyncWithServiceResponse() {
        return service.getComplexEmpty()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Widget>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Widget>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Widget>> clientResponse = getComplexEmptyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Widget>> getComplexEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Widget>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Widget>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get dictionary of complex type with null item {"0": {"integer": 1, "string": "2"}, "1": null, "2": {"integer": 5, "string": "6"}}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Widget&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Widget> getComplexItemNull() throws ErrorException, IOException {
        return getComplexItemNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get dictionary of complex type with null item {"0": {"integer": 1, "string": "2"}, "1": null, "2": {"integer": 5, "string": "6"}}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Widget>> getComplexItemNullAsync(final ServiceCallback<Map<String, Widget>> serviceCallback) {
        return ServiceCall.create(getComplexItemNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get dictionary of complex type with null item {"0": {"integer": 1, "string": "2"}, "1": null, "2": {"integer": 5, "string": "6"}}.
     *
     * @return the observable to the Map&lt;String, Widget&gt; object
     */
    public Observable<Map<String, Widget>> getComplexItemNullAsync() {
        return getComplexItemNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Widget>>, Map<String, Widget>>() {
            @Override
            public Map<String, Widget> call(ServiceResponse<Map<String, Widget>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get dictionary of complex type with null item {"0": {"integer": 1, "string": "2"}, "1": null, "2": {"integer": 5, "string": "6"}}.
     *
     * @return the observable to the Map&lt;String, Widget&gt; object
     */
    public Observable<ServiceResponse<Map<String, Widget>>> getComplexItemNullAsyncWithServiceResponse() {
        return service.getComplexItemNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Widget>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Widget>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Widget>> clientResponse = getComplexItemNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Widget>> getComplexItemNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Widget>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Widget>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get dictionary of complex type with empty item {"0": {"integer": 1, "string": "2"}, "1:" {}, "2": {"integer": 5, "string": "6"}}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Widget&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Widget> getComplexItemEmpty() throws ErrorException, IOException {
        return getComplexItemEmptyAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get dictionary of complex type with empty item {"0": {"integer": 1, "string": "2"}, "1:" {}, "2": {"integer": 5, "string": "6"}}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Widget>> getComplexItemEmptyAsync(final ServiceCallback<Map<String, Widget>> serviceCallback) {
        return ServiceCall.create(getComplexItemEmptyAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get dictionary of complex type with empty item {"0": {"integer": 1, "string": "2"}, "1:" {}, "2": {"integer": 5, "string": "6"}}.
     *
     * @return the observable to the Map&lt;String, Widget&gt; object
     */
    public Observable<Map<String, Widget>> getComplexItemEmptyAsync() {
        return getComplexItemEmptyAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Widget>>, Map<String, Widget>>() {
            @Override
            public Map<String, Widget> call(ServiceResponse<Map<String, Widget>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get dictionary of complex type with empty item {"0": {"integer": 1, "string": "2"}, "1:" {}, "2": {"integer": 5, "string": "6"}}.
     *
     * @return the observable to the Map&lt;String, Widget&gt; object
     */
    public Observable<ServiceResponse<Map<String, Widget>>> getComplexItemEmptyAsyncWithServiceResponse() {
        return service.getComplexItemEmpty()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Widget>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Widget>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Widget>> clientResponse = getComplexItemEmptyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Widget>> getComplexItemEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Widget>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Widget>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get dictionary of complex type with {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer": 5, "string": "6"}}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Widget&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Widget> getComplexValid() throws ErrorException, IOException {
        return getComplexValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get dictionary of complex type with {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer": 5, "string": "6"}}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Widget>> getComplexValidAsync(final ServiceCallback<Map<String, Widget>> serviceCallback) {
        return ServiceCall.create(getComplexValidAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get dictionary of complex type with {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer": 5, "string": "6"}}.
     *
     * @return the observable to the Map&lt;String, Widget&gt; object
     */
    public Observable<Map<String, Widget>> getComplexValidAsync() {
        return getComplexValidAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Widget>>, Map<String, Widget>>() {
            @Override
            public Map<String, Widget> call(ServiceResponse<Map<String, Widget>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get dictionary of complex type with {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer": 5, "string": "6"}}.
     *
     * @return the observable to the Map&lt;String, Widget&gt; object
     */
    public Observable<ServiceResponse<Map<String, Widget>>> getComplexValidAsyncWithServiceResponse() {
        return service.getComplexValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Widget>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Widget>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Widget>> clientResponse = getComplexValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Widget>> getComplexValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Widget>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Widget>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Put an dictionary of complex type with values {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer": 5, "string": "6"}}.
     *
     * @param arrayBody the Map&lt;String, Widget&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putComplexValid(Map<String, Widget> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        putComplexValidAsyncWithServiceResponse(arrayBody).toBlocking().single().getBody();
    }

    /**
     * Put an dictionary of complex type with values {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer": 5, "string": "6"}}.
     *
     * @param arrayBody the Map&lt;String, Widget&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putComplexValidAsync(Map<String, Widget> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putComplexValidAsyncWithServiceResponse(arrayBody), serviceCallback);
    }

    /**
     * Put an dictionary of complex type with values {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer": 5, "string": "6"}}.
     *
     * @param arrayBody the Map&lt;String, Widget&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putComplexValidAsync(Map<String, Widget> arrayBody) {
        return putComplexValidAsyncWithServiceResponse(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Put an dictionary of complex type with values {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer": 5, "string": "6"}}.
     *
     * @param arrayBody the Map&lt;String, Widget&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putComplexValidAsyncWithServiceResponse(Map<String, Widget> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putComplexValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putComplexValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putComplexValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get a null array.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, List&lt;String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, List<String>> getArrayNull() throws ErrorException, IOException {
        return getArrayNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get a null array.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, List<String>>> getArrayNullAsync(final ServiceCallback<Map<String, List<String>>> serviceCallback) {
        return ServiceCall.create(getArrayNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get a null array.
     *
     * @return the observable to the Map&lt;String, List&lt;String&gt;&gt; object
     */
    public Observable<Map<String, List<String>>> getArrayNullAsync() {
        return getArrayNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, List<String>>>, Map<String, List<String>>>() {
            @Override
            public Map<String, List<String>> call(ServiceResponse<Map<String, List<String>>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get a null array.
     *
     * @return the observable to the Map&lt;String, List&lt;String&gt;&gt; object
     */
    public Observable<ServiceResponse<Map<String, List<String>>>> getArrayNullAsyncWithServiceResponse() {
        return service.getArrayNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, List<String>>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, List<String>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, List<String>>> clientResponse = getArrayNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, List<String>>> getArrayNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, List<String>>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, List<String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an empty dictionary {}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, List&lt;String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, List<String>> getArrayEmpty() throws ErrorException, IOException {
        return getArrayEmptyAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get an empty dictionary {}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, List<String>>> getArrayEmptyAsync(final ServiceCallback<Map<String, List<String>>> serviceCallback) {
        return ServiceCall.create(getArrayEmptyAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get an empty dictionary {}.
     *
     * @return the observable to the Map&lt;String, List&lt;String&gt;&gt; object
     */
    public Observable<Map<String, List<String>>> getArrayEmptyAsync() {
        return getArrayEmptyAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, List<String>>>, Map<String, List<String>>>() {
            @Override
            public Map<String, List<String>> call(ServiceResponse<Map<String, List<String>>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get an empty dictionary {}.
     *
     * @return the observable to the Map&lt;String, List&lt;String&gt;&gt; object
     */
    public Observable<ServiceResponse<Map<String, List<String>>>> getArrayEmptyAsyncWithServiceResponse() {
        return service.getArrayEmpty()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, List<String>>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, List<String>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, List<String>>> clientResponse = getArrayEmptyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, List<String>>> getArrayEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, List<String>>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, List<String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an dictionary of array of strings {"0": ["1", "2", "3"], "1": null, "2": ["7", "8", "9"]}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, List&lt;String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, List<String>> getArrayItemNull() throws ErrorException, IOException {
        return getArrayItemNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get an dictionary of array of strings {"0": ["1", "2", "3"], "1": null, "2": ["7", "8", "9"]}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, List<String>>> getArrayItemNullAsync(final ServiceCallback<Map<String, List<String>>> serviceCallback) {
        return ServiceCall.create(getArrayItemNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get an dictionary of array of strings {"0": ["1", "2", "3"], "1": null, "2": ["7", "8", "9"]}.
     *
     * @return the observable to the Map&lt;String, List&lt;String&gt;&gt; object
     */
    public Observable<Map<String, List<String>>> getArrayItemNullAsync() {
        return getArrayItemNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, List<String>>>, Map<String, List<String>>>() {
            @Override
            public Map<String, List<String>> call(ServiceResponse<Map<String, List<String>>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get an dictionary of array of strings {"0": ["1", "2", "3"], "1": null, "2": ["7", "8", "9"]}.
     *
     * @return the observable to the Map&lt;String, List&lt;String&gt;&gt; object
     */
    public Observable<ServiceResponse<Map<String, List<String>>>> getArrayItemNullAsyncWithServiceResponse() {
        return service.getArrayItemNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, List<String>>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, List<String>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, List<String>>> clientResponse = getArrayItemNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, List<String>>> getArrayItemNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, List<String>>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, List<String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of array of strings [{"0": ["1", "2", "3"], "1": [], "2": ["7", "8", "9"]}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, List&lt;String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, List<String>> getArrayItemEmpty() throws ErrorException, IOException {
        return getArrayItemEmptyAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get an array of array of strings [{"0": ["1", "2", "3"], "1": [], "2": ["7", "8", "9"]}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, List<String>>> getArrayItemEmptyAsync(final ServiceCallback<Map<String, List<String>>> serviceCallback) {
        return ServiceCall.create(getArrayItemEmptyAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get an array of array of strings [{"0": ["1", "2", "3"], "1": [], "2": ["7", "8", "9"]}.
     *
     * @return the observable to the Map&lt;String, List&lt;String&gt;&gt; object
     */
    public Observable<Map<String, List<String>>> getArrayItemEmptyAsync() {
        return getArrayItemEmptyAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, List<String>>>, Map<String, List<String>>>() {
            @Override
            public Map<String, List<String>> call(ServiceResponse<Map<String, List<String>>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get an array of array of strings [{"0": ["1", "2", "3"], "1": [], "2": ["7", "8", "9"]}.
     *
     * @return the observable to the Map&lt;String, List&lt;String&gt;&gt; object
     */
    public Observable<ServiceResponse<Map<String, List<String>>>> getArrayItemEmptyAsyncWithServiceResponse() {
        return service.getArrayItemEmpty()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, List<String>>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, List<String>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, List<String>>> clientResponse = getArrayItemEmptyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, List<String>>> getArrayItemEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, List<String>>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, List<String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, List&lt;String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, List<String>> getArrayValid() throws ErrorException, IOException {
        return getArrayValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get an array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, List<String>>> getArrayValidAsync(final ServiceCallback<Map<String, List<String>>> serviceCallback) {
        return ServiceCall.create(getArrayValidAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get an array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}.
     *
     * @return the observable to the Map&lt;String, List&lt;String&gt;&gt; object
     */
    public Observable<Map<String, List<String>>> getArrayValidAsync() {
        return getArrayValidAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, List<String>>>, Map<String, List<String>>>() {
            @Override
            public Map<String, List<String>> call(ServiceResponse<Map<String, List<String>>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get an array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}.
     *
     * @return the observable to the Map&lt;String, List&lt;String&gt;&gt; object
     */
    public Observable<ServiceResponse<Map<String, List<String>>>> getArrayValidAsyncWithServiceResponse() {
        return service.getArrayValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, List<String>>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, List<String>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, List<String>>> clientResponse = getArrayValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, List<String>>> getArrayValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, List<String>>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, List<String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Put An array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}.
     *
     * @param arrayBody the Map&lt;String, List&lt;String&gt;&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putArrayValid(Map<String, List<String>> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        putArrayValidAsyncWithServiceResponse(arrayBody).toBlocking().single().getBody();
    }

    /**
     * Put An array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}.
     *
     * @param arrayBody the Map&lt;String, List&lt;String&gt;&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putArrayValidAsync(Map<String, List<String>> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putArrayValidAsyncWithServiceResponse(arrayBody), serviceCallback);
    }

    /**
     * Put An array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}.
     *
     * @param arrayBody the Map&lt;String, List&lt;String&gt;&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putArrayValidAsync(Map<String, List<String>> arrayBody) {
        return putArrayValidAsyncWithServiceResponse(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Put An array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}.
     *
     * @param arrayBody the Map&lt;String, List&lt;String&gt;&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putArrayValidAsyncWithServiceResponse(Map<String, List<String>> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putArrayValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putArrayValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putArrayValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an dictionaries of dictionaries with value null.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Map&lt;String, String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Map<String, String>> getDictionaryNull() throws ErrorException, IOException {
        return getDictionaryNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get an dictionaries of dictionaries with value null.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Map<String, String>>> getDictionaryNullAsync(final ServiceCallback<Map<String, Map<String, String>>> serviceCallback) {
        return ServiceCall.create(getDictionaryNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get an dictionaries of dictionaries with value null.
     *
     * @return the observable to the Map&lt;String, Map&lt;String, String&gt;&gt; object
     */
    public Observable<Map<String, Map<String, String>>> getDictionaryNullAsync() {
        return getDictionaryNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Map<String, String>>>, Map<String, Map<String, String>>>() {
            @Override
            public Map<String, Map<String, String>> call(ServiceResponse<Map<String, Map<String, String>>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get an dictionaries of dictionaries with value null.
     *
     * @return the observable to the Map&lt;String, Map&lt;String, String&gt;&gt; object
     */
    public Observable<ServiceResponse<Map<String, Map<String, String>>>> getDictionaryNullAsyncWithServiceResponse() {
        return service.getDictionaryNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Map<String, String>>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Map<String, String>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Map<String, String>>> clientResponse = getDictionaryNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Map<String, String>>> getDictionaryNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Map<String, String>>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Map<String, String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Map&lt;String, String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Map<String, String>> getDictionaryEmpty() throws ErrorException, IOException {
        return getDictionaryEmptyAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Map<String, String>>> getDictionaryEmptyAsync(final ServiceCallback<Map<String, Map<String, String>>> serviceCallback) {
        return ServiceCall.create(getDictionaryEmptyAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {}.
     *
     * @return the observable to the Map&lt;String, Map&lt;String, String&gt;&gt; object
     */
    public Observable<Map<String, Map<String, String>>> getDictionaryEmptyAsync() {
        return getDictionaryEmptyAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Map<String, String>>>, Map<String, Map<String, String>>>() {
            @Override
            public Map<String, Map<String, String>> call(ServiceResponse<Map<String, Map<String, String>>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {}.
     *
     * @return the observable to the Map&lt;String, Map&lt;String, String&gt;&gt; object
     */
    public Observable<ServiceResponse<Map<String, Map<String, String>>>> getDictionaryEmptyAsyncWithServiceResponse() {
        return service.getDictionaryEmpty()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Map<String, String>>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Map<String, String>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Map<String, String>>> clientResponse = getDictionaryEmptyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Map<String, String>>> getDictionaryEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Map<String, String>>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Map<String, String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": null, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Map&lt;String, String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Map<String, String>> getDictionaryItemNull() throws ErrorException, IOException {
        return getDictionaryItemNullAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": null, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Map<String, String>>> getDictionaryItemNullAsync(final ServiceCallback<Map<String, Map<String, String>>> serviceCallback) {
        return ServiceCall.create(getDictionaryItemNullAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": null, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @return the observable to the Map&lt;String, Map&lt;String, String&gt;&gt; object
     */
    public Observable<Map<String, Map<String, String>>> getDictionaryItemNullAsync() {
        return getDictionaryItemNullAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Map<String, String>>>, Map<String, Map<String, String>>>() {
            @Override
            public Map<String, Map<String, String>> call(ServiceResponse<Map<String, Map<String, String>>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": null, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @return the observable to the Map&lt;String, Map&lt;String, String&gt;&gt; object
     */
    public Observable<ServiceResponse<Map<String, Map<String, String>>>> getDictionaryItemNullAsyncWithServiceResponse() {
        return service.getDictionaryItemNull()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Map<String, String>>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Map<String, String>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Map<String, String>>> clientResponse = getDictionaryItemNullDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Map<String, String>>> getDictionaryItemNullDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Map<String, String>>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Map<String, String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Map&lt;String, String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Map<String, String>> getDictionaryItemEmpty() throws ErrorException, IOException {
        return getDictionaryItemEmptyAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Map<String, String>>> getDictionaryItemEmptyAsync(final ServiceCallback<Map<String, Map<String, String>>> serviceCallback) {
        return ServiceCall.create(getDictionaryItemEmptyAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @return the observable to the Map&lt;String, Map&lt;String, String&gt;&gt; object
     */
    public Observable<Map<String, Map<String, String>>> getDictionaryItemEmptyAsync() {
        return getDictionaryItemEmptyAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Map<String, String>>>, Map<String, Map<String, String>>>() {
            @Override
            public Map<String, Map<String, String>> call(ServiceResponse<Map<String, Map<String, String>>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @return the observable to the Map&lt;String, Map&lt;String, String&gt;&gt; object
     */
    public Observable<ServiceResponse<Map<String, Map<String, String>>>> getDictionaryItemEmptyAsyncWithServiceResponse() {
        return service.getDictionaryItemEmpty()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Map<String, String>>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Map<String, String>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Map<String, String>>> clientResponse = getDictionaryItemEmptyDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Map<String, String>>> getDictionaryItemEmptyDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Map<String, String>>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Map<String, String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five", "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @return the Map&lt;String, Map&lt;String, String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.
     */
    public Map<String, Map<String, String>> getDictionaryValid() throws ErrorException, IOException {
        return getDictionaryValidAsyncWithServiceResponse().toBlocking().single().getBody();
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five", "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Map<String, Map<String, String>>> getDictionaryValidAsync(final ServiceCallback<Map<String, Map<String, String>>> serviceCallback) {
        return ServiceCall.create(getDictionaryValidAsyncWithServiceResponse(), serviceCallback);
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five", "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @return the observable to the Map&lt;String, Map&lt;String, String&gt;&gt; object
     */
    public Observable<Map<String, Map<String, String>>> getDictionaryValidAsync() {
        return getDictionaryValidAsyncWithServiceResponse().map(new Func1<ServiceResponse<Map<String, Map<String, String>>>, Map<String, Map<String, String>>>() {
            @Override
            public Map<String, Map<String, String>> call(ServiceResponse<Map<String, Map<String, String>>> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five", "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @return the observable to the Map&lt;String, Map&lt;String, String&gt;&gt; object
     */
    public Observable<ServiceResponse<Map<String, Map<String, String>>>> getDictionaryValidAsyncWithServiceResponse() {
        return service.getDictionaryValid()
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, Map<String, String>>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, Map<String, String>>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, Map<String, String>>> clientResponse = getDictionaryValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Map<String, Map<String, String>>> getDictionaryValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException {
        return new ServiceResponseBuilder<Map<String, Map<String, String>>, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Map<String, Map<String, String>>>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five", "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @param arrayBody the Map&lt;String, Map&lt;String, String&gt;&gt; value
     * @throws ErrorException exception thrown from REST call
     * @throws IOException exception thrown from serialization/deserialization
     * @throws IllegalArgumentException exception thrown from invalid parameters
     * @return the {@link ServiceResponse} object if successful.
     */
    public void putDictionaryValid(Map<String, Map<String, String>> arrayBody) throws ErrorException, IOException, IllegalArgumentException {
        putDictionaryValidAsyncWithServiceResponse(arrayBody).toBlocking().single().getBody();
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five", "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @param arrayBody the Map&lt;String, Map&lt;String, String&gt;&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     * @return the {@link ServiceCall} object
     */
    public ServiceCall<Void> putDictionaryValidAsync(Map<String, Map<String, String>> arrayBody, final ServiceCallback<Void> serviceCallback) {
        return ServiceCall.create(putDictionaryValidAsyncWithServiceResponse(arrayBody), serviceCallback);
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five", "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @param arrayBody the Map&lt;String, Map&lt;String, String&gt;&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<Void> putDictionaryValidAsync(Map<String, Map<String, String>> arrayBody) {
        return putDictionaryValidAsyncWithServiceResponse(arrayBody).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.getBody();
            }
        }); 
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five", "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}.
     *
     * @param arrayBody the Map&lt;String, Map&lt;String, String&gt;&gt; value
     * @return the {@link ServiceResponse} object if successful.
     */
    public Observable<ServiceResponse<Void>> putDictionaryValidAsyncWithServiceResponse(Map<String, Map<String, String>> arrayBody) {
        if (arrayBody == null) {
            throw new IllegalArgumentException("Parameter arrayBody is required and cannot be null.");
        }
        Validator.validate(arrayBody);
        return service.putDictionaryValid(arrayBody)
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = putDictionaryValidDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }

    private ServiceResponse<Void> putDictionaryValidDelegate(Response<ResponseBody> response) throws ErrorException, IOException, IllegalArgumentException {
        return new ServiceResponseBuilder<Void, ErrorException>(this.client.mapperAdapter())
                .register(200, new TypeToken<Void>() { }.getType())
                .registerError(ErrorException.class)
                .build(response);
    }

}
