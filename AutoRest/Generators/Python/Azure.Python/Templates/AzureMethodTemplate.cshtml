@using System;
@using System.Linq;
@using Microsoft.Rest.Generator.ClientModel
@using Microsoft.Rest.Generator.Utilities
@using Microsoft.Rest.Generator.Python
@using Microsoft.Rest.Generator.Python.TemplateModels
@using Microsoft.Rest.Generator.Python.Templates
@inherits Microsoft.Rest.Generator.Template<Microsoft.Rest.Generator.Azure.Python.AzureMethodTemplateModel>
@if (!Model.IsPagingMethod && !Model.IsLongRunningOperation)
{
@:@(Include(new MethodTemplate(), (MethodTemplateModel)Model))
}
else if (Model.IsPagingMethod)
{
<text>
    @@async_request
    def @(Model.Name.ToPythonCase())(
            self, @(Model.MethodParameterDeclaration(true))):
        """
@if (!String.IsNullOrEmpty(Model.Summary))
{
@:        @WrapComment(string.Empty, Model.Summary)
}
@if (!String.IsNullOrEmpty(Model.Description))
{
@EmptyLine
@:        @WrapComment(string.Empty, Model.Description)
}
@EmptyLine
@*need to fix comment here for paging function*@
    @foreach(var parameter in Model.DocumentationParameters)
    {
@:        @WrapComment(string.Empty, ":param " + parameter.Name + ": " + parameter.Documentation)
    }
        @WrapComment(string.Empty, ":param custom_headers: headers that will be added to the request")
        @WrapComment(string.Empty, ":param raw: returns the direct response alongside the deserialized response")
        @WrapComment(string.Empty, ":param callback: if provided, the call will run asynchronously and call the callback when complete.  When specified the function returns a concurrent.futures.Future")
    @foreach (var parameter in Model.DocumentationParameters)
    {
@:        @WrapComment(string.Empty, ":type " + parameter.Name + ": " + MethodTemplateModel.GetDocumentationType(parameter.Type, parameter.IsRequired))
    }
        @WrapComment(string.Empty, ":type custom_headers: dict")
        @WrapComment(string.Empty, ":type raw: boolean")
        @WrapComment(string.Empty, ":type callback: Callable[[concurrent.futures.Future], None] or None")

        @WrapComment(string.Empty, string.Format(":rtype: {0} or ({0}, requests.response) or concurrent.futures.Future", MethodTemplateModel.GetDocumentationType(Model.ReturnType)))

        """
@EmptyLine
        @Model.BuildInputMappings()
@if (Model.InputParameterTransformation.Any())
{
@EmptyLine
}
        def internal_paging(next_link=None, raw=False):
@EmptyLine
            if next_link is None:
                # Construct URL
                url = '@(Model.Url)'
                @(Model.BuildUrlPath("url"))
@EmptyLine
                # Construct parameters
                query_parameters = {}
                @(Model.BuildUrlQuery("query_parameters"))
@EmptyLine
            else:
                url = next_link
                query_parameters = {}
@EmptyLine
            # Construct headers
            header_parameters = {}
            header_parameters['Content-Type'] = '@(Model.ContentType)'
            @(Model.SetDefaultHeaders)
            @(Model.BuildHeaders("header_parameters"))
@EmptyLine
@if (Model.RequestBody != null)
{
            @:# Construct body
  if (Model.RequestBody.IsRequired)
  {
            @:body_content = self._serialize(@Model.RequestBody.Name, '@(Model.RequestBody.Type.ToPythonRuntimeTypeString())')
  }
  else
  {
            @:if @Model.RequestBody.Name is not None:
                @:body_content = self._serialize(@Model.RequestBody.Name, '@(Model.RequestBody.Type.ToPythonRuntimeTypeString())')
            @:else:
                @:body_content = None
  }
@EmptyLine
}
            # Construct and send request
            request = self._client.@(MethodTemplateModel.GetHttpFunction(Model.HttpMethod))(url, query_parameters)
@if (Model.RequestBody != null)
{
            @:response = self._client.send(
                @:request, header_parameters, body_content, **operation_config)
}
else
{
            @:response = self._client.send(
                @:request, header_parameters, **operation_config)
}
@EmptyLine
            if @Model.FailureStatusCodePredicate:
                raise @Model.RaisedException
@EmptyLine
            return response
@EmptyLine
        response = internal_paging()
@EmptyLine
        # Deserialize response
        deserialized = @(Model.PagedResponseClassName)(response, internal_paging, self._deserialize.dependencies)
@EmptyLine
        if raw:
            return deserialized, response
@EmptyLine
        return deserialized
</text>
}
else //Long running operations
{
<text>
    def @(Model.Name.ToPythonCase())(
            self, @(Model.MethodParameterDeclaration(Model.AddCustomHeader))):
        """
@*need to fix comment here for long running function*@
@if (!String.IsNullOrEmpty(Model.Summary))
{
@:        @WrapComment(string.Empty, Model.Summary)
}
@if (!String.IsNullOrEmpty(Model.Description))
{
@EmptyLine
@:        @WrapComment(string.Empty, Model.Description)
}
@EmptyLine
    @foreach(var parameter in Model.DocumentationParameters)
    {
@:        @WrapComment(string.Empty, ":param " + parameter.Name + ": " + parameter.Documentation)
    }
        @WrapComment(string.Empty, ":param custom_headers: headers that will be added to the request")
        @WrapComment(string.Empty, ":param raw: returns the direct response alongside the deserialized response")
        @WrapComment(string.Empty, ":param callback: if provided, the call will run asynchronously and call the callback when complete.  When specified the function returns a concurrent.futures.Future")
    @foreach (var parameter in Model.DocumentationParameters)
    {
@:        @WrapComment(string.Empty, ":type " + parameter.Name + ": " + MethodTemplateModel.GetDocumentationType(parameter.Type, parameter.IsRequired))
    }
        @WrapComment(string.Empty, ":type custom_headers: dict")
        @WrapComment(string.Empty, ":type raw: boolean")
        @WrapComment(string.Empty, ":type callback: Callable[[concurrent.futures.Future], None] or None")

        @WrapComment(string.Empty, string.Format(":rtype: {0} or ({0}, requests.response) or concurrent.futures.Future", MethodTemplateModel.GetDocumentationType(Model.ReturnType)))

        """
@EmptyLine
        @Model.BuildInputMappings()
@if (Model.InputParameterTransformation.Any())
{
@EmptyLine
}
        # Construct URL
        url = '@(Model.Url)'
        @(Model.BuildUrlPath("url"))
@EmptyLine
        # Construct parameters
        query_parameters = {}
        @(Model.BuildUrlQuery("query_parameters"))
@EmptyLine
        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = '@(Model.ContentType)'
        @(Model.SetDefaultHeaders)
        @(Model.BuildHeaders("header_parameters"))
@EmptyLine
@if (Model.RequestBody != null)
{
        @:# Construct body
  if (Model.RequestBody.IsRequired)
  {
        @:body_content = self._serialize(@Model.RequestBody.Name, '@(Model.RequestBody.Type.ToPythonRuntimeTypeString())')
  }
  else
  {
        @:if @Model.RequestBody.Name is not None:
            @:body_content = self._serialize(@Model.RequestBody.Name, '@(Model.RequestBody.Type.ToPythonRuntimeTypeString())')
        @:else:
            @:body_content = None
  }
@EmptyLine
}
        # Construct and send request
        def long_running_send():
            request = self._client.@(MethodTemplateModel.GetHttpFunction(Model.HttpMethod))(url, query_parameters)
@if (Model.RequestBody != null)
{
            @:return self._client.send(
                @:request, header_parameters, body_content, **operation_config)
}
else
{
            @:return self._client.send(request, header_parameters, **operation_config)
}
@EmptyLine
        def get_long_running_status(status_link):
            request = self._client.get(status_link)
            return self._client.send(
                request, header_parameters, **operation_config)
@EmptyLine
        def get_long_running_output(response):
            if @Model.FailureStatusCodePredicate:
                raise @Model.RaisedException
@EmptyLine
@if (Model.HasAnyResponse)
{
  if (Model.IsResponseStream)
  {
            @:def download_gen():
                @:for data in response.iter_content(self.config.connection.data_block_size):
                    @:if not data:
                        @:break
@EmptyLine
                    @:yield data
@EmptyLine
            @:if raw:
                @:return download_gen(), response
@EmptyLine
            @:return download_gen()
  }
  else
  {
            @:deserialized = None
@EmptyLine
    foreach (var responsePair in Model.Responses.Where(r => r.Value != null))
    {
            @:if response.status_code == @MethodTemplateModel.GetStatusCodeReference(responsePair.Key):
                @:deserialized = self._deserialize('@responsePair.Value.ToPythonRuntimeTypeString()', response)
    }
@EmptyLine
            @:if raw:
                @:return deserialized, response
@EmptyLine
            @:return deserialized
  }
}
else
{
            @:if raw:
                @:return None, response
}
@EmptyLine
        long_running_operation_timeout = operation_config.get(
            'long_running_operation_timeout',
            self.config.long_running_operation_timeout)
        return AzureOperationPoller(
            long_running_send, get_long_running_output,
            get_long_running_status, long_running_operation_timeout)
</text>
}
