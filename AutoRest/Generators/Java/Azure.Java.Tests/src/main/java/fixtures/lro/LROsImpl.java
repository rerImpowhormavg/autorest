/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 * 
 * Code generated by Microsoft (R) AutoRest Code Generator 0.12.0.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package fixtures.lro;

import com.google.common.reflect.TypeToken;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceException;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseBuilder;
import com.microsoft.rest.ServiceResponseCallback;
import com.microsoft.rest.ServiceResponseEmptyCallback;
import com.squareup.okhttp.ResponseBody;
import retrofit.Retrofit;
import retrofit.Call;
import retrofit.Response;
import java.io.IOException;
import fixtures.lro.models.Product;
import fixtures.lro.models.Sku;
import fixtures.lro.models.SubProduct;
import fixtures.lro.models.CloudError;

public class LROsImpl implements LROs {
    private LROsService service;
    AutoRestLongRunningOperationTestService client;

    public LROsImpl(Retrofit retrofit, AutoRestLongRunningOperationTestService client) {
        this.service = retrofit.create(LROsService.class);
        this.client = client;
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Succeeded’.
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> put200Succeeded(Product product) throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Product> result = this.beginPut200Succeeded(product);
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Succeeded’.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> put200SucceededAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        return this.beginPut200SucceededAsync(product, new ServiceCallback<Product>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Product> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Succeeded’.
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> beginPut200Succeeded(Product product) throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPut200Succeeded(product, this.client.getAcceptLanguage());
            return beginPut200SucceededDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Succeeded’.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPut200SucceededAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        Call<ResponseBody> call = service.beginPut200Succeeded(product, this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Product>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPut200SucceededDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Product> beginPut200SucceededDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(204, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that does not contain ProvisioningState=’Succeeded’.
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> put200SucceededNoState(Product product) throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Product> result = this.beginPut200SucceededNoState(product);
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that does not contain ProvisioningState=’Succeeded’.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> put200SucceededNoStateAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        return this.beginPut200SucceededNoStateAsync(product, new ServiceCallback<Product>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Product> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that does not contain ProvisioningState=’Succeeded’.
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> beginPut200SucceededNoState(Product product) throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPut200SucceededNoState(product, this.client.getAcceptLanguage());
            return beginPut200SucceededNoStateDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that does not contain ProvisioningState=’Succeeded’.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPut200SucceededNoStateAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        Call<ResponseBody> call = service.beginPut200SucceededNoState(product, this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Product>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPut200SucceededNoStateDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Product> beginPut200SucceededNoStateDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running put request, service returns a 202 to the initial request, with a location header that points to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> put202Retry200(Product product) throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Product> result = this.beginPut202Retry200(product);
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running put request, service returns a 202 to the initial request, with a location header that points to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> put202Retry200Async(Product product, final ServiceCallback<Product> serviceCallback) {
        return this.beginPut202Retry200Async(product, new ServiceCallback<Product>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Product> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running put request, service returns a 202 to the initial request, with a location header that points to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> beginPut202Retry200(Product product) throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPut202Retry200(product, this.client.getAcceptLanguage());
            return beginPut202Retry200Delegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running put request, service returns a 202 to the initial request, with a location header that points to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPut202Retry200Async(Product product, final ServiceCallback<Product> serviceCallback) {
        Call<ResponseBody> call = service.beginPut202Retry200(product, this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Product>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPut202Retry200Delegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Product> beginPut202Retry200Delegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(202, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> put201CreatingSucceeded200(Product product) throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Product> result = this.beginPut201CreatingSucceeded200(product);
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> put201CreatingSucceeded200Async(Product product, final ServiceCallback<Product> serviceCallback) {
        return this.beginPut201CreatingSucceeded200Async(product, new ServiceCallback<Product>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Product> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> beginPut201CreatingSucceeded200(Product product) throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPut201CreatingSucceeded200(product, this.client.getAcceptLanguage());
            return beginPut201CreatingSucceeded200Delegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPut201CreatingSucceeded200Async(Product product, final ServiceCallback<Product> serviceCallback) {
        Call<ResponseBody> call = service.beginPut201CreatingSucceeded200(product, this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Product>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPut201CreatingSucceeded200Delegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Product> beginPut201CreatingSucceeded200Delegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(201, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Updating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> put200UpdatingSucceeded204(Product product) throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Product> result = this.beginPut200UpdatingSucceeded204(product);
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Updating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> put200UpdatingSucceeded204Async(Product product, final ServiceCallback<Product> serviceCallback) {
        return this.beginPut200UpdatingSucceeded204Async(product, new ServiceCallback<Product>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Product> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Updating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> beginPut200UpdatingSucceeded204(Product product) throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPut200UpdatingSucceeded204(product, this.client.getAcceptLanguage());
            return beginPut200UpdatingSucceeded204Delegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Updating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPut200UpdatingSucceeded204Async(Product product, final ServiceCallback<Product> serviceCallback) {
        Call<ResponseBody> call = service.beginPut200UpdatingSucceeded204(product, this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Product>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPut200UpdatingSucceeded204Delegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Product> beginPut200UpdatingSucceeded204Delegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Created’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> put201CreatingFailed200(Product product) throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Product> result = this.beginPut201CreatingFailed200(product);
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Created’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> put201CreatingFailed200Async(Product product, final ServiceCallback<Product> serviceCallback) {
        return this.beginPut201CreatingFailed200Async(product, new ServiceCallback<Product>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Product> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Created’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> beginPut201CreatingFailed200(Product product) throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPut201CreatingFailed200(product, this.client.getAcceptLanguage());
            return beginPut201CreatingFailed200Delegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Created’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPut201CreatingFailed200Async(Product product, final ServiceCallback<Product> serviceCallback) {
        Call<ResponseBody> call = service.beginPut201CreatingFailed200(product, this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Product>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPut201CreatingFailed200Delegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Product> beginPut201CreatingFailed200Delegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(201, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> put200Acceptedcanceled200(Product product) throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Product> result = this.beginPut200Acceptedcanceled200(product);
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> put200Acceptedcanceled200Async(Product product, final ServiceCallback<Product> serviceCallback) {
        return this.beginPut200Acceptedcanceled200Async(product, new ServiceCallback<Product>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Product> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> beginPut200Acceptedcanceled200(Product product) throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPut200Acceptedcanceled200(product, this.client.getAcceptLanguage());
            return beginPut200Acceptedcanceled200Delegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPut200Acceptedcanceled200Async(Product product, final ServiceCallback<Product> serviceCallback) {
        Call<ResponseBody> call = service.beginPut200Acceptedcanceled200(product, this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Product>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPut200Acceptedcanceled200Delegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Product> beginPut200Acceptedcanceled200Delegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to operation status do not contain location header.
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> putNoHeaderInRetry(Product product) throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Product> result = this.beginPutNoHeaderInRetry(product);
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to operation status do not contain location header.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putNoHeaderInRetryAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        return this.beginPutNoHeaderInRetryAsync(product, new ServiceCallback<Product>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Product> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to operation status do not contain location header.
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> beginPutNoHeaderInRetry(Product product) throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPutNoHeaderInRetry(product, this.client.getAcceptLanguage());
            return beginPutNoHeaderInRetryDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to operation status do not contain location header.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPutNoHeaderInRetryAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        Call<ResponseBody> call = service.beginPutNoHeaderInRetry(product, this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Product>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPutNoHeaderInRetryDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Product> beginPutNoHeaderInRetryDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(202, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> putAsyncRetrySucceeded(Product product) throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Product> result = this.beginPutAsyncRetrySucceeded(product);
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putAsyncRetrySucceededAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        return this.beginPutAsyncRetrySucceededAsync(product, new ServiceCallback<Product>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Product> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> beginPutAsyncRetrySucceeded(Product product) throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPutAsyncRetrySucceeded(product, this.client.getAcceptLanguage());
            return beginPutAsyncRetrySucceededDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPutAsyncRetrySucceededAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        Call<ResponseBody> call = service.beginPutAsyncRetrySucceeded(product, this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Product>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPutAsyncRetrySucceededDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Product> beginPutAsyncRetrySucceededDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> putAsyncNoRetrySucceeded(Product product) throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Product> result = this.beginPutAsyncNoRetrySucceeded(product);
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putAsyncNoRetrySucceededAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        return this.beginPutAsyncNoRetrySucceededAsync(product, new ServiceCallback<Product>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Product> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> beginPutAsyncNoRetrySucceeded(Product product) throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPutAsyncNoRetrySucceeded(product, this.client.getAcceptLanguage());
            return beginPutAsyncNoRetrySucceededDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPutAsyncNoRetrySucceededAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        Call<ResponseBody> call = service.beginPutAsyncNoRetrySucceeded(product, this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Product>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPutAsyncNoRetrySucceededDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Product> beginPutAsyncNoRetrySucceededDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> putAsyncRetryFailed(Product product) throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Product> result = this.beginPutAsyncRetryFailed(product);
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putAsyncRetryFailedAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        return this.beginPutAsyncRetryFailedAsync(product, new ServiceCallback<Product>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Product> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> beginPutAsyncRetryFailed(Product product) throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPutAsyncRetryFailed(product, this.client.getAcceptLanguage());
            return beginPutAsyncRetryFailedDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPutAsyncRetryFailedAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        Call<ResponseBody> call = service.beginPutAsyncRetryFailed(product, this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Product>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPutAsyncRetryFailedDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Product> beginPutAsyncRetryFailedDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> putAsyncNoRetrycanceled(Product product) throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Product> result = this.beginPutAsyncNoRetrycanceled(product);
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putAsyncNoRetrycanceledAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        return this.beginPutAsyncNoRetrycanceledAsync(product, new ServiceCallback<Product>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Product> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> beginPutAsyncNoRetrycanceled(Product product) throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPutAsyncNoRetrycanceled(product, this.client.getAcceptLanguage());
            return beginPutAsyncNoRetrycanceledDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPutAsyncNoRetrycanceledAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        Call<ResponseBody> call = service.beginPutAsyncNoRetrycanceled(product, this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Product>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPutAsyncNoRetrycanceledDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Product> beginPutAsyncNoRetrycanceledDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> putAsyncNoHeaderInRetry(Product product) throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Product> result = this.beginPutAsyncNoHeaderInRetry(product);
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putAsyncNoHeaderInRetryAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        return this.beginPutAsyncNoHeaderInRetryAsync(product, new ServiceCallback<Product>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Product> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> beginPutAsyncNoHeaderInRetry(Product product) throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPutAsyncNoHeaderInRetry(product, this.client.getAcceptLanguage());
            return beginPutAsyncNoHeaderInRetryDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPutAsyncNoHeaderInRetryAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        Call<ResponseBody> call = service.beginPutAsyncNoHeaderInRetry(product, this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Product>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPutAsyncNoHeaderInRetryDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Product> beginPutAsyncNoHeaderInRetryDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(201, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running put request with non resource.
     *
     * @param sku sku to put
     * @return the Sku object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Sku> putNonResource(Sku sku) throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Sku> result = this.beginPutNonResource(sku);
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running put request with non resource.
     *
     * @param sku sku to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putNonResourceAsync(Sku sku, final ServiceCallback<Sku> serviceCallback) {
        return this.beginPutNonResourceAsync(sku, new ServiceCallback<Sku>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Sku> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running put request with non resource.
     *
     * @param sku sku to put
     * @return the Sku object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Sku> beginPutNonResource(Sku sku) throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPutNonResource(sku, this.client.getAcceptLanguage());
            return beginPutNonResourceDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running put request with non resource.
     *
     * @param sku sku to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPutNonResourceAsync(Sku sku, final ServiceCallback<Sku> serviceCallback) {
        Call<ResponseBody> call = service.beginPutNonResource(sku, this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Sku>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPutNonResourceDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Sku> beginPutNonResourceDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Sku>()
                .register(202, new TypeToken<Sku>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running put request with non resource.
     *
     * @param sku Sku to put
     * @return the Sku object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Sku> putAsyncNonResource(Sku sku) throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Sku> result = this.beginPutAsyncNonResource(sku);
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running put request with non resource.
     *
     * @param sku Sku to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putAsyncNonResourceAsync(Sku sku, final ServiceCallback<Sku> serviceCallback) {
        return this.beginPutAsyncNonResourceAsync(sku, new ServiceCallback<Sku>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Sku> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running put request with non resource.
     *
     * @param sku Sku to put
     * @return the Sku object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Sku> beginPutAsyncNonResource(Sku sku) throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPutAsyncNonResource(sku, this.client.getAcceptLanguage());
            return beginPutAsyncNonResourceDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running put request with non resource.
     *
     * @param sku Sku to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPutAsyncNonResourceAsync(Sku sku, final ServiceCallback<Sku> serviceCallback) {
        Call<ResponseBody> call = service.beginPutAsyncNonResource(sku, this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Sku>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPutAsyncNonResourceDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Sku> beginPutAsyncNonResourceDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Sku>()
                .register(202, new TypeToken<Sku>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running put request with sub resource.
     *
     * @param product Sub Product to put
     * @return the SubProduct object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<SubProduct> putSubResource(SubProduct product) throws ServiceException, IOException, InterruptedException {
        ServiceResponse<SubProduct> result = this.beginPutSubResource(product);
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running put request with sub resource.
     *
     * @param product Sub Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putSubResourceAsync(SubProduct product, final ServiceCallback<SubProduct> serviceCallback) {
        return this.beginPutSubResourceAsync(product, new ServiceCallback<SubProduct>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<SubProduct> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running put request with sub resource.
     *
     * @param product Sub Product to put
     * @return the SubProduct object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<SubProduct> beginPutSubResource(SubProduct product) throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPutSubResource(product, this.client.getAcceptLanguage());
            return beginPutSubResourceDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running put request with sub resource.
     *
     * @param product Sub Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPutSubResourceAsync(SubProduct product, final ServiceCallback<SubProduct> serviceCallback) {
        Call<ResponseBody> call = service.beginPutSubResource(product, this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<SubProduct>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPutSubResourceDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<SubProduct> beginPutSubResourceDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<SubProduct>()
                .register(202, new TypeToken<SubProduct>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running put request with sub resource.
     *
     * @param product Sub Product to put
     * @return the SubProduct object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<SubProduct> putAsyncSubResource(SubProduct product) throws ServiceException, IOException, InterruptedException {
        ServiceResponse<SubProduct> result = this.beginPutAsyncSubResource(product);
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running put request with sub resource.
     *
     * @param product Sub Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putAsyncSubResourceAsync(SubProduct product, final ServiceCallback<SubProduct> serviceCallback) {
        return this.beginPutAsyncSubResourceAsync(product, new ServiceCallback<SubProduct>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<SubProduct> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running put request with sub resource.
     *
     * @param product Sub Product to put
     * @return the SubProduct object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<SubProduct> beginPutAsyncSubResource(SubProduct product) throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPutAsyncSubResource(product, this.client.getAcceptLanguage());
            return beginPutAsyncSubResourceDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running put request with sub resource.
     *
     * @param product Sub Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPutAsyncSubResourceAsync(SubProduct product, final ServiceCallback<SubProduct> serviceCallback) {
        Call<ResponseBody> call = service.beginPutAsyncSubResource(product, this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<SubProduct>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPutAsyncSubResourceDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<SubProduct> beginPutAsyncSubResourceDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<SubProduct>()
                .register(202, new TypeToken<SubProduct>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Accepted’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> deleteProvisioning202Accepted200Succeeded() throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Product> result = this.beginDeleteProvisioning202Accepted200Succeeded();
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Accepted’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> deleteProvisioning202Accepted200SucceededAsync(final ServiceCallback<Product> serviceCallback) {
        return this.beginDeleteProvisioning202Accepted200SucceededAsync(new ServiceCallback<Product>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Product> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Accepted’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> beginDeleteProvisioning202Accepted200Succeeded() throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginDeleteProvisioning202Accepted200Succeeded(this.client.getAcceptLanguage());
            return beginDeleteProvisioning202Accepted200SucceededDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Accepted’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginDeleteProvisioning202Accepted200SucceededAsync(final ServiceCallback<Product> serviceCallback) {
        Call<ResponseBody> call = service.beginDeleteProvisioning202Accepted200Succeeded(this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Product>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginDeleteProvisioning202Accepted200SucceededDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Product> beginDeleteProvisioning202Accepted200SucceededDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(202, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
     *
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> deleteProvisioning202DeletingFailed200() throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Product> result = this.beginDeleteProvisioning202DeletingFailed200();
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> deleteProvisioning202DeletingFailed200Async(final ServiceCallback<Product> serviceCallback) {
        return this.beginDeleteProvisioning202DeletingFailed200Async(new ServiceCallback<Product>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Product> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
     *
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> beginDeleteProvisioning202DeletingFailed200() throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginDeleteProvisioning202DeletingFailed200(this.client.getAcceptLanguage());
            return beginDeleteProvisioning202DeletingFailed200Delegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginDeleteProvisioning202DeletingFailed200Async(final ServiceCallback<Product> serviceCallback) {
        Call<ResponseBody> call = service.beginDeleteProvisioning202DeletingFailed200(this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Product>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginDeleteProvisioning202DeletingFailed200Delegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Product> beginDeleteProvisioning202DeletingFailed200Delegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(202, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
     *
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> deleteProvisioning202Deletingcanceled200() throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Product> result = this.beginDeleteProvisioning202Deletingcanceled200();
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> deleteProvisioning202Deletingcanceled200Async(final ServiceCallback<Product> serviceCallback) {
        return this.beginDeleteProvisioning202Deletingcanceled200Async(new ServiceCallback<Product>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Product> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
     *
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> beginDeleteProvisioning202Deletingcanceled200() throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginDeleteProvisioning202Deletingcanceled200(this.client.getAcceptLanguage());
            return beginDeleteProvisioning202Deletingcanceled200Delegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginDeleteProvisioning202Deletingcanceled200Async(final ServiceCallback<Product> serviceCallback) {
        Call<ResponseBody> call = service.beginDeleteProvisioning202Deletingcanceled200(this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Product>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginDeleteProvisioning202Deletingcanceled200Delegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Product> beginDeleteProvisioning202Deletingcanceled200Delegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(202, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running delete succeeds and returns right away
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Void> delete204Succeeded() throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Void> result = this.beginDelete204Succeeded();
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running delete succeeds and returns right away
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> delete204SucceededAsync(final ServiceCallback<Void> serviceCallback) {
        return this.beginDelete204SucceededAsync(new ServiceCallback<Void>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Void> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running delete succeeds and returns right away
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Void> beginDelete204Succeeded() throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginDelete204Succeeded(this.client.getAcceptLanguage());
            return beginDelete204SucceededDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running delete succeeds and returns right away
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginDelete204SucceededAsync(final ServiceCallback<Void> serviceCallback) {
        Call<ResponseBody> call = service.beginDelete204Succeeded(this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginDelete204SucceededDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> beginDelete204SucceededDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(204, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> delete202Retry200() throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Product> result = this.beginDelete202Retry200();
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> delete202Retry200Async(final ServiceCallback<Product> serviceCallback) {
        return this.beginDelete202Retry200Async(new ServiceCallback<Product>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Product> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> beginDelete202Retry200() throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginDelete202Retry200(this.client.getAcceptLanguage());
            return beginDelete202Retry200Delegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginDelete202Retry200Async(final ServiceCallback<Product> serviceCallback) {
        Call<ResponseBody> call = service.beginDelete202Retry200(this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Product>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginDelete202Retry200Delegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Product> beginDelete202Retry200Delegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> delete202NoRetry204() throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Product> result = this.beginDelete202NoRetry204();
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> delete202NoRetry204Async(final ServiceCallback<Product> serviceCallback) {
        return this.beginDelete202NoRetry204Async(new ServiceCallback<Product>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Product> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> beginDelete202NoRetry204() throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginDelete202NoRetry204(this.client.getAcceptLanguage());
            return beginDelete202NoRetry204Delegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginDelete202NoRetry204Async(final ServiceCallback<Product> serviceCallback) {
        Call<ResponseBody> call = service.beginDelete202NoRetry204(this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Product>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginDelete202NoRetry204Delegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Product> beginDelete202NoRetry204Delegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running delete request, service returns a location header in the initial request. Subsequent calls to operation status do not contain location header.
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Void> deleteNoHeaderInRetry() throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Void> result = this.beginDeleteNoHeaderInRetry();
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running delete request, service returns a location header in the initial request. Subsequent calls to operation status do not contain location header.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> deleteNoHeaderInRetryAsync(final ServiceCallback<Void> serviceCallback) {
        return this.beginDeleteNoHeaderInRetryAsync(new ServiceCallback<Void>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Void> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running delete request, service returns a location header in the initial request. Subsequent calls to operation status do not contain location header.
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Void> beginDeleteNoHeaderInRetry() throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginDeleteNoHeaderInRetry(this.client.getAcceptLanguage());
            return beginDeleteNoHeaderInRetryDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running delete request, service returns a location header in the initial request. Subsequent calls to operation status do not contain location header.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginDeleteNoHeaderInRetryAsync(final ServiceCallback<Void> serviceCallback) {
        Call<ResponseBody> call = service.beginDeleteNoHeaderInRetry(this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginDeleteNoHeaderInRetryDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> beginDeleteNoHeaderInRetryDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(204, new TypeToken<Void>(){}.getType())
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Void> deleteAsyncNoHeaderInRetry() throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Void> result = this.beginDeleteAsyncNoHeaderInRetry();
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> deleteAsyncNoHeaderInRetryAsync(final ServiceCallback<Void> serviceCallback) {
        return this.beginDeleteAsyncNoHeaderInRetryAsync(new ServiceCallback<Void>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Void> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Void> beginDeleteAsyncNoHeaderInRetry() throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginDeleteAsyncNoHeaderInRetry(this.client.getAcceptLanguage());
            return beginDeleteAsyncNoHeaderInRetryDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginDeleteAsyncNoHeaderInRetryAsync(final ServiceCallback<Void> serviceCallback) {
        Call<ResponseBody> call = service.beginDeleteAsyncNoHeaderInRetry(this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginDeleteAsyncNoHeaderInRetryDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> beginDeleteAsyncNoHeaderInRetryDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(204, new TypeToken<Void>(){}.getType())
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Void> deleteAsyncRetrySucceeded() throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Void> result = this.beginDeleteAsyncRetrySucceeded();
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> deleteAsyncRetrySucceededAsync(final ServiceCallback<Void> serviceCallback) {
        return this.beginDeleteAsyncRetrySucceededAsync(new ServiceCallback<Void>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Void> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Void> beginDeleteAsyncRetrySucceeded() throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginDeleteAsyncRetrySucceeded(this.client.getAcceptLanguage());
            return beginDeleteAsyncRetrySucceededDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginDeleteAsyncRetrySucceededAsync(final ServiceCallback<Void> serviceCallback) {
        Call<ResponseBody> call = service.beginDeleteAsyncRetrySucceeded(this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginDeleteAsyncRetrySucceededDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> beginDeleteAsyncRetrySucceededDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Void> deleteAsyncNoRetrySucceeded() throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Void> result = this.beginDeleteAsyncNoRetrySucceeded();
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> deleteAsyncNoRetrySucceededAsync(final ServiceCallback<Void> serviceCallback) {
        return this.beginDeleteAsyncNoRetrySucceededAsync(new ServiceCallback<Void>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Void> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Void> beginDeleteAsyncNoRetrySucceeded() throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginDeleteAsyncNoRetrySucceeded(this.client.getAcceptLanguage());
            return beginDeleteAsyncNoRetrySucceededDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginDeleteAsyncNoRetrySucceededAsync(final ServiceCallback<Void> serviceCallback) {
        Call<ResponseBody> call = service.beginDeleteAsyncNoRetrySucceeded(this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginDeleteAsyncNoRetrySucceededDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> beginDeleteAsyncNoRetrySucceededDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Void> deleteAsyncRetryFailed() throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Void> result = this.beginDeleteAsyncRetryFailed();
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> deleteAsyncRetryFailedAsync(final ServiceCallback<Void> serviceCallback) {
        return this.beginDeleteAsyncRetryFailedAsync(new ServiceCallback<Void>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Void> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Void> beginDeleteAsyncRetryFailed() throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginDeleteAsyncRetryFailed(this.client.getAcceptLanguage());
            return beginDeleteAsyncRetryFailedDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginDeleteAsyncRetryFailedAsync(final ServiceCallback<Void> serviceCallback) {
        Call<ResponseBody> call = service.beginDeleteAsyncRetryFailed(this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginDeleteAsyncRetryFailedDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> beginDeleteAsyncRetryFailedDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Void> deleteAsyncRetrycanceled() throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Void> result = this.beginDeleteAsyncRetrycanceled();
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> deleteAsyncRetrycanceledAsync(final ServiceCallback<Void> serviceCallback) {
        return this.beginDeleteAsyncRetrycanceledAsync(new ServiceCallback<Void>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Void> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Void> beginDeleteAsyncRetrycanceled() throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginDeleteAsyncRetrycanceled(this.client.getAcceptLanguage());
            return beginDeleteAsyncRetrycanceledDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginDeleteAsyncRetrycanceledAsync(final ServiceCallback<Void> serviceCallback) {
        Call<ResponseBody> call = service.beginDeleteAsyncRetrycanceled(this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginDeleteAsyncRetrycanceledDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> beginDeleteAsyncRetrycanceledDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header. Poll returns a 200 with a response body after success.
     *
     * @return the Sku object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Sku> post200WithPayload() throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Sku> result = this.beginPost200WithPayload();
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header. Poll returns a 200 with a response body after success.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> post200WithPayloadAsync(final ServiceCallback<Sku> serviceCallback) {
        return this.beginPost200WithPayloadAsync(new ServiceCallback<Sku>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Sku> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header. Poll returns a 200 with a response body after success.
     *
     * @return the Sku object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Sku> beginPost200WithPayload() throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPost200WithPayload(this.client.getAcceptLanguage());
            return beginPost200WithPayloadDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header. Poll returns a 200 with a response body after success.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPost200WithPayloadAsync(final ServiceCallback<Sku> serviceCallback) {
        Call<ResponseBody> call = service.beginPost200WithPayload(this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Sku>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPost200WithPayloadDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Sku> beginPost200WithPayloadDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Sku>()
                .register(202, new TypeToken<Sku>(){}.getType())
                .register(200, new TypeToken<Sku>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After' headers, Polls return a 200 with a response body after success
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Void> post202Retry200(Product product) throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Void> result = this.beginPost202Retry200(product);
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After' headers, Polls return a 200 with a response body after success
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> post202Retry200Async(Product product, final ServiceCallback<Void> serviceCallback) {
        return this.beginPost202Retry200Async(product, new ServiceCallback<Void>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Void> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After' headers, Polls return a 200 with a response body after success
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Void> beginPost202Retry200(Product product) throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPost202Retry200(product, this.client.getAcceptLanguage());
            return beginPost202Retry200Delegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After' headers, Polls return a 200 with a response body after success
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPost202Retry200Async(Product product, final ServiceCallback<Void> serviceCallback) {
        Call<ResponseBody> call = service.beginPost202Retry200(product, this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPost202Retry200Delegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> beginPost202Retry200Delegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with noresponse body after success
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> post202NoRetry204(Product product) throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Product> result = this.beginPost202NoRetry204(product);
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with noresponse body after success
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> post202NoRetry204Async(Product product, final ServiceCallback<Product> serviceCallback) {
        return this.beginPost202NoRetry204Async(product, new ServiceCallback<Product>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Product> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with noresponse body after success
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> beginPost202NoRetry204(Product product) throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPost202NoRetry204(product, this.client.getAcceptLanguage());
            return beginPost202NoRetry204Delegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with noresponse body after success
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPost202NoRetry204Async(Product product, final ServiceCallback<Product> serviceCallback) {
        Call<ResponseBody> call = service.beginPost202NoRetry204(product, this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Product>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPost202NoRetry204Delegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Product> beginPost202NoRetry204Delegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(202, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> postAsyncRetrySucceeded(Product product) throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Product> result = this.beginPostAsyncRetrySucceeded(product);
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> postAsyncRetrySucceededAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        return this.beginPostAsyncRetrySucceededAsync(product, new ServiceCallback<Product>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Product> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> beginPostAsyncRetrySucceeded(Product product) throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPostAsyncRetrySucceeded(product, this.client.getAcceptLanguage());
            return beginPostAsyncRetrySucceededDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPostAsyncRetrySucceededAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        Call<ResponseBody> call = service.beginPostAsyncRetrySucceeded(product, this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Product>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPostAsyncRetrySucceededDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Product> beginPostAsyncRetrySucceededDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(202, new TypeToken<Void>(){}.getType())
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> postAsyncNoRetrySucceeded(Product product) throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Product> result = this.beginPostAsyncNoRetrySucceeded(product);
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> postAsyncNoRetrySucceededAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        return this.beginPostAsyncNoRetrySucceededAsync(product, new ServiceCallback<Product>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Product> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Product> beginPostAsyncNoRetrySucceeded(Product product) throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPostAsyncNoRetrySucceeded(product, this.client.getAcceptLanguage());
            return beginPostAsyncNoRetrySucceededDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPostAsyncNoRetrySucceededAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        Call<ResponseBody> call = service.beginPostAsyncNoRetrySucceeded(product, this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Product>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPostAsyncNoRetrySucceededDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Product> beginPostAsyncNoRetrySucceededDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(202, new TypeToken<Void>(){}.getType())
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Void> postAsyncRetryFailed(Product product) throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Void> result = this.beginPostAsyncRetryFailed(product);
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> postAsyncRetryFailedAsync(Product product, final ServiceCallback<Void> serviceCallback) {
        return this.beginPostAsyncRetryFailedAsync(product, new ServiceCallback<Void>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Void> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Void> beginPostAsyncRetryFailed(Product product) throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPostAsyncRetryFailed(product, this.client.getAcceptLanguage());
            return beginPostAsyncRetryFailedDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPostAsyncRetryFailedAsync(Product product, final ServiceCallback<Void> serviceCallback) {
        Call<ResponseBody> call = service.beginPostAsyncRetryFailed(product, this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPostAsyncRetryFailedDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> beginPostAsyncRetryFailedDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Void> postAsyncRetrycanceled(Product product) throws ServiceException, IOException, InterruptedException {
        ServiceResponse<Void> result = this.beginPostAsyncRetrycanceled(product);
        return client.getAzureClient().getPutOrPatchResult(result);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> postAsyncRetrycanceledAsync(Product product, final ServiceCallback<Void> serviceCallback) {
        return this.beginPostAsyncRetrycanceledAsync(product, new ServiceCallback<Void>() {
            @Override
            public void failure(Throwable t) { serviceCallback.failure(t); }
            @Override
            public void success(ServiceResponse<Void> result) {
                client.getAzureClient().getPutOrPatchResultAsync(result, serviceCallback);
            }
        });
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public ServiceResponse<Void> beginPostAsyncRetrycanceled(Product product) throws ServiceException {
        try {
            Call<ResponseBody> call = service.beginPostAsyncRetrycanceled(product, this.client.getAcceptLanguage());
            return beginPostAsyncRetrycanceledDelegate(call.execute(), null);
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> beginPostAsyncRetrycanceledAsync(Product product, final ServiceCallback<Void> serviceCallback) {
        Call<ResponseBody> call = service.beginPostAsyncRetrycanceled(product, this.client.getAcceptLanguage());
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(beginPostAsyncRetrycanceledDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> beginPostAsyncRetrycanceledDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, retrofit);
    }

}
