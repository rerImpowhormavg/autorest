/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 * 
 * Code generated by Microsoft (R) AutoRest Code Generator 0.11.0.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package fixtures.lro;

import com.google.gson.reflect.TypeToken;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceException;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseBuilder;
import com.microsoft.rest.ServiceResponseCallback;
import retrofit.RestAdapter;
import retrofit.RetrofitError;
import retrofit.client.Response;
import fixtures.lro.models.Product;
import fixtures.lro.models.Sku;
import fixtures.lro.models.SubProduct;
import fixtures.lro.models.CloudError;

public class LROsImpl implements LROs {
    private LROsService service;
    AutoRestLongRunningOperationTestService client;

    public LROsImpl(RestAdapter restAdapter, AutoRestLongRunningOperationTestService client) {
        this.service = restAdapter.create(LROsService.class);
        this.client = client;
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Succeeded’.
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product put200Succeeded(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = put200SucceededDelegate(service.put200Succeeded(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = put200SucceededDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Succeeded’.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void put200SucceededAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.put200SucceededAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(put200SucceededDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> put200SucceededDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(204, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Succeeded’.
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPut200Succeeded(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPut200SucceededDelegate(service.beginPut200Succeeded(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPut200SucceededDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Succeeded’.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPut200SucceededAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPut200SucceededAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPut200SucceededDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPut200SucceededDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(204, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that does not contain ProvisioningState=’Succeeded’.
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product put200SucceededNoState(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = put200SucceededNoStateDelegate(service.put200SucceededNoState(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = put200SucceededNoStateDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that does not contain ProvisioningState=’Succeeded’.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void put200SucceededNoStateAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.put200SucceededNoStateAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(put200SucceededNoStateDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> put200SucceededNoStateDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that does not contain ProvisioningState=’Succeeded’.
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPut200SucceededNoState(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPut200SucceededNoStateDelegate(service.beginPut200SucceededNoState(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPut200SucceededNoStateDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that does not contain ProvisioningState=’Succeeded’.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPut200SucceededNoStateAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPut200SucceededNoStateAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPut200SucceededNoStateDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPut200SucceededNoStateDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 202 to the initial request, with a location header that points to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product put202Retry200(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = put202Retry200Delegate(service.put202Retry200(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = put202Retry200Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 202 to the initial request, with a location header that points to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void put202Retry200Async(Product product, final ServiceCallback<Product> serviceCallback) {
        service.put202Retry200Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(put202Retry200Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> put202Retry200Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(202, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 202 to the initial request, with a location header that points to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPut202Retry200(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPut202Retry200Delegate(service.beginPut202Retry200(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPut202Retry200Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 202 to the initial request, with a location header that points to a polling URL that returns a 200 and an entity that doesn't contains ProvisioningState
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPut202Retry200Async(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPut202Retry200Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPut202Retry200Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPut202Retry200Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(202, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product put201CreatingSucceeded200(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = put201CreatingSucceeded200Delegate(service.put201CreatingSucceeded200(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = put201CreatingSucceeded200Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void put201CreatingSucceeded200Async(Product product, final ServiceCallback<Product> serviceCallback) {
        service.put201CreatingSucceeded200Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(put201CreatingSucceeded200Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> put201CreatingSucceeded200Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(201, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPut201CreatingSucceeded200(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPut201CreatingSucceeded200Delegate(service.beginPut201CreatingSucceeded200(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPut201CreatingSucceeded200Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPut201CreatingSucceeded200Async(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPut201CreatingSucceeded200Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPut201CreatingSucceeded200Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPut201CreatingSucceeded200Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(201, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Updating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product put200UpdatingSucceeded204(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = put200UpdatingSucceeded204Delegate(service.put200UpdatingSucceeded204(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = put200UpdatingSucceeded204Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Updating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void put200UpdatingSucceeded204Async(Product product, final ServiceCallback<Product> serviceCallback) {
        service.put200UpdatingSucceeded204Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(put200UpdatingSucceeded204Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> put200UpdatingSucceeded204Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Updating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPut200UpdatingSucceeded204(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPut200UpdatingSucceeded204Delegate(service.beginPut200UpdatingSucceeded204(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPut200UpdatingSucceeded204Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Updating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPut200UpdatingSucceeded204Async(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPut200UpdatingSucceeded204Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPut200UpdatingSucceeded204Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPut200UpdatingSucceeded204Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Created’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product put201CreatingFailed200(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = put201CreatingFailed200Delegate(service.put201CreatingFailed200(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = put201CreatingFailed200Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Created’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void put201CreatingFailed200Async(Product product, final ServiceCallback<Product> serviceCallback) {
        service.put201CreatingFailed200Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(put201CreatingFailed200Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> put201CreatingFailed200Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(201, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Created’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPut201CreatingFailed200(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPut201CreatingFailed200Delegate(service.beginPut201CreatingFailed200(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPut201CreatingFailed200Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Created’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPut201CreatingFailed200Async(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPut201CreatingFailed200Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPut201CreatingFailed200Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPut201CreatingFailed200Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(201, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product put200Acceptedcanceled200(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = put200Acceptedcanceled200Delegate(service.put200Acceptedcanceled200(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = put200Acceptedcanceled200Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void put200Acceptedcanceled200Async(Product product, final ServiceCallback<Product> serviceCallback) {
        service.put200Acceptedcanceled200Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(put200Acceptedcanceled200Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> put200Acceptedcanceled200Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPut200Acceptedcanceled200(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPut200Acceptedcanceled200Delegate(service.beginPut200Acceptedcanceled200(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPut200Acceptedcanceled200Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 201 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPut200Acceptedcanceled200Async(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPut200Acceptedcanceled200Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPut200Acceptedcanceled200Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPut200Acceptedcanceled200Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to operation status do not contain location header.
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product putNoHeaderInRetry(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = putNoHeaderInRetryDelegate(service.putNoHeaderInRetry(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = putNoHeaderInRetryDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to operation status do not contain location header.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putNoHeaderInRetryAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.putNoHeaderInRetryAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putNoHeaderInRetryDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> putNoHeaderInRetryDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(202, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to operation status do not contain location header.
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPutNoHeaderInRetry(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPutNoHeaderInRetryDelegate(service.beginPutNoHeaderInRetry(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPutNoHeaderInRetryDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 202 to the initial request with location header. Subsequent calls to operation status do not contain location header.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPutNoHeaderInRetryAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPutNoHeaderInRetryAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPutNoHeaderInRetryDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPutNoHeaderInRetryDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(202, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product putAsyncRetrySucceeded(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = putAsyncRetrySucceededDelegate(service.putAsyncRetrySucceeded(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = putAsyncRetrySucceededDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putAsyncRetrySucceededAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.putAsyncRetrySucceededAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putAsyncRetrySucceededDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> putAsyncRetrySucceededDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPutAsyncRetrySucceeded(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPutAsyncRetrySucceededDelegate(service.beginPutAsyncRetrySucceeded(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPutAsyncRetrySucceededDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPutAsyncRetrySucceededAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPutAsyncRetrySucceededAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPutAsyncRetrySucceededDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPutAsyncRetrySucceededDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product putAsyncNoRetrySucceeded(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = putAsyncNoRetrySucceededDelegate(service.putAsyncNoRetrySucceeded(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = putAsyncNoRetrySucceededDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putAsyncNoRetrySucceededAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.putAsyncNoRetrySucceededAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putAsyncNoRetrySucceededDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> putAsyncNoRetrySucceededDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPutAsyncNoRetrySucceeded(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPutAsyncNoRetrySucceededDelegate(service.beginPutAsyncNoRetrySucceeded(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPutAsyncNoRetrySucceededDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPutAsyncNoRetrySucceededAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPutAsyncNoRetrySucceededAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPutAsyncNoRetrySucceededDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPutAsyncNoRetrySucceededDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product putAsyncRetryFailed(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = putAsyncRetryFailedDelegate(service.putAsyncRetryFailed(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = putAsyncRetryFailedDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putAsyncRetryFailedAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.putAsyncRetryFailedAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putAsyncRetryFailedDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> putAsyncRetryFailedDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPutAsyncRetryFailed(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPutAsyncRetryFailedDelegate(service.beginPutAsyncRetryFailed(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPutAsyncRetryFailedDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPutAsyncRetryFailedAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPutAsyncRetryFailedAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPutAsyncRetryFailedDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPutAsyncRetryFailedDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product putAsyncNoRetrycanceled(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = putAsyncNoRetrycanceledDelegate(service.putAsyncNoRetrycanceled(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = putAsyncNoRetrycanceledDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putAsyncNoRetrycanceledAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.putAsyncNoRetrycanceledAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putAsyncNoRetrycanceledDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> putAsyncNoRetrycanceledDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPutAsyncNoRetrycanceled(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPutAsyncNoRetrycanceledDelegate(service.beginPutAsyncNoRetrycanceled(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPutAsyncNoRetrycanceledDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 200 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPutAsyncNoRetrycanceledAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPutAsyncNoRetrycanceledAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPutAsyncNoRetrycanceledDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPutAsyncNoRetrycanceledDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product putAsyncNoHeaderInRetry(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = putAsyncNoHeaderInRetryDelegate(service.putAsyncNoHeaderInRetry(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = putAsyncNoHeaderInRetryDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putAsyncNoHeaderInRetryAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.putAsyncNoHeaderInRetryAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putAsyncNoHeaderInRetryDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> putAsyncNoHeaderInRetryDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(201, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPutAsyncNoHeaderInRetry(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPutAsyncNoHeaderInRetryDelegate(service.beginPutAsyncNoHeaderInRetry(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPutAsyncNoHeaderInRetryDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request, service returns a 202 to the initial request with Azure-AsyncOperation header. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPutAsyncNoHeaderInRetryAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPutAsyncNoHeaderInRetryAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPutAsyncNoHeaderInRetryDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPutAsyncNoHeaderInRetryDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(201, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request with non resource.
     *
     * @param sku sku to put
     * @return the Sku object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Sku putNonResource(Sku sku) throws ServiceException {
        try {
            ServiceResponse<Sku> response = putNonResourceDelegate(service.putNonResource(sku, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Sku> response = putNonResourceDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request with non resource.
     *
     * @param sku sku to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putNonResourceAsync(Sku sku, final ServiceCallback<Sku> serviceCallback) {
        service.putNonResourceAsync(sku, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putNonResourceDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Sku> putNonResourceDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Sku>()
                .register(202, new TypeToken<Sku>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request with non resource.
     *
     * @param sku sku to put
     * @return the Sku object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Sku beginPutNonResource(Sku sku) throws ServiceException {
        try {
            ServiceResponse<Sku> response = beginPutNonResourceDelegate(service.beginPutNonResource(sku, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Sku> response = beginPutNonResourceDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request with non resource.
     *
     * @param sku sku to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPutNonResourceAsync(Sku sku, final ServiceCallback<Sku> serviceCallback) {
        service.beginPutNonResourceAsync(sku, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPutNonResourceDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Sku> beginPutNonResourceDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Sku>()
                .register(202, new TypeToken<Sku>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request with non resource.
     *
     * @param sku Sku to put
     * @return the Sku object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Sku putAsyncNonResource(Sku sku) throws ServiceException {
        try {
            ServiceResponse<Sku> response = putAsyncNonResourceDelegate(service.putAsyncNonResource(sku, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Sku> response = putAsyncNonResourceDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request with non resource.
     *
     * @param sku Sku to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putAsyncNonResourceAsync(Sku sku, final ServiceCallback<Sku> serviceCallback) {
        service.putAsyncNonResourceAsync(sku, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putAsyncNonResourceDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Sku> putAsyncNonResourceDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Sku>()
                .register(202, new TypeToken<Sku>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request with non resource.
     *
     * @param sku Sku to put
     * @return the Sku object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Sku beginPutAsyncNonResource(Sku sku) throws ServiceException {
        try {
            ServiceResponse<Sku> response = beginPutAsyncNonResourceDelegate(service.beginPutAsyncNonResource(sku, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Sku> response = beginPutAsyncNonResourceDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request with non resource.
     *
     * @param sku Sku to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPutAsyncNonResourceAsync(Sku sku, final ServiceCallback<Sku> serviceCallback) {
        service.beginPutAsyncNonResourceAsync(sku, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPutAsyncNonResourceDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Sku> beginPutAsyncNonResourceDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Sku>()
                .register(202, new TypeToken<Sku>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request with sub resource.
     *
     * @param product Sub Product to put
     * @return the SubProduct object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public SubProduct putSubResource(SubProduct product) throws ServiceException {
        try {
            ServiceResponse<SubProduct> response = putSubResourceDelegate(service.putSubResource(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<SubProduct> response = putSubResourceDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request with sub resource.
     *
     * @param product Sub Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putSubResourceAsync(SubProduct product, final ServiceCallback<SubProduct> serviceCallback) {
        service.putSubResourceAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putSubResourceDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<SubProduct> putSubResourceDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<SubProduct>()
                .register(202, new TypeToken<SubProduct>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request with sub resource.
     *
     * @param product Sub Product to put
     * @return the SubProduct object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public SubProduct beginPutSubResource(SubProduct product) throws ServiceException {
        try {
            ServiceResponse<SubProduct> response = beginPutSubResourceDelegate(service.beginPutSubResource(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<SubProduct> response = beginPutSubResourceDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request with sub resource.
     *
     * @param product Sub Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPutSubResourceAsync(SubProduct product, final ServiceCallback<SubProduct> serviceCallback) {
        service.beginPutSubResourceAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPutSubResourceDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<SubProduct> beginPutSubResourceDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<SubProduct>()
                .register(202, new TypeToken<SubProduct>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request with sub resource.
     *
     * @param product Sub Product to put
     * @return the SubProduct object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public SubProduct putAsyncSubResource(SubProduct product) throws ServiceException {
        try {
            ServiceResponse<SubProduct> response = putAsyncSubResourceDelegate(service.putAsyncSubResource(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<SubProduct> response = putAsyncSubResourceDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request with sub resource.
     *
     * @param product Sub Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putAsyncSubResourceAsync(SubProduct product, final ServiceCallback<SubProduct> serviceCallback) {
        service.putAsyncSubResourceAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putAsyncSubResourceDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<SubProduct> putAsyncSubResourceDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<SubProduct>()
                .register(202, new TypeToken<SubProduct>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running put request with sub resource.
     *
     * @param product Sub Product to put
     * @return the SubProduct object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public SubProduct beginPutAsyncSubResource(SubProduct product) throws ServiceException {
        try {
            ServiceResponse<SubProduct> response = beginPutAsyncSubResourceDelegate(service.beginPutAsyncSubResource(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<SubProduct> response = beginPutAsyncSubResourceDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running put request with sub resource.
     *
     * @param product Sub Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPutAsyncSubResourceAsync(SubProduct product, final ServiceCallback<SubProduct> serviceCallback) {
        service.beginPutAsyncSubResourceAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPutAsyncSubResourceDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<SubProduct> beginPutAsyncSubResourceDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<SubProduct>()
                .register(202, new TypeToken<SubProduct>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Accepted’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product deleteProvisioning202Accepted200Succeeded() throws ServiceException {
        try {
            ServiceResponse<Product> response = deleteProvisioning202Accepted200SucceededDelegate(service.deleteProvisioning202Accepted200Succeeded(this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = deleteProvisioning202Accepted200SucceededDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Accepted’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void deleteProvisioning202Accepted200SucceededAsync(final ServiceCallback<Product> serviceCallback) {
        service.deleteProvisioning202Accepted200SucceededAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(deleteProvisioning202Accepted200SucceededDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> deleteProvisioning202Accepted200SucceededDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(202, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Accepted’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginDeleteProvisioning202Accepted200Succeeded() throws ServiceException {
        try {
            ServiceResponse<Product> response = beginDeleteProvisioning202Accepted200SucceededDelegate(service.beginDeleteProvisioning202Accepted200Succeeded(this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginDeleteProvisioning202Accepted200SucceededDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Accepted’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginDeleteProvisioning202Accepted200SucceededAsync(final ServiceCallback<Product> serviceCallback) {
        service.beginDeleteProvisioning202Accepted200SucceededAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginDeleteProvisioning202Accepted200SucceededDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginDeleteProvisioning202Accepted200SucceededDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(202, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
     *
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product deleteProvisioning202DeletingFailed200() throws ServiceException {
        try {
            ServiceResponse<Product> response = deleteProvisioning202DeletingFailed200Delegate(service.deleteProvisioning202DeletingFailed200(this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = deleteProvisioning202DeletingFailed200Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void deleteProvisioning202DeletingFailed200Async(final ServiceCallback<Product> serviceCallback) {
        service.deleteProvisioning202DeletingFailed200Async(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(deleteProvisioning202DeletingFailed200Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> deleteProvisioning202DeletingFailed200Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(202, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
     *
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginDeleteProvisioning202DeletingFailed200() throws ServiceException {
        try {
            ServiceResponse<Product> response = beginDeleteProvisioning202DeletingFailed200Delegate(service.beginDeleteProvisioning202DeletingFailed200(this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginDeleteProvisioning202DeletingFailed200Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Failed’
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginDeleteProvisioning202DeletingFailed200Async(final ServiceCallback<Product> serviceCallback) {
        service.beginDeleteProvisioning202DeletingFailed200Async(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginDeleteProvisioning202DeletingFailed200Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginDeleteProvisioning202DeletingFailed200Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(202, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
     *
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product deleteProvisioning202Deletingcanceled200() throws ServiceException {
        try {
            ServiceResponse<Product> response = deleteProvisioning202Deletingcanceled200Delegate(service.deleteProvisioning202Deletingcanceled200(this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = deleteProvisioning202Deletingcanceled200Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void deleteProvisioning202Deletingcanceled200Async(final ServiceCallback<Product> serviceCallback) {
        service.deleteProvisioning202Deletingcanceled200Async(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(deleteProvisioning202Deletingcanceled200Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> deleteProvisioning202Deletingcanceled200Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(202, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
     *
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginDeleteProvisioning202Deletingcanceled200() throws ServiceException {
        try {
            ServiceResponse<Product> response = beginDeleteProvisioning202Deletingcanceled200Delegate(service.beginDeleteProvisioning202Deletingcanceled200(this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginDeleteProvisioning202Deletingcanceled200Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’.  Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Canceled’
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginDeleteProvisioning202Deletingcanceled200Async(final ServiceCallback<Product> serviceCallback) {
        service.beginDeleteProvisioning202Deletingcanceled200Async(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginDeleteProvisioning202Deletingcanceled200Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginDeleteProvisioning202Deletingcanceled200Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(202, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete succeeds and returns right away
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void delete204Succeeded() throws ServiceException {
        try {
            ServiceResponse<Void> response = delete204SucceededDelegate(service.delete204Succeeded(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = delete204SucceededDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete succeeds and returns right away
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void delete204SucceededAsync(final ServiceCallback<Void> serviceCallback) {
        service.delete204SucceededAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(delete204SucceededDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> delete204SucceededDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(204, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete succeeds and returns right away
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginDelete204Succeeded() throws ServiceException {
        try {
            ServiceResponse<Void> response = beginDelete204SucceededDelegate(service.beginDelete204Succeeded(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginDelete204SucceededDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete succeeds and returns right away
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginDelete204SucceededAsync(final ServiceCallback<Void> serviceCallback) {
        service.beginDelete204SucceededAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginDelete204SucceededDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginDelete204SucceededDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(204, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product delete202Retry200() throws ServiceException {
        try {
            ServiceResponse<Product> response = delete202Retry200Delegate(service.delete202Retry200(this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = delete202Retry200Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void delete202Retry200Async(final ServiceCallback<Product> serviceCallback) {
        service.delete202Retry200Async(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(delete202Retry200Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> delete202Retry200Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginDelete202Retry200() throws ServiceException {
        try {
            ServiceResponse<Product> response = beginDelete202Retry200Delegate(service.beginDelete202Retry200(this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginDelete202Retry200Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginDelete202Retry200Async(final ServiceCallback<Product> serviceCallback) {
        service.beginDelete202Retry200Async(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginDelete202Retry200Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginDelete202Retry200Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product delete202NoRetry204() throws ServiceException {
        try {
            ServiceResponse<Product> response = delete202NoRetry204Delegate(service.delete202NoRetry204(this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = delete202NoRetry204Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void delete202NoRetry204Async(final ServiceCallback<Product> serviceCallback) {
        service.delete202NoRetry204Async(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(delete202NoRetry204Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> delete202NoRetry204Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginDelete202NoRetry204() throws ServiceException {
        try {
            ServiceResponse<Product> response = beginDelete202NoRetry204Delegate(service.beginDelete202NoRetry204(this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginDelete202NoRetry204Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Polls return this value until the last poll returns a ‘200’ with ProvisioningState=’Succeeded’
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginDelete202NoRetry204Async(final ServiceCallback<Product> serviceCallback) {
        service.beginDelete202NoRetry204Async(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginDelete202NoRetry204Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginDelete202NoRetry204Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(200, new TypeToken<Product>(){}.getType())
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a location header in the initial request. Subsequent calls to operation status do not contain location header.
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void deleteNoHeaderInRetry() throws ServiceException {
        try {
            ServiceResponse<Void> response = deleteNoHeaderInRetryDelegate(service.deleteNoHeaderInRetry(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = deleteNoHeaderInRetryDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a location header in the initial request. Subsequent calls to operation status do not contain location header.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void deleteNoHeaderInRetryAsync(final ServiceCallback<Void> serviceCallback) {
        service.deleteNoHeaderInRetryAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(deleteNoHeaderInRetryDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> deleteNoHeaderInRetryDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(204, new TypeToken<Void>(){}.getType())
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a location header in the initial request. Subsequent calls to operation status do not contain location header.
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginDeleteNoHeaderInRetry() throws ServiceException {
        try {
            ServiceResponse<Void> response = beginDeleteNoHeaderInRetryDelegate(service.beginDeleteNoHeaderInRetry(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginDeleteNoHeaderInRetryDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a location header in the initial request. Subsequent calls to operation status do not contain location header.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginDeleteNoHeaderInRetryAsync(final ServiceCallback<Void> serviceCallback) {
        service.beginDeleteNoHeaderInRetryAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginDeleteNoHeaderInRetryDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginDeleteNoHeaderInRetryDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(204, new TypeToken<Void>(){}.getType())
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void deleteAsyncNoHeaderInRetry() throws ServiceException {
        try {
            ServiceResponse<Void> response = deleteAsyncNoHeaderInRetryDelegate(service.deleteAsyncNoHeaderInRetry(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = deleteAsyncNoHeaderInRetryDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void deleteAsyncNoHeaderInRetryAsync(final ServiceCallback<Void> serviceCallback) {
        service.deleteAsyncNoHeaderInRetryAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(deleteAsyncNoHeaderInRetryDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> deleteAsyncNoHeaderInRetryDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(204, new TypeToken<Void>(){}.getType())
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginDeleteAsyncNoHeaderInRetry() throws ServiceException {
        try {
            ServiceResponse<Void> response = beginDeleteAsyncNoHeaderInRetryDelegate(service.beginDeleteAsyncNoHeaderInRetry(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginDeleteAsyncNoHeaderInRetryDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns an Azure-AsyncOperation header in the initial request. Subsequent calls to operation status do not contain Azure-AsyncOperation header.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginDeleteAsyncNoHeaderInRetryAsync(final ServiceCallback<Void> serviceCallback) {
        service.beginDeleteAsyncNoHeaderInRetryAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginDeleteAsyncNoHeaderInRetryDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginDeleteAsyncNoHeaderInRetryDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(204, new TypeToken<Void>(){}.getType())
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void deleteAsyncRetrySucceeded() throws ServiceException {
        try {
            ServiceResponse<Void> response = deleteAsyncRetrySucceededDelegate(service.deleteAsyncRetrySucceeded(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = deleteAsyncRetrySucceededDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void deleteAsyncRetrySucceededAsync(final ServiceCallback<Void> serviceCallback) {
        service.deleteAsyncRetrySucceededAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(deleteAsyncRetrySucceededDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> deleteAsyncRetrySucceededDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginDeleteAsyncRetrySucceeded() throws ServiceException {
        try {
            ServiceResponse<Void> response = beginDeleteAsyncRetrySucceededDelegate(service.beginDeleteAsyncRetrySucceeded(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginDeleteAsyncRetrySucceededDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginDeleteAsyncRetrySucceededAsync(final ServiceCallback<Void> serviceCallback) {
        service.beginDeleteAsyncRetrySucceededAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginDeleteAsyncRetrySucceededDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginDeleteAsyncRetrySucceededDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void deleteAsyncNoRetrySucceeded() throws ServiceException {
        try {
            ServiceResponse<Void> response = deleteAsyncNoRetrySucceededDelegate(service.deleteAsyncNoRetrySucceeded(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = deleteAsyncNoRetrySucceededDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void deleteAsyncNoRetrySucceededAsync(final ServiceCallback<Void> serviceCallback) {
        service.deleteAsyncNoRetrySucceededAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(deleteAsyncNoRetrySucceededDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> deleteAsyncNoRetrySucceededDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginDeleteAsyncNoRetrySucceeded() throws ServiceException {
        try {
            ServiceResponse<Void> response = beginDeleteAsyncNoRetrySucceededDelegate(service.beginDeleteAsyncNoRetrySucceeded(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginDeleteAsyncNoRetrySucceededDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginDeleteAsyncNoRetrySucceededAsync(final ServiceCallback<Void> serviceCallback) {
        service.beginDeleteAsyncNoRetrySucceededAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginDeleteAsyncNoRetrySucceededDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginDeleteAsyncNoRetrySucceededDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void deleteAsyncRetryFailed() throws ServiceException {
        try {
            ServiceResponse<Void> response = deleteAsyncRetryFailedDelegate(service.deleteAsyncRetryFailed(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = deleteAsyncRetryFailedDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void deleteAsyncRetryFailedAsync(final ServiceCallback<Void> serviceCallback) {
        service.deleteAsyncRetryFailedAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(deleteAsyncRetryFailedDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> deleteAsyncRetryFailedDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginDeleteAsyncRetryFailed() throws ServiceException {
        try {
            ServiceResponse<Void> response = beginDeleteAsyncRetryFailedDelegate(service.beginDeleteAsyncRetryFailed(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginDeleteAsyncRetryFailedDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginDeleteAsyncRetryFailedAsync(final ServiceCallback<Void> serviceCallback) {
        service.beginDeleteAsyncRetryFailedAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginDeleteAsyncRetryFailedDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginDeleteAsyncRetryFailedDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void deleteAsyncRetrycanceled() throws ServiceException {
        try {
            ServiceResponse<Void> response = deleteAsyncRetrycanceledDelegate(service.deleteAsyncRetrycanceled(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = deleteAsyncRetrycanceledDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void deleteAsyncRetrycanceledAsync(final ServiceCallback<Void> serviceCallback) {
        service.deleteAsyncRetrycanceledAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(deleteAsyncRetrycanceledDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> deleteAsyncRetrycanceledDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginDeleteAsyncRetrycanceled() throws ServiceException {
        try {
            ServiceResponse<Void> response = beginDeleteAsyncRetrycanceledDelegate(service.beginDeleteAsyncRetrycanceled(this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginDeleteAsyncRetrycanceledDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running delete request, service returns a 202 to the initial request. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginDeleteAsyncRetrycanceledAsync(final ServiceCallback<Void> serviceCallback) {
        service.beginDeleteAsyncRetrycanceledAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginDeleteAsyncRetrycanceledDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginDeleteAsyncRetrycanceledDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header. Poll returns a 200 with a response body after success.
     *
     * @return the Sku object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Sku post200WithPayload() throws ServiceException {
        try {
            ServiceResponse<Sku> response = post200WithPayloadDelegate(service.post200WithPayload(this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Sku> response = post200WithPayloadDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header. Poll returns a 200 with a response body after success.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void post200WithPayloadAsync(final ServiceCallback<Sku> serviceCallback) {
        service.post200WithPayloadAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(post200WithPayloadDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Sku> post200WithPayloadDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Sku>()
                .register(202, new TypeToken<Sku>(){}.getType())
                .register(200, new TypeToken<Sku>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header. Poll returns a 200 with a response body after success.
     *
     * @return the Sku object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Sku beginPost200WithPayload() throws ServiceException {
        try {
            ServiceResponse<Sku> response = beginPost200WithPayloadDelegate(service.beginPost200WithPayload(this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Sku> response = beginPost200WithPayloadDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header. Poll returns a 200 with a response body after success.
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPost200WithPayloadAsync(final ServiceCallback<Sku> serviceCallback) {
        service.beginPost200WithPayloadAsync(this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPost200WithPayloadDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Sku> beginPost200WithPayloadDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Sku>()
                .register(202, new TypeToken<Sku>(){}.getType())
                .register(200, new TypeToken<Sku>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After' headers, Polls return a 200 with a response body after success
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void post202Retry200(Product product) throws ServiceException {
        try {
            ServiceResponse<Void> response = post202Retry200Delegate(service.post202Retry200(product, this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = post202Retry200Delegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After' headers, Polls return a 200 with a response body after success
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void post202Retry200Async(Product product, final ServiceCallback<Void> serviceCallback) {
        service.post202Retry200Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(post202Retry200Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> post202Retry200Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After' headers, Polls return a 200 with a response body after success
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginPost202Retry200(Product product) throws ServiceException {
        try {
            ServiceResponse<Void> response = beginPost202Retry200Delegate(service.beginPost202Retry200(product, this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginPost202Retry200Delegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' and 'Retry-After' headers, Polls return a 200 with a response body after success
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPost202Retry200Async(Product product, final ServiceCallback<Void> serviceCallback) {
        service.beginPost202Retry200Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPost202Retry200Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginPost202Retry200Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with noresponse body after success
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product post202NoRetry204(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = post202NoRetry204Delegate(service.post202NoRetry204(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = post202NoRetry204Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with noresponse body after success
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void post202NoRetry204Async(Product product, final ServiceCallback<Product> serviceCallback) {
        service.post202NoRetry204Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(post202NoRetry204Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> post202NoRetry204Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(202, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with noresponse body after success
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPost202NoRetry204(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPost202NoRetry204Delegate(service.beginPost202NoRetry204(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPost202NoRetry204Delegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with 'Location' header, 204 with noresponse body after success
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPost202NoRetry204Async(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPost202NoRetry204Async(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPost202NoRetry204Delegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPost202NoRetry204Delegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(202, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product postAsyncRetrySucceeded(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = postAsyncRetrySucceededDelegate(service.postAsyncRetrySucceeded(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = postAsyncRetrySucceededDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void postAsyncRetrySucceededAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.postAsyncRetrySucceededAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(postAsyncRetrySucceededDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> postAsyncRetrySucceededDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(202, new TypeToken<Void>(){}.getType())
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPostAsyncRetrySucceeded(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPostAsyncRetrySucceededDelegate(service.beginPostAsyncRetrySucceeded(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPostAsyncRetrySucceededDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPostAsyncRetrySucceededAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPostAsyncRetrySucceededAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPostAsyncRetrySucceededDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPostAsyncRetrySucceededDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(202, new TypeToken<Void>(){}.getType())
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product postAsyncNoRetrySucceeded(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = postAsyncNoRetrySucceededDelegate(service.postAsyncNoRetrySucceeded(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = postAsyncNoRetrySucceededDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void postAsyncNoRetrySucceededAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.postAsyncNoRetrySucceededAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(postAsyncNoRetrySucceededDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> postAsyncNoRetrySucceededDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(202, new TypeToken<Void>(){}.getType())
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @return the Product object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Product beginPostAsyncNoRetrySucceeded(Product product) throws ServiceException {
        try {
            ServiceResponse<Product> response = beginPostAsyncNoRetrySucceededDelegate(service.beginPostAsyncNoRetrySucceeded(product, this.client.getAcceptLanguage()), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Product> response = beginPostAsyncNoRetrySucceededDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPostAsyncNoRetrySucceededAsync(Product product, final ServiceCallback<Product> serviceCallback) {
        service.beginPostAsyncNoRetrySucceededAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPostAsyncNoRetrySucceededDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Product> beginPostAsyncNoRetrySucceededDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Product>()
                .register(202, new TypeToken<Void>(){}.getType())
                .register(200, new TypeToken<Product>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void postAsyncRetryFailed(Product product) throws ServiceException {
        try {
            ServiceResponse<Void> response = postAsyncRetryFailedDelegate(service.postAsyncRetryFailed(product, this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = postAsyncRetryFailedDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void postAsyncRetryFailedAsync(Product product, final ServiceCallback<Void> serviceCallback) {
        service.postAsyncRetryFailedAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(postAsyncRetryFailedDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> postAsyncRetryFailedDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginPostAsyncRetryFailed(Product product) throws ServiceException {
        try {
            ServiceResponse<Void> response = beginPostAsyncRetryFailedDelegate(service.beginPostAsyncRetryFailed(product, this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginPostAsyncRetryFailedDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPostAsyncRetryFailedAsync(Product product, final ServiceCallback<Void> serviceCallback) {
        service.beginPostAsyncRetryFailedAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPostAsyncRetryFailedDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginPostAsyncRetryFailedDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void postAsyncRetrycanceled(Product product) throws ServiceException {
        try {
            ServiceResponse<Void> response = postAsyncRetrycanceledDelegate(service.postAsyncRetrycanceled(product, this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = postAsyncRetrycanceledDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void postAsyncRetrycanceledAsync(Product product, final ServiceCallback<Void> serviceCallback) {
        service.postAsyncRetrycanceledAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(postAsyncRetrycanceledDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> postAsyncRetrycanceledDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void beginPostAsyncRetrycanceled(Product product) throws ServiceException {
        try {
            ServiceResponse<Void> response = beginPostAsyncRetrycanceledDelegate(service.beginPostAsyncRetrycanceled(product, this.client.getAcceptLanguage()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = beginPostAsyncRetrycanceledDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Long running post request, service returns a 202 to the initial request, with an entity that contains ProvisioningState=’Creating’. Poll the endpoint indicated in the Azure-AsyncOperation header for operation status
     *
     * @param product Product to put
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void beginPostAsyncRetrycanceledAsync(Product product, final ServiceCallback<Void> serviceCallback) {
        service.beginPostAsyncRetrycanceledAsync(product, this.client.getAcceptLanguage(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(beginPostAsyncRetrycanceledDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> beginPostAsyncRetrycanceledDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(202, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<CloudError>(){}.getType())
                .build(response, error);
    }

}
