/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 * 
 * Code generated by Microsoft (R) AutoRest Code Generator 0.11.0.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package fixtures.bodydictionary;

import com.google.gson.reflect.TypeToken;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceException;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseBuilder;
import com.microsoft.rest.ServiceResponseCallback;
import retrofit.RestAdapter;
import retrofit.RetrofitError;
import retrofit.client.Response;
import java.util.Map;
import fixtures.bodydictionary.models.Error;
import org.joda.time.LocalDate;
import org.joda.time.DateTime;
import fixtures.bodydictionary.models.Widget;
import java.util.List;
import com.microsoft.rest.Validator;

public class DictionaryImpl implements Dictionary {
    private DictionaryService service;
    AutoRestSwaggerBATdictionaryService client;

    public DictionaryImpl(RestAdapter restAdapter, AutoRestSwaggerBATdictionaryService client) {
        this.service = restAdapter.create(DictionaryService.class);
        this.client = client;
    }

    /**
     * Get null dictionary value
     *
     * @return the Map&lt;String, Integer&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Integer> getNull() throws ServiceException {
        try {
            ServiceResponse<Map<String, Integer>> response = getNullDelegate(service.getNull(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Integer>> response = getNullDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get null dictionary value
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getNullAsync(final ServiceCallback<Map<String, Integer>> serviceCallback) {
        service.getNullAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Integer>> getNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Integer>>()
                .register(200, new TypeToken<Map<String, Integer>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get empty dictionary value {}
     *
     * @return the Map&lt;String, Integer&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Integer> getEmpty() throws ServiceException {
        try {
            ServiceResponse<Map<String, Integer>> response = getEmptyDelegate(service.getEmpty(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Integer>> response = getEmptyDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get empty dictionary value {}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getEmptyAsync(final ServiceCallback<Map<String, Integer>> serviceCallback) {
        service.getEmptyAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getEmptyDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Integer>> getEmptyDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Integer>>()
                .register(200, new TypeToken<Map<String, Integer>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Set dictionary value empty {}
     *
     * @param arrayBody the Map&lt;String, String&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putEmpty(Map<String, String> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            ServiceResponse<Void> response = putEmptyDelegate(service.putEmpty(arrayBody), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = putEmptyDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Set dictionary value empty {}
     *
     * @param arrayBody the Map&lt;String, String&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putEmptyAsync(Map<String, String> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        service.putEmptyAsync(arrayBody, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putEmptyDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> putEmptyDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get Dictionary with null value
     *
     * @return the Map&lt;String, String&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, String> getNullValue() throws ServiceException {
        try {
            ServiceResponse<Map<String, String>> response = getNullValueDelegate(service.getNullValue(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, String>> response = getNullValueDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get Dictionary with null value
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getNullValueAsync(final ServiceCallback<Map<String, String>> serviceCallback) {
        service.getNullValueAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getNullValueDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, String>> getNullValueDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, String>>()
                .register(200, new TypeToken<Map<String, String>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get Dictionary with null key
     *
     * @return the Map&lt;String, String&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, String> getNullKey() throws ServiceException {
        try {
            ServiceResponse<Map<String, String>> response = getNullKeyDelegate(service.getNullKey(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, String>> response = getNullKeyDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get Dictionary with null key
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getNullKeyAsync(final ServiceCallback<Map<String, String>> serviceCallback) {
        service.getNullKeyAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getNullKeyDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, String>> getNullKeyDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, String>>()
                .register(200, new TypeToken<Map<String, String>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get Dictionary with key as empty string
     *
     * @return the Map&lt;String, String&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, String> getEmptyStringKey() throws ServiceException {
        try {
            ServiceResponse<Map<String, String>> response = getEmptyStringKeyDelegate(service.getEmptyStringKey(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, String>> response = getEmptyStringKeyDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get Dictionary with key as empty string
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getEmptyStringKeyAsync(final ServiceCallback<Map<String, String>> serviceCallback) {
        service.getEmptyStringKeyAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getEmptyStringKeyDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, String>> getEmptyStringKeyDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, String>>()
                .register(200, new TypeToken<Map<String, String>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get invalid Dictionary value
     *
     * @return the Map&lt;String, String&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, String> getInvalid() throws ServiceException {
        try {
            ServiceResponse<Map<String, String>> response = getInvalidDelegate(service.getInvalid(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, String>> response = getInvalidDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get invalid Dictionary value
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getInvalidAsync(final ServiceCallback<Map<String, String>> serviceCallback) {
        service.getInvalidAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getInvalidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, String>> getInvalidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, String>>()
                .register(200, new TypeToken<Map<String, String>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get boolean dictionary value {"0": true, "1": false, "2": false, "3": true }
     *
     * @return the Map&lt;String, Boolean&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Boolean> getBooleanTfft() throws ServiceException {
        try {
            ServiceResponse<Map<String, Boolean>> response = getBooleanTfftDelegate(service.getBooleanTfft(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Boolean>> response = getBooleanTfftDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get boolean dictionary value {"0": true, "1": false, "2": false, "3": true }
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getBooleanTfftAsync(final ServiceCallback<Map<String, Boolean>> serviceCallback) {
        service.getBooleanTfftAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getBooleanTfftDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Boolean>> getBooleanTfftDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Boolean>>()
                .register(200, new TypeToken<Map<String, Boolean>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Set dictionary value empty {"0": true, "1": false, "2": false, "3": true }
     *
     * @param arrayBody the Map&lt;String, Boolean&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putBooleanTfft(Map<String, Boolean> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            ServiceResponse<Void> response = putBooleanTfftDelegate(service.putBooleanTfft(arrayBody), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = putBooleanTfftDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Set dictionary value empty {"0": true, "1": false, "2": false, "3": true }
     *
     * @param arrayBody the Map&lt;String, Boolean&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putBooleanTfftAsync(Map<String, Boolean> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        service.putBooleanTfftAsync(arrayBody, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putBooleanTfftDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> putBooleanTfftDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get boolean dictionary value {"0": true, "1": null, "2": false }
     *
     * @return the Map&lt;String, Boolean&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Boolean> getBooleanInvalidNull() throws ServiceException {
        try {
            ServiceResponse<Map<String, Boolean>> response = getBooleanInvalidNullDelegate(service.getBooleanInvalidNull(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Boolean>> response = getBooleanInvalidNullDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get boolean dictionary value {"0": true, "1": null, "2": false }
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getBooleanInvalidNullAsync(final ServiceCallback<Map<String, Boolean>> serviceCallback) {
        service.getBooleanInvalidNullAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getBooleanInvalidNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Boolean>> getBooleanInvalidNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Boolean>>()
                .register(200, new TypeToken<Map<String, Boolean>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get boolean dictionary value '{"0": true, "1": "boolean", "2": false}'
     *
     * @return the Map&lt;String, Boolean&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Boolean> getBooleanInvalidString() throws ServiceException {
        try {
            ServiceResponse<Map<String, Boolean>> response = getBooleanInvalidStringDelegate(service.getBooleanInvalidString(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Boolean>> response = getBooleanInvalidStringDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get boolean dictionary value '{"0": true, "1": "boolean", "2": false}'
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getBooleanInvalidStringAsync(final ServiceCallback<Map<String, Boolean>> serviceCallback) {
        service.getBooleanInvalidStringAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getBooleanInvalidStringDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Boolean>> getBooleanInvalidStringDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Boolean>>()
                .register(200, new TypeToken<Map<String, Boolean>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}
     *
     * @return the Map&lt;String, Integer&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Integer> getIntegerValid() throws ServiceException {
        try {
            ServiceResponse<Map<String, Integer>> response = getIntegerValidDelegate(service.getIntegerValid(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Integer>> response = getIntegerValidDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getIntegerValidAsync(final ServiceCallback<Map<String, Integer>> serviceCallback) {
        service.getIntegerValidAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getIntegerValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Integer>> getIntegerValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Integer>>()
                .register(200, new TypeToken<Map<String, Integer>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}
     *
     * @param arrayBody the Map&lt;String, Integer&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putIntegerValid(Map<String, Integer> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            ServiceResponse<Void> response = putIntegerValidDelegate(service.putIntegerValid(arrayBody), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = putIntegerValidDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}
     *
     * @param arrayBody the Map&lt;String, Integer&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putIntegerValidAsync(Map<String, Integer> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        service.putIntegerValidAsync(arrayBody, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putIntegerValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> putIntegerValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get integer dictionary value {"0": 1, "1": null, "2": 0}
     *
     * @return the Map&lt;String, Integer&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Integer> getIntInvalidNull() throws ServiceException {
        try {
            ServiceResponse<Map<String, Integer>> response = getIntInvalidNullDelegate(service.getIntInvalidNull(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Integer>> response = getIntInvalidNullDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get integer dictionary value {"0": 1, "1": null, "2": 0}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getIntInvalidNullAsync(final ServiceCallback<Map<String, Integer>> serviceCallback) {
        service.getIntInvalidNullAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getIntInvalidNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Integer>> getIntInvalidNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Integer>>()
                .register(200, new TypeToken<Map<String, Integer>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get integer dictionary value {"0": 1, "1": "integer", "2": 0}
     *
     * @return the Map&lt;String, Integer&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Integer> getIntInvalidString() throws ServiceException {
        try {
            ServiceResponse<Map<String, Integer>> response = getIntInvalidStringDelegate(service.getIntInvalidString(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Integer>> response = getIntInvalidStringDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get integer dictionary value {"0": 1, "1": "integer", "2": 0}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getIntInvalidStringAsync(final ServiceCallback<Map<String, Integer>> serviceCallback) {
        service.getIntInvalidStringAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getIntInvalidStringDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Integer>> getIntInvalidStringDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Integer>>()
                .register(200, new TypeToken<Map<String, Integer>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}
     *
     * @return the Map&lt;String, Long&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Long> getLongValid() throws ServiceException {
        try {
            ServiceResponse<Map<String, Long>> response = getLongValidDelegate(service.getLongValid(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Long>> response = getLongValidDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get integer dictionary value {"0": 1, "1": -1, "2": 3, "3": 300}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getLongValidAsync(final ServiceCallback<Map<String, Long>> serviceCallback) {
        service.getLongValidAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getLongValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Long>> getLongValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Long>>()
                .register(200, new TypeToken<Map<String, Long>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}
     *
     * @param arrayBody the Map&lt;String, Long&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putLongValid(Map<String, Long> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            ServiceResponse<Void> response = putLongValidDelegate(service.putLongValid(arrayBody), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = putLongValidDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Set dictionary value empty {"0": 1, "1": -1, "2": 3, "3": 300}
     *
     * @param arrayBody the Map&lt;String, Long&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putLongValidAsync(Map<String, Long> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        service.putLongValidAsync(arrayBody, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putLongValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> putLongValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get long dictionary value {"0": 1, "1": null, "2": 0}
     *
     * @return the Map&lt;String, Long&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Long> getLongInvalidNull() throws ServiceException {
        try {
            ServiceResponse<Map<String, Long>> response = getLongInvalidNullDelegate(service.getLongInvalidNull(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Long>> response = getLongInvalidNullDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get long dictionary value {"0": 1, "1": null, "2": 0}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getLongInvalidNullAsync(final ServiceCallback<Map<String, Long>> serviceCallback) {
        service.getLongInvalidNullAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getLongInvalidNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Long>> getLongInvalidNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Long>>()
                .register(200, new TypeToken<Map<String, Long>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get long dictionary value {"0": 1, "1": "integer", "2": 0}
     *
     * @return the Map&lt;String, Long&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Long> getLongInvalidString() throws ServiceException {
        try {
            ServiceResponse<Map<String, Long>> response = getLongInvalidStringDelegate(service.getLongInvalidString(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Long>> response = getLongInvalidStringDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get long dictionary value {"0": 1, "1": "integer", "2": 0}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getLongInvalidStringAsync(final ServiceCallback<Map<String, Long>> serviceCallback) {
        service.getLongInvalidStringAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getLongInvalidStringDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Long>> getLongInvalidStringDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Long>>()
                .register(200, new TypeToken<Map<String, Long>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}
     *
     * @return the Map&lt;String, Double&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Double> getFloatValid() throws ServiceException {
        try {
            ServiceResponse<Map<String, Double>> response = getFloatValidDelegate(service.getFloatValid(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Double>> response = getFloatValidDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getFloatValidAsync(final ServiceCallback<Map<String, Double>> serviceCallback) {
        service.getFloatValidAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getFloatValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Double>> getFloatValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Double>>()
                .register(200, new TypeToken<Map<String, Double>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}
     *
     * @param arrayBody the Map&lt;String, Double&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putFloatValid(Map<String, Double> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            ServiceResponse<Void> response = putFloatValidDelegate(service.putFloatValid(arrayBody), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = putFloatValidDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}
     *
     * @param arrayBody the Map&lt;String, Double&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putFloatValidAsync(Map<String, Double> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        service.putFloatValidAsync(arrayBody, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putFloatValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> putFloatValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}
     *
     * @return the Map&lt;String, Double&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Double> getFloatInvalidNull() throws ServiceException {
        try {
            ServiceResponse<Map<String, Double>> response = getFloatInvalidNullDelegate(service.getFloatInvalidNull(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Double>> response = getFloatInvalidNullDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getFloatInvalidNullAsync(final ServiceCallback<Map<String, Double>> serviceCallback) {
        service.getFloatInvalidNullAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getFloatInvalidNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Double>> getFloatInvalidNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Double>>()
                .register(200, new TypeToken<Map<String, Double>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}
     *
     * @return the Map&lt;String, Double&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Double> getFloatInvalidString() throws ServiceException {
        try {
            ServiceResponse<Map<String, Double>> response = getFloatInvalidStringDelegate(service.getFloatInvalidString(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Double>> response = getFloatInvalidStringDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getFloatInvalidStringAsync(final ServiceCallback<Map<String, Double>> serviceCallback) {
        service.getFloatInvalidStringAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getFloatInvalidStringDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Double>> getFloatInvalidStringDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Double>>()
                .register(200, new TypeToken<Map<String, Double>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}
     *
     * @return the Map&lt;String, Double&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Double> getDoubleValid() throws ServiceException {
        try {
            ServiceResponse<Map<String, Double>> response = getDoubleValidDelegate(service.getDoubleValid(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Double>> response = getDoubleValidDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get float dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getDoubleValidAsync(final ServiceCallback<Map<String, Double>> serviceCallback) {
        service.getDoubleValidAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getDoubleValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Double>> getDoubleValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Double>>()
                .register(200, new TypeToken<Map<String, Double>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}
     *
     * @param arrayBody the Map&lt;String, Double&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putDoubleValid(Map<String, Double> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            ServiceResponse<Void> response = putDoubleValidDelegate(service.putDoubleValid(arrayBody), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = putDoubleValidDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Set dictionary value {"0": 0, "1": -0.01, "2": 1.2e20}
     *
     * @param arrayBody the Map&lt;String, Double&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putDoubleValidAsync(Map<String, Double> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        service.putDoubleValidAsync(arrayBody, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putDoubleValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> putDoubleValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}
     *
     * @return the Map&lt;String, Double&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Double> getDoubleInvalidNull() throws ServiceException {
        try {
            ServiceResponse<Map<String, Double>> response = getDoubleInvalidNullDelegate(service.getDoubleInvalidNull(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Double>> response = getDoubleInvalidNullDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get float dictionary value {"0": 0.0, "1": null, "2": 1.2e20}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getDoubleInvalidNullAsync(final ServiceCallback<Map<String, Double>> serviceCallback) {
        service.getDoubleInvalidNullAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getDoubleInvalidNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Double>> getDoubleInvalidNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Double>>()
                .register(200, new TypeToken<Map<String, Double>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}
     *
     * @return the Map&lt;String, Double&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Double> getDoubleInvalidString() throws ServiceException {
        try {
            ServiceResponse<Map<String, Double>> response = getDoubleInvalidStringDelegate(service.getDoubleInvalidString(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Double>> response = getDoubleInvalidStringDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get boolean dictionary value {"0": 1.0, "1": "number", "2": 0.0}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getDoubleInvalidStringAsync(final ServiceCallback<Map<String, Double>> serviceCallback) {
        service.getDoubleInvalidStringAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getDoubleInvalidStringDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Double>> getDoubleInvalidStringDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Double>>()
                .register(200, new TypeToken<Map<String, Double>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get string dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}
     *
     * @return the Map&lt;String, String&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, String> getStringValid() throws ServiceException {
        try {
            ServiceResponse<Map<String, String>> response = getStringValidDelegate(service.getStringValid(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, String>> response = getStringValidDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get string dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getStringValidAsync(final ServiceCallback<Map<String, String>> serviceCallback) {
        service.getStringValidAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getStringValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, String>> getStringValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, String>>()
                .register(200, new TypeToken<Map<String, String>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Set dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}
     *
     * @param arrayBody the Map&lt;String, String&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putStringValid(Map<String, String> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            ServiceResponse<Void> response = putStringValidDelegate(service.putStringValid(arrayBody), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = putStringValidDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Set dictionary value {"0": "foo1", "1": "foo2", "2": "foo3"}
     *
     * @param arrayBody the Map&lt;String, String&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putStringValidAsync(Map<String, String> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        service.putStringValidAsync(arrayBody, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putStringValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> putStringValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get string dictionary value {"0": "foo", "1": null, "2": "foo2"}
     *
     * @return the Map&lt;String, String&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, String> getStringWithNull() throws ServiceException {
        try {
            ServiceResponse<Map<String, String>> response = getStringWithNullDelegate(service.getStringWithNull(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, String>> response = getStringWithNullDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get string dictionary value {"0": "foo", "1": null, "2": "foo2"}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getStringWithNullAsync(final ServiceCallback<Map<String, String>> serviceCallback) {
        service.getStringWithNullAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getStringWithNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, String>> getStringWithNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, String>>()
                .register(200, new TypeToken<Map<String, String>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get string dictionary value {"0": "foo", "1": 123, "2": "foo2"}
     *
     * @return the Map&lt;String, String&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, String> getStringWithInvalid() throws ServiceException {
        try {
            ServiceResponse<Map<String, String>> response = getStringWithInvalidDelegate(service.getStringWithInvalid(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, String>> response = getStringWithInvalidDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get string dictionary value {"0": "foo", "1": 123, "2": "foo2"}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getStringWithInvalidAsync(final ServiceCallback<Map<String, String>> serviceCallback) {
        service.getStringWithInvalidAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getStringWithInvalidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, String>> getStringWithInvalidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, String>>()
                .register(200, new TypeToken<Map<String, String>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get integer dictionary value {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}
     *
     * @return the Map&lt;String, LocalDate&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, LocalDate> getDateValid() throws ServiceException {
        try {
            ServiceResponse<Map<String, LocalDate>> response = getDateValidDelegate(service.getDateValid(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, LocalDate>> response = getDateValidDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get integer dictionary value {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getDateValidAsync(final ServiceCallback<Map<String, LocalDate>> serviceCallback) {
        service.getDateValidAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getDateValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, LocalDate>> getDateValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, LocalDate>>()
                .register(200, new TypeToken<Map<String, LocalDate>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Set dictionary value  {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}
     *
     * @param arrayBody the Map&lt;String, LocalDate&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putDateValid(Map<String, LocalDate> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            ServiceResponse<Void> response = putDateValidDelegate(service.putDateValid(arrayBody), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = putDateValidDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Set dictionary value  {"0": "2000-12-01", "1": "1980-01-02", "2": "1492-10-12"}
     *
     * @param arrayBody the Map&lt;String, LocalDate&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putDateValidAsync(Map<String, LocalDate> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        service.putDateValidAsync(arrayBody, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putDateValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> putDateValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get date dictionary value {"0": "2012-01-01", "1": null, "2": "1776-07-04"}
     *
     * @return the Map&lt;String, LocalDate&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, LocalDate> getDateInvalidNull() throws ServiceException {
        try {
            ServiceResponse<Map<String, LocalDate>> response = getDateInvalidNullDelegate(service.getDateInvalidNull(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, LocalDate>> response = getDateInvalidNullDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get date dictionary value {"0": "2012-01-01", "1": null, "2": "1776-07-04"}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getDateInvalidNullAsync(final ServiceCallback<Map<String, LocalDate>> serviceCallback) {
        service.getDateInvalidNullAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getDateInvalidNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, LocalDate>> getDateInvalidNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, LocalDate>>()
                .register(200, new TypeToken<Map<String, LocalDate>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get date dictionary value {"0": "2011-03-22", "1": "date"}
     *
     * @return the Map&lt;String, LocalDate&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, LocalDate> getDateInvalidChars() throws ServiceException {
        try {
            ServiceResponse<Map<String, LocalDate>> response = getDateInvalidCharsDelegate(service.getDateInvalidChars(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, LocalDate>> response = getDateInvalidCharsDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get date dictionary value {"0": "2011-03-22", "1": "date"}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getDateInvalidCharsAsync(final ServiceCallback<Map<String, LocalDate>> serviceCallback) {
        service.getDateInvalidCharsAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getDateInvalidCharsDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, LocalDate>> getDateInvalidCharsDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, LocalDate>>()
                .register(200, new TypeToken<Map<String, LocalDate>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get date-time dictionary value {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}
     *
     * @return the Map&lt;String, DateTime&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, DateTime> getDateTimeValid() throws ServiceException {
        try {
            ServiceResponse<Map<String, DateTime>> response = getDateTimeValidDelegate(service.getDateTimeValid(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, DateTime>> response = getDateTimeValidDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get date-time dictionary value {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getDateTimeValidAsync(final ServiceCallback<Map<String, DateTime>> serviceCallback) {
        service.getDateTimeValidAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getDateTimeValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, DateTime>> getDateTimeValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, DateTime>>()
                .register(200, new TypeToken<Map<String, DateTime>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Set dictionary value  {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}
     *
     * @param arrayBody the Map&lt;String, DateTime&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putDateTimeValid(Map<String, DateTime> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            ServiceResponse<Void> response = putDateTimeValidDelegate(service.putDateTimeValid(arrayBody), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = putDateTimeValidDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Set dictionary value  {"0": "2000-12-01t00:00:01z", "1": "1980-01-02T00:11:35+01:00", "2": "1492-10-12T10:15:01-08:00"}
     *
     * @param arrayBody the Map&lt;String, DateTime&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putDateTimeValidAsync(Map<String, DateTime> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        service.putDateTimeValidAsync(arrayBody, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putDateTimeValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> putDateTimeValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": null}
     *
     * @return the Map&lt;String, DateTime&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, DateTime> getDateTimeInvalidNull() throws ServiceException {
        try {
            ServiceResponse<Map<String, DateTime>> response = getDateTimeInvalidNullDelegate(service.getDateTimeInvalidNull(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, DateTime>> response = getDateTimeInvalidNullDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": null}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getDateTimeInvalidNullAsync(final ServiceCallback<Map<String, DateTime>> serviceCallback) {
        service.getDateTimeInvalidNullAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getDateTimeInvalidNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, DateTime>> getDateTimeInvalidNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, DateTime>>()
                .register(200, new TypeToken<Map<String, DateTime>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": "date-time"}
     *
     * @return the Map&lt;String, DateTime&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, DateTime> getDateTimeInvalidChars() throws ServiceException {
        try {
            ServiceResponse<Map<String, DateTime>> response = getDateTimeInvalidCharsDelegate(service.getDateTimeInvalidChars(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, DateTime>> response = getDateTimeInvalidCharsDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get date dictionary value {"0": "2000-12-01t00:00:01z", "1": "date-time"}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getDateTimeInvalidCharsAsync(final ServiceCallback<Map<String, DateTime>> serviceCallback) {
        service.getDateTimeInvalidCharsAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getDateTimeInvalidCharsDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, DateTime>> getDateTimeInvalidCharsDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, DateTime>>()
                .register(200, new TypeToken<Map<String, DateTime>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get byte dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each item encoded in base64
     *
     * @return the Map&lt;String, byte[]&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, byte[]> getByteValid() throws ServiceException {
        try {
            ServiceResponse<Map<String, byte[]>> response = getByteValidDelegate(service.getByteValid(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, byte[]>> response = getByteValidDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get byte dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each item encoded in base64
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getByteValidAsync(final ServiceCallback<Map<String, byte[]>> serviceCallback) {
        service.getByteValidAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getByteValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, byte[]>> getByteValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, byte[]>>()
                .register(200, new TypeToken<Map<String, byte[]>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Put the dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each elementencoded in base 64
     *
     * @param arrayBody the Map&lt;String, byte[]&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putByteValid(Map<String, byte[]> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            ServiceResponse<Void> response = putByteValidDelegate(service.putByteValid(arrayBody), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = putByteValidDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Put the dictionary value {"0": hex(FF FF FF FA), "1": hex(01 02 03), "2": hex (25, 29, 43)} with each elementencoded in base 64
     *
     * @param arrayBody the Map&lt;String, byte[]&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putByteValidAsync(Map<String, byte[]> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        service.putByteValidAsync(arrayBody, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putByteValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> putByteValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get byte dictionary value {"0": hex(FF FF FF FA), "1": null} with the first item base64 encoded
     *
     * @return the Map&lt;String, byte[]&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, byte[]> getByteInvalidNull() throws ServiceException {
        try {
            ServiceResponse<Map<String, byte[]>> response = getByteInvalidNullDelegate(service.getByteInvalidNull(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, byte[]>> response = getByteInvalidNullDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get byte dictionary value {"0": hex(FF FF FF FA), "1": null} with the first item base64 encoded
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getByteInvalidNullAsync(final ServiceCallback<Map<String, byte[]>> serviceCallback) {
        service.getByteInvalidNullAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getByteInvalidNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, byte[]>> getByteInvalidNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, byte[]>>()
                .register(200, new TypeToken<Map<String, byte[]>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get dictionary of complex type null value
     *
     * @return the Map&lt;String, Widget&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Widget> getComplexNull() throws ServiceException {
        try {
            ServiceResponse<Map<String, Widget>> response = getComplexNullDelegate(service.getComplexNull(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Widget>> response = getComplexNullDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get dictionary of complex type null value
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getComplexNullAsync(final ServiceCallback<Map<String, Widget>> serviceCallback) {
        service.getComplexNullAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getComplexNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Widget>> getComplexNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Widget>>()
                .register(200, new TypeToken<Map<String, Widget>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get empty dictionary of complex type {}
     *
     * @return the Map&lt;String, Widget&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Widget> getComplexEmpty() throws ServiceException {
        try {
            ServiceResponse<Map<String, Widget>> response = getComplexEmptyDelegate(service.getComplexEmpty(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Widget>> response = getComplexEmptyDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get empty dictionary of complex type {}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getComplexEmptyAsync(final ServiceCallback<Map<String, Widget>> serviceCallback) {
        service.getComplexEmptyAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getComplexEmptyDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Widget>> getComplexEmptyDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Widget>>()
                .register(200, new TypeToken<Map<String, Widget>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get dictionary of complex type with null item {"0": {"integer": 1, "string": "2"}, "1": null, "2": {"integer": 5, "string": "6"}}
     *
     * @return the Map&lt;String, Widget&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Widget> getComplexItemNull() throws ServiceException {
        try {
            ServiceResponse<Map<String, Widget>> response = getComplexItemNullDelegate(service.getComplexItemNull(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Widget>> response = getComplexItemNullDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get dictionary of complex type with null item {"0": {"integer": 1, "string": "2"}, "1": null, "2": {"integer": 5, "string": "6"}}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getComplexItemNullAsync(final ServiceCallback<Map<String, Widget>> serviceCallback) {
        service.getComplexItemNullAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getComplexItemNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Widget>> getComplexItemNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Widget>>()
                .register(200, new TypeToken<Map<String, Widget>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get dictionary of complex type with empty item {"0": {"integer": 1, "string": "2"}, "1:" {}, "2": {"integer": 5, "string": "6"}}
     *
     * @return the Map&lt;String, Widget&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Widget> getComplexItemEmpty() throws ServiceException {
        try {
            ServiceResponse<Map<String, Widget>> response = getComplexItemEmptyDelegate(service.getComplexItemEmpty(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Widget>> response = getComplexItemEmptyDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get dictionary of complex type with empty item {"0": {"integer": 1, "string": "2"}, "1:" {}, "2": {"integer": 5, "string": "6"}}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getComplexItemEmptyAsync(final ServiceCallback<Map<String, Widget>> serviceCallback) {
        service.getComplexItemEmptyAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getComplexItemEmptyDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Widget>> getComplexItemEmptyDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Widget>>()
                .register(200, new TypeToken<Map<String, Widget>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get dictionary of complex type with {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer": 5, "string": "6"}}
     *
     * @return the Map&lt;String, Widget&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Widget> getComplexValid() throws ServiceException {
        try {
            ServiceResponse<Map<String, Widget>> response = getComplexValidDelegate(service.getComplexValid(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Widget>> response = getComplexValidDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get dictionary of complex type with {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer": 5, "string": "6"}}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getComplexValidAsync(final ServiceCallback<Map<String, Widget>> serviceCallback) {
        service.getComplexValidAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getComplexValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Widget>> getComplexValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Widget>>()
                .register(200, new TypeToken<Map<String, Widget>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Put an dictionary of complex type with values {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer": 5, "string": "6"}}
     *
     * @param arrayBody the Map&lt;String, Widget&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putComplexValid(Map<String, Widget> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            ServiceResponse<Void> response = putComplexValidDelegate(service.putComplexValid(arrayBody), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = putComplexValidDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Put an dictionary of complex type with values {"0": {"integer": 1, "string": "2"}, "1": {"integer": 3, "string": "4"}, "2": {"integer": 5, "string": "6"}}
     *
     * @param arrayBody the Map&lt;String, Widget&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putComplexValidAsync(Map<String, Widget> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        service.putComplexValidAsync(arrayBody, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putComplexValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> putComplexValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get a null array
     *
     * @return the Map&lt;String, List&lt;String&gt;&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, List<String>> getArrayNull() throws ServiceException {
        try {
            ServiceResponse<Map<String, List<String>>> response = getArrayNullDelegate(service.getArrayNull(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, List<String>>> response = getArrayNullDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get a null array
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getArrayNullAsync(final ServiceCallback<Map<String, List<String>>> serviceCallback) {
        service.getArrayNullAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getArrayNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, List<String>>> getArrayNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, List<String>>>()
                .register(200, new TypeToken<Map<String, List<String>>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get an empty dictionary {}
     *
     * @return the Map&lt;String, List&lt;String&gt;&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, List<String>> getArrayEmpty() throws ServiceException {
        try {
            ServiceResponse<Map<String, List<String>>> response = getArrayEmptyDelegate(service.getArrayEmpty(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, List<String>>> response = getArrayEmptyDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get an empty dictionary {}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getArrayEmptyAsync(final ServiceCallback<Map<String, List<String>>> serviceCallback) {
        service.getArrayEmptyAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getArrayEmptyDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, List<String>>> getArrayEmptyDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, List<String>>>()
                .register(200, new TypeToken<Map<String, List<String>>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get an dictionary of array of strings {"0": ["1", "2", "3"], "1": null, "2": ["7", "8", "9"]}
     *
     * @return the Map&lt;String, List&lt;String&gt;&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, List<String>> getArrayItemNull() throws ServiceException {
        try {
            ServiceResponse<Map<String, List<String>>> response = getArrayItemNullDelegate(service.getArrayItemNull(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, List<String>>> response = getArrayItemNullDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get an dictionary of array of strings {"0": ["1", "2", "3"], "1": null, "2": ["7", "8", "9"]}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getArrayItemNullAsync(final ServiceCallback<Map<String, List<String>>> serviceCallback) {
        service.getArrayItemNullAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getArrayItemNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, List<String>>> getArrayItemNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, List<String>>>()
                .register(200, new TypeToken<Map<String, List<String>>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get an array of array of strings [{"0": ["1", "2", "3"], "1": [], "2": ["7", "8", "9"]}
     *
     * @return the Map&lt;String, List&lt;String&gt;&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, List<String>> getArrayItemEmpty() throws ServiceException {
        try {
            ServiceResponse<Map<String, List<String>>> response = getArrayItemEmptyDelegate(service.getArrayItemEmpty(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, List<String>>> response = getArrayItemEmptyDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get an array of array of strings [{"0": ["1", "2", "3"], "1": [], "2": ["7", "8", "9"]}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getArrayItemEmptyAsync(final ServiceCallback<Map<String, List<String>>> serviceCallback) {
        service.getArrayItemEmptyAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getArrayItemEmptyDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, List<String>>> getArrayItemEmptyDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, List<String>>>()
                .register(200, new TypeToken<Map<String, List<String>>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get an array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}
     *
     * @return the Map&lt;String, List&lt;String&gt;&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, List<String>> getArrayValid() throws ServiceException {
        try {
            ServiceResponse<Map<String, List<String>>> response = getArrayValidDelegate(service.getArrayValid(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, List<String>>> response = getArrayValidDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get an array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getArrayValidAsync(final ServiceCallback<Map<String, List<String>>> serviceCallback) {
        service.getArrayValidAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getArrayValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, List<String>>> getArrayValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, List<String>>>()
                .register(200, new TypeToken<Map<String, List<String>>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Put An array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}
     *
     * @param arrayBody the Map&lt;String, List&lt;String&gt;&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putArrayValid(Map<String, List<String>> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            ServiceResponse<Void> response = putArrayValidDelegate(service.putArrayValid(arrayBody), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = putArrayValidDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Put An array of array of strings {"0": ["1", "2", "3"], "1": ["4", "5", "6"], "2": ["7", "8", "9"]}
     *
     * @param arrayBody the Map&lt;String, List&lt;String&gt;&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putArrayValidAsync(Map<String, List<String>> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        service.putArrayValidAsync(arrayBody, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putArrayValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> putArrayValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get an dictionaries of dictionaries with value null
     *
     * @return the Map&lt;String, Map&lt;String, String&gt;&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Map<String, String>> getDictionaryNull() throws ServiceException {
        try {
            ServiceResponse<Map<String, Map<String, String>>> response = getDictionaryNullDelegate(service.getDictionaryNull(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Map<String, String>>> response = getDictionaryNullDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get an dictionaries of dictionaries with value null
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getDictionaryNullAsync(final ServiceCallback<Map<String, Map<String, String>>> serviceCallback) {
        service.getDictionaryNullAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getDictionaryNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Map<String, String>>> getDictionaryNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Map<String, String>>>()
                .register(200, new TypeToken<Map<String, Map<String, String>>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {}
     *
     * @return the Map&lt;String, Map&lt;String, String&gt;&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Map<String, String>> getDictionaryEmpty() throws ServiceException {
        try {
            ServiceResponse<Map<String, Map<String, String>>> response = getDictionaryEmptyDelegate(service.getDictionaryEmpty(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Map<String, String>>> response = getDictionaryEmptyDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getDictionaryEmptyAsync(final ServiceCallback<Map<String, Map<String, String>>> serviceCallback) {
        service.getDictionaryEmptyAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getDictionaryEmptyDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Map<String, String>>> getDictionaryEmptyDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Map<String, String>>>()
                .register(200, new TypeToken<Map<String, Map<String, String>>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": null, "2": {"7": "seven", "8": "eight", "9": "nine"}}
     *
     * @return the Map&lt;String, Map&lt;String, String&gt;&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Map<String, String>> getDictionaryItemNull() throws ServiceException {
        try {
            ServiceResponse<Map<String, Map<String, String>>> response = getDictionaryItemNullDelegate(service.getDictionaryItemNull(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Map<String, String>>> response = getDictionaryItemNullDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": null, "2": {"7": "seven", "8": "eight", "9": "nine"}}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getDictionaryItemNullAsync(final ServiceCallback<Map<String, Map<String, String>>> serviceCallback) {
        service.getDictionaryItemNullAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getDictionaryItemNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Map<String, String>>> getDictionaryItemNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Map<String, String>>>()
                .register(200, new TypeToken<Map<String, Map<String, String>>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {}, "2": {"7": "seven", "8": "eight", "9": "nine"}}
     *
     * @return the Map&lt;String, Map&lt;String, String&gt;&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Map<String, String>> getDictionaryItemEmpty() throws ServiceException {
        try {
            ServiceResponse<Map<String, Map<String, String>>> response = getDictionaryItemEmptyDelegate(service.getDictionaryItemEmpty(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Map<String, String>>> response = getDictionaryItemEmptyDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {}, "2": {"7": "seven", "8": "eight", "9": "nine"}}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getDictionaryItemEmptyAsync(final ServiceCallback<Map<String, Map<String, String>>> serviceCallback) {
        service.getDictionaryItemEmptyAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getDictionaryItemEmptyDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Map<String, String>>> getDictionaryItemEmptyDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Map<String, String>>>()
                .register(200, new TypeToken<Map<String, Map<String, String>>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five", "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}
     *
     * @return the Map&lt;String, Map&lt;String, String&gt;&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public Map<String, Map<String, String>> getDictionaryValid() throws ServiceException {
        try {
            ServiceResponse<Map<String, Map<String, String>>> response = getDictionaryValidDelegate(service.getDictionaryValid(), null);
            return response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Map<String, Map<String, String>>> response = getDictionaryValidDelegate(error.getResponse(), error);
            return response.getBody();
        }
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five", "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getDictionaryValidAsync(final ServiceCallback<Map<String, Map<String, String>>> serviceCallback) {
        service.getDictionaryValidAsync(new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getDictionaryValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Map<String, Map<String, String>>> getDictionaryValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Map<String, Map<String, String>>>()
                .register(200, new TypeToken<Map<String, Map<String, String>>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five", "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}
     *
     * @param arrayBody the Map&lt;String, Map&lt;String, String&gt;&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putDictionaryValid(Map<String, Map<String, String>> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            ServiceResponse<Void> response = putDictionaryValidDelegate(service.putDictionaryValid(arrayBody), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = putDictionaryValidDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get an dictionaries of dictionaries of type &lt;string, string&gt; with value {"0": {"1": "one", "2": "two", "3": "three"}, "1": {"4": "four", "5": "five", "6": "six"}, "2": {"7": "seven", "8": "eight", "9": "nine"}}
     *
     * @param arrayBody the Map&lt;String, Map&lt;String, String&gt;&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void putDictionaryValidAsync(Map<String, Map<String, String>> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        service.putDictionaryValidAsync(arrayBody, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(putDictionaryValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> putDictionaryValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

}
