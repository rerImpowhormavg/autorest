/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 * 
 * Code generated by Microsoft (R) AutoRest Code Generator 0.11.0.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package fixtures.url;

import com.google.gson.reflect.TypeToken;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceException;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseBuilder;
import com.microsoft.rest.ServiceResponseCallback;
import retrofit.RestAdapter;
import retrofit.RetrofitError;
import retrofit.client.Response;
import fixtures.url.models.UriColor;
import org.joda.time.LocalDate;
import org.joda.time.DateTime;
import fixtures.url.models.Error;
import org.apache.commons.codec.binary.Base64;
import com.microsoft.rest.serializer.JacksonHelper;

public class PathsImpl implements Paths {
    private PathsService service;
    AutoRestUrlTestService client;

    public PathsImpl(RestAdapter restAdapter, AutoRestUrlTestService client) {
        this.service = restAdapter.create(PathsService.class);
        this.client = client;
    }

    /**
     * Get true Boolean value on path
     *
     * @param boolPath true boolean value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void getBooleanTrue(boolean boolPath) throws ServiceException {
        try {
            ServiceResponse<Void> response = getBooleanTrueDelegate(service.getBooleanTrue(boolPath), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = getBooleanTrueDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get true Boolean value on path
     *
     * @param boolPath true boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getBooleanTrueAsync(boolean boolPath, final ServiceCallback<Void> serviceCallback) {
        service.getBooleanTrueAsync(boolPath, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getBooleanTrueDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> getBooleanTrueDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get false Boolean value on path
     *
     * @param boolPath false boolean value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void getBooleanFalse(boolean boolPath) throws ServiceException {
        try {
            ServiceResponse<Void> response = getBooleanFalseDelegate(service.getBooleanFalse(boolPath), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = getBooleanFalseDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get false Boolean value on path
     *
     * @param boolPath false boolean value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getBooleanFalseAsync(boolean boolPath, final ServiceCallback<Void> serviceCallback) {
        service.getBooleanFalseAsync(boolPath, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getBooleanFalseDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> getBooleanFalseDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '1000000' integer value
     *
     * @param intPath '1000000' integer value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void getIntOneMillion(int intPath) throws ServiceException {
        try {
            ServiceResponse<Void> response = getIntOneMillionDelegate(service.getIntOneMillion(intPath), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = getIntOneMillionDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '1000000' integer value
     *
     * @param intPath '1000000' integer value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getIntOneMillionAsync(int intPath, final ServiceCallback<Void> serviceCallback) {
        service.getIntOneMillionAsync(intPath, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getIntOneMillionDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> getIntOneMillionDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '-1000000' integer value
     *
     * @param intPath '-1000000' integer value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void getIntNegativeOneMillion(int intPath) throws ServiceException {
        try {
            ServiceResponse<Void> response = getIntNegativeOneMillionDelegate(service.getIntNegativeOneMillion(intPath), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = getIntNegativeOneMillionDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '-1000000' integer value
     *
     * @param intPath '-1000000' integer value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getIntNegativeOneMillionAsync(int intPath, final ServiceCallback<Void> serviceCallback) {
        service.getIntNegativeOneMillionAsync(intPath, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getIntNegativeOneMillionDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> getIntNegativeOneMillionDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '10000000000' 64 bit integer value
     *
     * @param longPath '10000000000' 64 bit integer value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void getTenBillion(long longPath) throws ServiceException {
        try {
            ServiceResponse<Void> response = getTenBillionDelegate(service.getTenBillion(longPath), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = getTenBillionDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '10000000000' 64 bit integer value
     *
     * @param longPath '10000000000' 64 bit integer value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getTenBillionAsync(long longPath, final ServiceCallback<Void> serviceCallback) {
        service.getTenBillionAsync(longPath, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getTenBillionDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> getTenBillionDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '-10000000000' 64 bit integer value
     *
     * @param longPath '-10000000000' 64 bit integer value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void getNegativeTenBillion(long longPath) throws ServiceException {
        try {
            ServiceResponse<Void> response = getNegativeTenBillionDelegate(service.getNegativeTenBillion(longPath), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = getNegativeTenBillionDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '-10000000000' 64 bit integer value
     *
     * @param longPath '-10000000000' 64 bit integer value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getNegativeTenBillionAsync(long longPath, final ServiceCallback<Void> serviceCallback) {
        service.getNegativeTenBillionAsync(longPath, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getNegativeTenBillionDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> getNegativeTenBillionDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '1.034E+20' numeric value
     *
     * @param floatPath '1.034E+20'numeric value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void floatScientificPositive(double floatPath) throws ServiceException {
        try {
            ServiceResponse<Void> response = floatScientificPositiveDelegate(service.floatScientificPositive(floatPath), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = floatScientificPositiveDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '1.034E+20' numeric value
     *
     * @param floatPath '1.034E+20'numeric value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void floatScientificPositiveAsync(double floatPath, final ServiceCallback<Void> serviceCallback) {
        service.floatScientificPositiveAsync(floatPath, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(floatScientificPositiveDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> floatScientificPositiveDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '-1.034E-20' numeric value
     *
     * @param floatPath '-1.034E-20'numeric value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void floatScientificNegative(double floatPath) throws ServiceException {
        try {
            ServiceResponse<Void> response = floatScientificNegativeDelegate(service.floatScientificNegative(floatPath), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = floatScientificNegativeDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '-1.034E-20' numeric value
     *
     * @param floatPath '-1.034E-20'numeric value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void floatScientificNegativeAsync(double floatPath, final ServiceCallback<Void> serviceCallback) {
        service.floatScientificNegativeAsync(floatPath, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(floatScientificNegativeDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> floatScientificNegativeDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '9999999.999' numeric value
     *
     * @param doublePath '9999999.999'numeric value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void doubleDecimalPositive(double doublePath) throws ServiceException {
        try {
            ServiceResponse<Void> response = doubleDecimalPositiveDelegate(service.doubleDecimalPositive(doublePath), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = doubleDecimalPositiveDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '9999999.999' numeric value
     *
     * @param doublePath '9999999.999'numeric value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void doubleDecimalPositiveAsync(double doublePath, final ServiceCallback<Void> serviceCallback) {
        service.doubleDecimalPositiveAsync(doublePath, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(doubleDecimalPositiveDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> doubleDecimalPositiveDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '-9999999.999' numeric value
     *
     * @param doublePath '-9999999.999'numeric value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void doubleDecimalNegative(double doublePath) throws ServiceException {
        try {
            ServiceResponse<Void> response = doubleDecimalNegativeDelegate(service.doubleDecimalNegative(doublePath), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = doubleDecimalNegativeDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '-9999999.999' numeric value
     *
     * @param doublePath '-9999999.999'numeric value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void doubleDecimalNegativeAsync(double doublePath, final ServiceCallback<Void> serviceCallback) {
        service.doubleDecimalNegativeAsync(doublePath, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(doubleDecimalNegativeDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> doubleDecimalNegativeDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value
     *
     * @param stringPath '啊齄丂狛狜隣郎隣兀﨩'multi-byte string value. Possible values for this parameter include: '啊齄丂狛狜隣郎隣兀﨩'
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void stringUnicode(String stringPath) throws ServiceException {
        if (stringPath == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter stringPath is required and cannot be null."));
        }
        try {
            ServiceResponse<Void> response = stringUnicodeDelegate(service.stringUnicode(stringPath), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = stringUnicodeDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multi-byte string value
     *
     * @param stringPath '啊齄丂狛狜隣郎隣兀﨩'multi-byte string value. Possible values for this parameter include: '啊齄丂狛狜隣郎隣兀﨩'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void stringUnicodeAsync(String stringPath, final ServiceCallback<Void> serviceCallback) {
        if (stringPath == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter stringPath is required and cannot be null.")));
        }
        service.stringUnicodeAsync(stringPath, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(stringUnicodeDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> stringUnicodeDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get 'begin!*'();:@ &amp;=+$,/?#[]end
     *
     * @param stringPath 'begin!*'();:@ &amp;=+$,/?#[]end' url encoded string value. Possible values for this parameter include: 'begin!*'();:@ &amp;=+$,/?#[]end'
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void stringUrlEncoded(String stringPath) throws ServiceException {
        if (stringPath == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter stringPath is required and cannot be null."));
        }
        try {
            ServiceResponse<Void> response = stringUrlEncodedDelegate(service.stringUrlEncoded(stringPath), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = stringUrlEncodedDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get 'begin!*'();:@ &amp;=+$,/?#[]end
     *
     * @param stringPath 'begin!*'();:@ &amp;=+$,/?#[]end' url encoded string value. Possible values for this parameter include: 'begin!*'();:@ &amp;=+$,/?#[]end'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void stringUrlEncodedAsync(String stringPath, final ServiceCallback<Void> serviceCallback) {
        if (stringPath == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter stringPath is required and cannot be null.")));
        }
        service.stringUrlEncodedAsync(stringPath, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(stringUrlEncodedDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> stringUrlEncodedDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get ''
     *
     * @param stringPath '' string value. Possible values for this parameter include: ''
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void stringEmpty(String stringPath) throws ServiceException {
        if (stringPath == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter stringPath is required and cannot be null."));
        }
        try {
            ServiceResponse<Void> response = stringEmptyDelegate(service.stringEmpty(stringPath), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = stringEmptyDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get ''
     *
     * @param stringPath '' string value. Possible values for this parameter include: ''
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void stringEmptyAsync(String stringPath, final ServiceCallback<Void> serviceCallback) {
        if (stringPath == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter stringPath is required and cannot be null.")));
        }
        service.stringEmptyAsync(stringPath, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(stringEmptyDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> stringEmptyDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get null (should throw)
     *
     * @param stringPath null string value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void stringNull(String stringPath) throws ServiceException {
        if (stringPath == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter stringPath is required and cannot be null."));
        }
        try {
            ServiceResponse<Void> response = stringNullDelegate(service.stringNull(stringPath), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = stringNullDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get null (should throw)
     *
     * @param stringPath null string value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void stringNullAsync(String stringPath, final ServiceCallback<Void> serviceCallback) {
        if (stringPath == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter stringPath is required and cannot be null.")));
        }
        service.stringNullAsync(stringPath, new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(stringNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> stringNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(400, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get using uri with 'green color' in path parameter
     *
     * @param enumPath send the value green. Possible values for this parameter include: 'red color', 'green color', 'blue color'
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void enumValid(UriColor enumPath) throws ServiceException {
        if (enumPath == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter enumPath is required and cannot be null."));
        }
        try {
            ServiceResponse<Void> response = enumValidDelegate(service.enumValid(JacksonHelper.serializeRaw(enumPath)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = enumValidDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get using uri with 'green color' in path parameter
     *
     * @param enumPath send the value green. Possible values for this parameter include: 'red color', 'green color', 'blue color'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void enumValidAsync(UriColor enumPath, final ServiceCallback<Void> serviceCallback) {
        if (enumPath == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter enumPath is required and cannot be null.")));
        }
        service.enumValidAsync(JacksonHelper.serializeRaw(enumPath), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(enumValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> enumValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get null (should throw on the client before the request is sent on wire)
     *
     * @param enumPath send null should throw. Possible values for this parameter include: 'red color', 'green color', 'blue color'
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void enumNull(UriColor enumPath) throws ServiceException {
        if (enumPath == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter enumPath is required and cannot be null."));
        }
        try {
            ServiceResponse<Void> response = enumNullDelegate(service.enumNull(JacksonHelper.serializeRaw(enumPath)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = enumNullDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get null (should throw on the client before the request is sent on wire)
     *
     * @param enumPath send null should throw. Possible values for this parameter include: 'red color', 'green color', 'blue color'
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void enumNullAsync(UriColor enumPath, final ServiceCallback<Void> serviceCallback) {
        if (enumPath == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter enumPath is required and cannot be null.")));
        }
        service.enumNullAsync(JacksonHelper.serializeRaw(enumPath), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(enumNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> enumNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(400, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
     *
     * @param bytePath '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void byteMultiByte(byte[] bytePath) throws ServiceException {
        if (bytePath == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter bytePath is required and cannot be null."));
        }
        try {
            ServiceResponse<Void> response = byteMultiByteDelegate(service.byteMultiByte(Base64.encodeBase64String(bytePath)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = byteMultiByteDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
     *
     * @param bytePath '啊齄丂狛狜隣郎隣兀﨩' multibyte value as utf-8 encoded byte array
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void byteMultiByteAsync(byte[] bytePath, final ServiceCallback<Void> serviceCallback) {
        if (bytePath == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter bytePath is required and cannot be null.")));
        }
        service.byteMultiByteAsync(Base64.encodeBase64String(bytePath), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(byteMultiByteDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> byteMultiByteDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '' as byte array
     *
     * @param bytePath '' as byte array
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void byteEmpty(byte[] bytePath) throws ServiceException {
        if (bytePath == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter bytePath is required and cannot be null."));
        }
        try {
            ServiceResponse<Void> response = byteEmptyDelegate(service.byteEmpty(Base64.encodeBase64String(bytePath)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = byteEmptyDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '' as byte array
     *
     * @param bytePath '' as byte array
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void byteEmptyAsync(byte[] bytePath, final ServiceCallback<Void> serviceCallback) {
        if (bytePath == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter bytePath is required and cannot be null.")));
        }
        service.byteEmptyAsync(Base64.encodeBase64String(bytePath), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(byteEmptyDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> byteEmptyDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get null as byte array (should throw)
     *
     * @param bytePath null as byte array (should throw)
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void byteNull(byte[] bytePath) throws ServiceException {
        if (bytePath == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter bytePath is required and cannot be null."));
        }
        try {
            ServiceResponse<Void> response = byteNullDelegate(service.byteNull(Base64.encodeBase64String(bytePath)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = byteNullDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get null as byte array (should throw)
     *
     * @param bytePath null as byte array (should throw)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void byteNullAsync(byte[] bytePath, final ServiceCallback<Void> serviceCallback) {
        if (bytePath == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter bytePath is required and cannot be null.")));
        }
        service.byteNullAsync(Base64.encodeBase64String(bytePath), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(byteNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> byteNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(400, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '2012-01-01' as date
     *
     * @param datePath '2012-01-01' as date
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void dateValid(LocalDate datePath) throws ServiceException {
        if (datePath == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter datePath is required and cannot be null."));
        }
        try {
            ServiceResponse<Void> response = dateValidDelegate(service.dateValid(JacksonHelper.serializeRaw(datePath)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = dateValidDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '2012-01-01' as date
     *
     * @param datePath '2012-01-01' as date
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void dateValidAsync(LocalDate datePath, final ServiceCallback<Void> serviceCallback) {
        if (datePath == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter datePath is required and cannot be null.")));
        }
        service.dateValidAsync(JacksonHelper.serializeRaw(datePath), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(dateValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> dateValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get null as date - this should throw or be unusable on the client side, depending on date representation
     *
     * @param datePath null as date (should throw)
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void dateNull(LocalDate datePath) throws ServiceException {
        if (datePath == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter datePath is required and cannot be null."));
        }
        try {
            ServiceResponse<Void> response = dateNullDelegate(service.dateNull(JacksonHelper.serializeRaw(datePath)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = dateNullDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get null as date - this should throw or be unusable on the client side, depending on date representation
     *
     * @param datePath null as date (should throw)
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void dateNullAsync(LocalDate datePath, final ServiceCallback<Void> serviceCallback) {
        if (datePath == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter datePath is required and cannot be null.")));
        }
        service.dateNullAsync(JacksonHelper.serializeRaw(datePath), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(dateNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> dateNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(400, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get '2012-01-01T01:01:01Z' as date-time
     *
     * @param dateTimePath '2012-01-01T01:01:01Z' as date-time
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void dateTimeValid(DateTime dateTimePath) throws ServiceException {
        if (dateTimePath == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter dateTimePath is required and cannot be null."));
        }
        try {
            ServiceResponse<Void> response = dateTimeValidDelegate(service.dateTimeValid(JacksonHelper.serializeRaw(dateTimePath)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = dateTimeValidDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get '2012-01-01T01:01:01Z' as date-time
     *
     * @param dateTimePath '2012-01-01T01:01:01Z' as date-time
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void dateTimeValidAsync(DateTime dateTimePath, final ServiceCallback<Void> serviceCallback) {
        if (dateTimePath == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter dateTimePath is required and cannot be null.")));
        }
        service.dateTimeValidAsync(JacksonHelper.serializeRaw(dateTimePath), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(dateTimeValidDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> dateTimeValidDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * Get null as date-time, should be disallowed or throw depending on representation of date-time
     *
     * @param dateTimePath null as date-time
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void dateTimeNull(DateTime dateTimePath) throws ServiceException {
        if (dateTimePath == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter dateTimePath is required and cannot be null."));
        }
        try {
            ServiceResponse<Void> response = dateTimeNullDelegate(service.dateTimeNull(JacksonHelper.serializeRaw(dateTimePath)), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = dateTimeNullDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * Get null as date-time, should be disallowed or throw depending on representation of date-time
     *
     * @param dateTimePath null as date-time
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void dateTimeNullAsync(DateTime dateTimePath, final ServiceCallback<Void> serviceCallback) {
        if (dateTimePath == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter dateTimePath is required and cannot be null.")));
        }
        service.dateTimeNullAsync(JacksonHelper.serializeRaw(dateTimePath), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(dateTimeNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> dateTimeNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(400, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

}
