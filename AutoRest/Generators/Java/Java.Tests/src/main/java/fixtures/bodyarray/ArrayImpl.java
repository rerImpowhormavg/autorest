/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 * 
 * Code generated by Microsoft (R) AutoRest Code Generator 0.13.0.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package fixtures.bodyarray;

import com.google.common.reflect.TypeToken;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceException;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseBuilder;
import com.microsoft.rest.ServiceResponseCallback;
import com.microsoft.rest.ServiceResponseEmptyCallback;
import com.squareup.okhttp.ResponseBody;
import retrofit.Retrofit;
import retrofit.Call;
import retrofit.Response;
import java.util.List;
import fixtures.bodyarray.models.Error;
import org.joda.time.LocalDate;
import org.joda.time.DateTime;
import com.microsoft.rest.DateTimeRfc1123;
import org.joda.time.Period;
import org.apache.commons.codec.binary.Base64;
import fixtures.bodyarray.models.Product;
import java.util.Map;
import com.microsoft.rest.Validator;

public class ArrayImpl implements Array {
    private ArrayService service;
    AutoRestSwaggerBATArrayService client;

    public ArrayImpl(Retrofit retrofit, AutoRestSwaggerBATArrayService client) {
        this.service = retrofit.create(ArrayService.class);
        this.client = client;
    }

    /**
     * Get null array value
     *
     * @return the List&lt;Integer&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Integer> getNull() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getNull();
            ServiceResponse<List<Integer>> response = getNullDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get null array value
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getNullAsync(final ServiceCallback<List<Integer>> serviceCallback) {
        Call<ResponseBody> call = service.getNull();
        call.enqueue(new ServiceResponseCallback<List<Integer>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getNullDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Integer>> getNullDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Integer>>()
                .register(200, new TypeToken<List<Integer>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get invalid array [1, 2, 3
     *
     * @return the List&lt;Integer&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Integer> getInvalid() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getInvalid();
            ServiceResponse<List<Integer>> response = getInvalidDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get invalid array [1, 2, 3
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getInvalidAsync(final ServiceCallback<List<Integer>> serviceCallback) {
        Call<ResponseBody> call = service.getInvalid();
        call.enqueue(new ServiceResponseCallback<List<Integer>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getInvalidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Integer>> getInvalidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Integer>>()
                .register(200, new TypeToken<List<Integer>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get empty array value []
     *
     * @return the List&lt;Integer&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Integer> getEmpty() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getEmpty();
            ServiceResponse<List<Integer>> response = getEmptyDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get empty array value []
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getEmptyAsync(final ServiceCallback<List<Integer>> serviceCallback) {
        Call<ResponseBody> call = service.getEmpty();
        call.enqueue(new ServiceResponseCallback<List<Integer>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getEmptyDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Integer>> getEmptyDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Integer>>()
                .register(200, new TypeToken<List<Integer>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Set array value empty []
     *
     * @param arrayBody the List&lt;String&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putEmpty(List<String> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            Call<ResponseBody> call = service.putEmpty(arrayBody);
            ServiceResponse<Void> response = putEmptyDelegate(call.execute(), null);
            response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Set array value empty []
     *
     * @param arrayBody the List&lt;String&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putEmptyAsync(List<String> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        Call<ResponseBody> call = service.putEmpty(arrayBody);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(putEmptyDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> putEmptyDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get boolean array value [true, false, false, true]
     *
     * @return the List&lt;Boolean&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Boolean> getBooleanTfft() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getBooleanTfft();
            ServiceResponse<List<Boolean>> response = getBooleanTfftDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get boolean array value [true, false, false, true]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getBooleanTfftAsync(final ServiceCallback<List<Boolean>> serviceCallback) {
        Call<ResponseBody> call = service.getBooleanTfft();
        call.enqueue(new ServiceResponseCallback<List<Boolean>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getBooleanTfftDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Boolean>> getBooleanTfftDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Boolean>>()
                .register(200, new TypeToken<List<Boolean>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Set array value empty [true, false, false, true]
     *
     * @param arrayBody the List&lt;Boolean&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putBooleanTfft(List<Boolean> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            Call<ResponseBody> call = service.putBooleanTfft(arrayBody);
            ServiceResponse<Void> response = putBooleanTfftDelegate(call.execute(), null);
            response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Set array value empty [true, false, false, true]
     *
     * @param arrayBody the List&lt;Boolean&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putBooleanTfftAsync(List<Boolean> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        Call<ResponseBody> call = service.putBooleanTfft(arrayBody);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(putBooleanTfftDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> putBooleanTfftDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get boolean array value [true, null, false]
     *
     * @return the List&lt;Boolean&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Boolean> getBooleanInvalidNull() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getBooleanInvalidNull();
            ServiceResponse<List<Boolean>> response = getBooleanInvalidNullDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get boolean array value [true, null, false]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getBooleanInvalidNullAsync(final ServiceCallback<List<Boolean>> serviceCallback) {
        Call<ResponseBody> call = service.getBooleanInvalidNull();
        call.enqueue(new ServiceResponseCallback<List<Boolean>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getBooleanInvalidNullDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Boolean>> getBooleanInvalidNullDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Boolean>>()
                .register(200, new TypeToken<List<Boolean>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get boolean array value [true, 'boolean', false]
     *
     * @return the List&lt;Boolean&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Boolean> getBooleanInvalidString() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getBooleanInvalidString();
            ServiceResponse<List<Boolean>> response = getBooleanInvalidStringDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get boolean array value [true, 'boolean', false]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getBooleanInvalidStringAsync(final ServiceCallback<List<Boolean>> serviceCallback) {
        Call<ResponseBody> call = service.getBooleanInvalidString();
        call.enqueue(new ServiceResponseCallback<List<Boolean>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getBooleanInvalidStringDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Boolean>> getBooleanInvalidStringDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Boolean>>()
                .register(200, new TypeToken<List<Boolean>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get integer array value [1, -1, 3, 300]
     *
     * @return the List&lt;Integer&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Integer> getIntegerValid() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getIntegerValid();
            ServiceResponse<List<Integer>> response = getIntegerValidDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get integer array value [1, -1, 3, 300]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getIntegerValidAsync(final ServiceCallback<List<Integer>> serviceCallback) {
        Call<ResponseBody> call = service.getIntegerValid();
        call.enqueue(new ServiceResponseCallback<List<Integer>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getIntegerValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Integer>> getIntegerValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Integer>>()
                .register(200, new TypeToken<List<Integer>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Set array value empty [1, -1, 3, 300]
     *
     * @param arrayBody the List&lt;Integer&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putIntegerValid(List<Integer> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            Call<ResponseBody> call = service.putIntegerValid(arrayBody);
            ServiceResponse<Void> response = putIntegerValidDelegate(call.execute(), null);
            response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Set array value empty [1, -1, 3, 300]
     *
     * @param arrayBody the List&lt;Integer&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putIntegerValidAsync(List<Integer> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        Call<ResponseBody> call = service.putIntegerValid(arrayBody);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(putIntegerValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> putIntegerValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get integer array value [1, null, 0]
     *
     * @return the List&lt;Integer&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Integer> getIntInvalidNull() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getIntInvalidNull();
            ServiceResponse<List<Integer>> response = getIntInvalidNullDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get integer array value [1, null, 0]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getIntInvalidNullAsync(final ServiceCallback<List<Integer>> serviceCallback) {
        Call<ResponseBody> call = service.getIntInvalidNull();
        call.enqueue(new ServiceResponseCallback<List<Integer>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getIntInvalidNullDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Integer>> getIntInvalidNullDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Integer>>()
                .register(200, new TypeToken<List<Integer>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get integer array value [1, 'integer', 0]
     *
     * @return the List&lt;Integer&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Integer> getIntInvalidString() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getIntInvalidString();
            ServiceResponse<List<Integer>> response = getIntInvalidStringDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get integer array value [1, 'integer', 0]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getIntInvalidStringAsync(final ServiceCallback<List<Integer>> serviceCallback) {
        Call<ResponseBody> call = service.getIntInvalidString();
        call.enqueue(new ServiceResponseCallback<List<Integer>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getIntInvalidStringDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Integer>> getIntInvalidStringDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Integer>>()
                .register(200, new TypeToken<List<Integer>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get integer array value [1, -1, 3, 300]
     *
     * @return the List&lt;Long&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Long> getLongValid() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getLongValid();
            ServiceResponse<List<Long>> response = getLongValidDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get integer array value [1, -1, 3, 300]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getLongValidAsync(final ServiceCallback<List<Long>> serviceCallback) {
        Call<ResponseBody> call = service.getLongValid();
        call.enqueue(new ServiceResponseCallback<List<Long>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getLongValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Long>> getLongValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Long>>()
                .register(200, new TypeToken<List<Long>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Set array value empty [1, -1, 3, 300]
     *
     * @param arrayBody the List&lt;Long&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putLongValid(List<Long> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            Call<ResponseBody> call = service.putLongValid(arrayBody);
            ServiceResponse<Void> response = putLongValidDelegate(call.execute(), null);
            response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Set array value empty [1, -1, 3, 300]
     *
     * @param arrayBody the List&lt;Long&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putLongValidAsync(List<Long> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        Call<ResponseBody> call = service.putLongValid(arrayBody);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(putLongValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> putLongValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get long array value [1, null, 0]
     *
     * @return the List&lt;Long&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Long> getLongInvalidNull() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getLongInvalidNull();
            ServiceResponse<List<Long>> response = getLongInvalidNullDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get long array value [1, null, 0]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getLongInvalidNullAsync(final ServiceCallback<List<Long>> serviceCallback) {
        Call<ResponseBody> call = service.getLongInvalidNull();
        call.enqueue(new ServiceResponseCallback<List<Long>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getLongInvalidNullDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Long>> getLongInvalidNullDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Long>>()
                .register(200, new TypeToken<List<Long>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get long array value [1, 'integer', 0]
     *
     * @return the List&lt;Long&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Long> getLongInvalidString() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getLongInvalidString();
            ServiceResponse<List<Long>> response = getLongInvalidStringDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get long array value [1, 'integer', 0]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getLongInvalidStringAsync(final ServiceCallback<List<Long>> serviceCallback) {
        Call<ResponseBody> call = service.getLongInvalidString();
        call.enqueue(new ServiceResponseCallback<List<Long>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getLongInvalidStringDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Long>> getLongInvalidStringDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Long>>()
                .register(200, new TypeToken<List<Long>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get float array value [0, -0.01, 1.2e20]
     *
     * @return the List&lt;Double&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Double> getFloatValid() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getFloatValid();
            ServiceResponse<List<Double>> response = getFloatValidDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get float array value [0, -0.01, 1.2e20]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getFloatValidAsync(final ServiceCallback<List<Double>> serviceCallback) {
        Call<ResponseBody> call = service.getFloatValid();
        call.enqueue(new ServiceResponseCallback<List<Double>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getFloatValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Double>> getFloatValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Double>>()
                .register(200, new TypeToken<List<Double>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Set array value [0, -0.01, 1.2e20]
     *
     * @param arrayBody the List&lt;Double&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putFloatValid(List<Double> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            Call<ResponseBody> call = service.putFloatValid(arrayBody);
            ServiceResponse<Void> response = putFloatValidDelegate(call.execute(), null);
            response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Set array value [0, -0.01, 1.2e20]
     *
     * @param arrayBody the List&lt;Double&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putFloatValidAsync(List<Double> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        Call<ResponseBody> call = service.putFloatValid(arrayBody);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(putFloatValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> putFloatValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get float array value [0.0, null, -1.2e20]
     *
     * @return the List&lt;Double&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Double> getFloatInvalidNull() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getFloatInvalidNull();
            ServiceResponse<List<Double>> response = getFloatInvalidNullDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get float array value [0.0, null, -1.2e20]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getFloatInvalidNullAsync(final ServiceCallback<List<Double>> serviceCallback) {
        Call<ResponseBody> call = service.getFloatInvalidNull();
        call.enqueue(new ServiceResponseCallback<List<Double>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getFloatInvalidNullDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Double>> getFloatInvalidNullDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Double>>()
                .register(200, new TypeToken<List<Double>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0]
     *
     * @return the List&lt;Double&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Double> getFloatInvalidString() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getFloatInvalidString();
            ServiceResponse<List<Double>> response = getFloatInvalidStringDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getFloatInvalidStringAsync(final ServiceCallback<List<Double>> serviceCallback) {
        Call<ResponseBody> call = service.getFloatInvalidString();
        call.enqueue(new ServiceResponseCallback<List<Double>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getFloatInvalidStringDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Double>> getFloatInvalidStringDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Double>>()
                .register(200, new TypeToken<List<Double>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get float array value [0, -0.01, 1.2e20]
     *
     * @return the List&lt;Double&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Double> getDoubleValid() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getDoubleValid();
            ServiceResponse<List<Double>> response = getDoubleValidDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get float array value [0, -0.01, 1.2e20]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getDoubleValidAsync(final ServiceCallback<List<Double>> serviceCallback) {
        Call<ResponseBody> call = service.getDoubleValid();
        call.enqueue(new ServiceResponseCallback<List<Double>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getDoubleValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Double>> getDoubleValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Double>>()
                .register(200, new TypeToken<List<Double>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Set array value [0, -0.01, 1.2e20]
     *
     * @param arrayBody the List&lt;Double&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putDoubleValid(List<Double> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            Call<ResponseBody> call = service.putDoubleValid(arrayBody);
            ServiceResponse<Void> response = putDoubleValidDelegate(call.execute(), null);
            response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Set array value [0, -0.01, 1.2e20]
     *
     * @param arrayBody the List&lt;Double&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putDoubleValidAsync(List<Double> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        Call<ResponseBody> call = service.putDoubleValid(arrayBody);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(putDoubleValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> putDoubleValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get float array value [0.0, null, -1.2e20]
     *
     * @return the List&lt;Double&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Double> getDoubleInvalidNull() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getDoubleInvalidNull();
            ServiceResponse<List<Double>> response = getDoubleInvalidNullDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get float array value [0.0, null, -1.2e20]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getDoubleInvalidNullAsync(final ServiceCallback<List<Double>> serviceCallback) {
        Call<ResponseBody> call = service.getDoubleInvalidNull();
        call.enqueue(new ServiceResponseCallback<List<Double>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getDoubleInvalidNullDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Double>> getDoubleInvalidNullDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Double>>()
                .register(200, new TypeToken<List<Double>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0]
     *
     * @return the List&lt;Double&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Double> getDoubleInvalidString() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getDoubleInvalidString();
            ServiceResponse<List<Double>> response = getDoubleInvalidStringDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get boolean array value [1.0, 'number', 0.0]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getDoubleInvalidStringAsync(final ServiceCallback<List<Double>> serviceCallback) {
        Call<ResponseBody> call = service.getDoubleInvalidString();
        call.enqueue(new ServiceResponseCallback<List<Double>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getDoubleInvalidStringDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Double>> getDoubleInvalidStringDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Double>>()
                .register(200, new TypeToken<List<Double>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get string array value ['foo1', 'foo2', 'foo3']
     *
     * @return the List&lt;String&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<String> getStringValid() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getStringValid();
            ServiceResponse<List<String>> response = getStringValidDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get string array value ['foo1', 'foo2', 'foo3']
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getStringValidAsync(final ServiceCallback<List<String>> serviceCallback) {
        Call<ResponseBody> call = service.getStringValid();
        call.enqueue(new ServiceResponseCallback<List<String>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getStringValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<String>> getStringValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<String>>()
                .register(200, new TypeToken<List<String>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Set array value ['foo1', 'foo2', 'foo3']
     *
     * @param arrayBody the List&lt;String&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putStringValid(List<String> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            Call<ResponseBody> call = service.putStringValid(arrayBody);
            ServiceResponse<Void> response = putStringValidDelegate(call.execute(), null);
            response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Set array value ['foo1', 'foo2', 'foo3']
     *
     * @param arrayBody the List&lt;String&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putStringValidAsync(List<String> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        Call<ResponseBody> call = service.putStringValid(arrayBody);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(putStringValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> putStringValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get string array value ['foo', null, 'foo2']
     *
     * @return the List&lt;String&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<String> getStringWithNull() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getStringWithNull();
            ServiceResponse<List<String>> response = getStringWithNullDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get string array value ['foo', null, 'foo2']
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getStringWithNullAsync(final ServiceCallback<List<String>> serviceCallback) {
        Call<ResponseBody> call = service.getStringWithNull();
        call.enqueue(new ServiceResponseCallback<List<String>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getStringWithNullDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<String>> getStringWithNullDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<String>>()
                .register(200, new TypeToken<List<String>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get string array value ['foo', 123, 'foo2']
     *
     * @return the List&lt;String&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<String> getStringWithInvalid() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getStringWithInvalid();
            ServiceResponse<List<String>> response = getStringWithInvalidDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get string array value ['foo', 123, 'foo2']
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getStringWithInvalidAsync(final ServiceCallback<List<String>> serviceCallback) {
        Call<ResponseBody> call = service.getStringWithInvalid();
        call.enqueue(new ServiceResponseCallback<List<String>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getStringWithInvalidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<String>> getStringWithInvalidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<String>>()
                .register(200, new TypeToken<List<String>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get integer array value ['2000-12-01', '1980-01-02', '1492-10-12']
     *
     * @return the List&lt;LocalDate&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<LocalDate> getDateValid() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getDateValid();
            ServiceResponse<List<LocalDate>> response = getDateValidDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get integer array value ['2000-12-01', '1980-01-02', '1492-10-12']
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getDateValidAsync(final ServiceCallback<List<LocalDate>> serviceCallback) {
        Call<ResponseBody> call = service.getDateValid();
        call.enqueue(new ServiceResponseCallback<List<LocalDate>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getDateValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<LocalDate>> getDateValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<LocalDate>>()
                .register(200, new TypeToken<List<LocalDate>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Set array value  ['2000-12-01', '1980-01-02', '1492-10-12']
     *
     * @param arrayBody the List&lt;LocalDate&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putDateValid(List<LocalDate> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            Call<ResponseBody> call = service.putDateValid(arrayBody);
            ServiceResponse<Void> response = putDateValidDelegate(call.execute(), null);
            response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Set array value  ['2000-12-01', '1980-01-02', '1492-10-12']
     *
     * @param arrayBody the List&lt;LocalDate&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putDateValidAsync(List<LocalDate> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        Call<ResponseBody> call = service.putDateValid(arrayBody);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(putDateValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> putDateValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get date array value ['2012-01-01', null, '1776-07-04']
     *
     * @return the List&lt;LocalDate&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<LocalDate> getDateInvalidNull() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getDateInvalidNull();
            ServiceResponse<List<LocalDate>> response = getDateInvalidNullDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get date array value ['2012-01-01', null, '1776-07-04']
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getDateInvalidNullAsync(final ServiceCallback<List<LocalDate>> serviceCallback) {
        Call<ResponseBody> call = service.getDateInvalidNull();
        call.enqueue(new ServiceResponseCallback<List<LocalDate>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getDateInvalidNullDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<LocalDate>> getDateInvalidNullDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<LocalDate>>()
                .register(200, new TypeToken<List<LocalDate>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get date array value ['2011-03-22', 'date']
     *
     * @return the List&lt;LocalDate&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<LocalDate> getDateInvalidChars() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getDateInvalidChars();
            ServiceResponse<List<LocalDate>> response = getDateInvalidCharsDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get date array value ['2011-03-22', 'date']
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getDateInvalidCharsAsync(final ServiceCallback<List<LocalDate>> serviceCallback) {
        Call<ResponseBody> call = service.getDateInvalidChars();
        call.enqueue(new ServiceResponseCallback<List<LocalDate>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getDateInvalidCharsDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<LocalDate>> getDateInvalidCharsDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<LocalDate>>()
                .register(200, new TypeToken<List<LocalDate>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get date-time array value ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00']
     *
     * @return the List&lt;DateTime&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<DateTime> getDateTimeValid() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getDateTimeValid();
            ServiceResponse<List<DateTime>> response = getDateTimeValidDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get date-time array value ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00']
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getDateTimeValidAsync(final ServiceCallback<List<DateTime>> serviceCallback) {
        Call<ResponseBody> call = service.getDateTimeValid();
        call.enqueue(new ServiceResponseCallback<List<DateTime>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getDateTimeValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<DateTime>> getDateTimeValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<DateTime>>()
                .register(200, new TypeToken<List<DateTime>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Set array value  ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00']
     *
     * @param arrayBody the List&lt;DateTime&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putDateTimeValid(List<DateTime> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            Call<ResponseBody> call = service.putDateTimeValid(arrayBody);
            ServiceResponse<Void> response = putDateTimeValidDelegate(call.execute(), null);
            response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Set array value  ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00']
     *
     * @param arrayBody the List&lt;DateTime&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putDateTimeValidAsync(List<DateTime> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        Call<ResponseBody> call = service.putDateTimeValid(arrayBody);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(putDateTimeValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> putDateTimeValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', null]
     *
     * @return the List&lt;DateTime&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<DateTime> getDateTimeInvalidNull() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getDateTimeInvalidNull();
            ServiceResponse<List<DateTime>> response = getDateTimeInvalidNullDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', null]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getDateTimeInvalidNullAsync(final ServiceCallback<List<DateTime>> serviceCallback) {
        Call<ResponseBody> call = service.getDateTimeInvalidNull();
        call.enqueue(new ServiceResponseCallback<List<DateTime>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getDateTimeInvalidNullDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<DateTime>> getDateTimeInvalidNullDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<DateTime>>()
                .register(200, new TypeToken<List<DateTime>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', 'date-time']
     *
     * @return the List&lt;DateTime&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<DateTime> getDateTimeInvalidChars() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getDateTimeInvalidChars();
            ServiceResponse<List<DateTime>> response = getDateTimeInvalidCharsDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get date array value ['2000-12-01t00:00:01z', 'date-time']
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getDateTimeInvalidCharsAsync(final ServiceCallback<List<DateTime>> serviceCallback) {
        Call<ResponseBody> call = service.getDateTimeInvalidChars();
        call.enqueue(new ServiceResponseCallback<List<DateTime>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getDateTimeInvalidCharsDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<DateTime>> getDateTimeInvalidCharsDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<DateTime>>()
                .register(200, new TypeToken<List<DateTime>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get date-time array value ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT']
     *
     * @return the List&lt;DateTimeRfc1123&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<DateTimeRfc1123> getDateTimeRfc1123Valid() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getDateTimeRfc1123Valid();
            ServiceResponse<List<DateTimeRfc1123>> response = getDateTimeRfc1123ValidDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get date-time array value ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT']
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getDateTimeRfc1123ValidAsync(final ServiceCallback<List<DateTimeRfc1123>> serviceCallback) {
        Call<ResponseBody> call = service.getDateTimeRfc1123Valid();
        call.enqueue(new ServiceResponseCallback<List<DateTimeRfc1123>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getDateTimeRfc1123ValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<DateTimeRfc1123>> getDateTimeRfc1123ValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<DateTimeRfc1123>>()
                .register(200, new TypeToken<List<DateTimeRfc1123>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Set array value  ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT']
     *
     * @param arrayBody the List&lt;DateTimeRfc1123&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putDateTimeRfc1123Valid(List<DateTimeRfc1123> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            Call<ResponseBody> call = service.putDateTimeRfc1123Valid(arrayBody);
            ServiceResponse<Void> response = putDateTimeRfc1123ValidDelegate(call.execute(), null);
            response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Set array value  ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT']
     *
     * @param arrayBody the List&lt;DateTimeRfc1123&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putDateTimeRfc1123ValidAsync(List<DateTimeRfc1123> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        Call<ResponseBody> call = service.putDateTimeRfc1123Valid(arrayBody);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(putDateTimeRfc1123ValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> putDateTimeRfc1123ValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get duration array value ['P123DT22H14M12.011S', 'P5DT1H0M0S']
     *
     * @return the List&lt;Period&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Period> getDurationValid() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getDurationValid();
            ServiceResponse<List<Period>> response = getDurationValidDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get duration array value ['P123DT22H14M12.011S', 'P5DT1H0M0S']
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getDurationValidAsync(final ServiceCallback<List<Period>> serviceCallback) {
        Call<ResponseBody> call = service.getDurationValid();
        call.enqueue(new ServiceResponseCallback<List<Period>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getDurationValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Period>> getDurationValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Period>>()
                .register(200, new TypeToken<List<Period>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Set array value  ['P123DT22H14M12.011S', 'P5DT1H0M0S']
     *
     * @param arrayBody the List&lt;Period&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putDurationValid(List<Period> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            Call<ResponseBody> call = service.putDurationValid(arrayBody);
            ServiceResponse<Void> response = putDurationValidDelegate(call.execute(), null);
            response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Set array value  ['P123DT22H14M12.011S', 'P5DT1H0M0S']
     *
     * @param arrayBody the List&lt;Period&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putDurationValidAsync(List<Period> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        Call<ResponseBody> call = service.putDurationValid(arrayBody);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(putDurationValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> putDurationValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get byte array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each item encoded in base64
     *
     * @return the List&lt;byte[]&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<byte[]> getByteValid() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getByteValid();
            ServiceResponse<List<byte[]>> response = getByteValidDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get byte array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each item encoded in base64
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getByteValidAsync(final ServiceCallback<List<byte[]>> serviceCallback) {
        Call<ResponseBody> call = service.getByteValid();
        call.enqueue(new ServiceResponseCallback<List<byte[]>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getByteValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<byte[]>> getByteValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<byte[]>>()
                .register(200, new TypeToken<List<byte[]>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Put the array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each elementencoded in base 64
     *
     * @param arrayBody the List&lt;byte[]&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putByteValid(List<byte[]> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            Call<ResponseBody> call = service.putByteValid(arrayBody);
            ServiceResponse<Void> response = putByteValidDelegate(call.execute(), null);
            response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Put the array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each elementencoded in base 64
     *
     * @param arrayBody the List&lt;byte[]&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putByteValidAsync(List<byte[]> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        Call<ResponseBody> call = service.putByteValid(arrayBody);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(putByteValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> putByteValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get byte array value [hex(AB, AC, AD), null] with the first item base64 encoded
     *
     * @return the List&lt;byte[]&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<byte[]> getByteInvalidNull() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getByteInvalidNull();
            ServiceResponse<List<byte[]>> response = getByteInvalidNullDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get byte array value [hex(AB, AC, AD), null] with the first item base64 encoded
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getByteInvalidNullAsync(final ServiceCallback<List<byte[]>> serviceCallback) {
        Call<ResponseBody> call = service.getByteInvalidNull();
        call.enqueue(new ServiceResponseCallback<List<byte[]>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getByteInvalidNullDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<byte[]>> getByteInvalidNullDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<byte[]>>()
                .register(200, new TypeToken<List<byte[]>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get array of complex type null value
     *
     * @return the List&lt;Product&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Product> getComplexNull() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getComplexNull();
            ServiceResponse<List<Product>> response = getComplexNullDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get array of complex type null value
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getComplexNullAsync(final ServiceCallback<List<Product>> serviceCallback) {
        Call<ResponseBody> call = service.getComplexNull();
        call.enqueue(new ServiceResponseCallback<List<Product>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getComplexNullDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Product>> getComplexNullDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Product>>()
                .register(200, new TypeToken<List<Product>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get empty array of complex type []
     *
     * @return the List&lt;Product&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Product> getComplexEmpty() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getComplexEmpty();
            ServiceResponse<List<Product>> response = getComplexEmptyDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get empty array of complex type []
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getComplexEmptyAsync(final ServiceCallback<List<Product>> serviceCallback) {
        Call<ResponseBody> call = service.getComplexEmpty();
        call.enqueue(new ServiceResponseCallback<List<Product>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getComplexEmptyDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Product>> getComplexEmptyDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Product>>()
                .register(200, new TypeToken<List<Product>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get array of complex type with null item [{'integer': 1 'string': '2'}, null, {'integer': 5, 'string': '6'}]
     *
     * @return the List&lt;Product&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Product> getComplexItemNull() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getComplexItemNull();
            ServiceResponse<List<Product>> response = getComplexItemNullDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get array of complex type with null item [{'integer': 1 'string': '2'}, null, {'integer': 5, 'string': '6'}]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getComplexItemNullAsync(final ServiceCallback<List<Product>> serviceCallback) {
        Call<ResponseBody> call = service.getComplexItemNull();
        call.enqueue(new ServiceResponseCallback<List<Product>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getComplexItemNullDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Product>> getComplexItemNullDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Product>>()
                .register(200, new TypeToken<List<Product>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get array of complex type with empty item [{'integer': 1 'string': '2'}, {}, {'integer': 5, 'string': '6'}]
     *
     * @return the List&lt;Product&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Product> getComplexItemEmpty() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getComplexItemEmpty();
            ServiceResponse<List<Product>> response = getComplexItemEmptyDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get array of complex type with empty item [{'integer': 1 'string': '2'}, {}, {'integer': 5, 'string': '6'}]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getComplexItemEmptyAsync(final ServiceCallback<List<Product>> serviceCallback) {
        Call<ResponseBody> call = service.getComplexItemEmpty();
        call.enqueue(new ServiceResponseCallback<List<Product>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getComplexItemEmptyDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Product>> getComplexItemEmptyDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Product>>()
                .register(200, new TypeToken<List<Product>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get array of complex type with [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}]
     *
     * @return the List&lt;Product&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Product> getComplexValid() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getComplexValid();
            ServiceResponse<List<Product>> response = getComplexValidDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get array of complex type with [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getComplexValidAsync(final ServiceCallback<List<Product>> serviceCallback) {
        Call<ResponseBody> call = service.getComplexValid();
        call.enqueue(new ServiceResponseCallback<List<Product>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getComplexValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Product>> getComplexValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Product>>()
                .register(200, new TypeToken<List<Product>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Put an array of complex type with values [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}]
     *
     * @param arrayBody the List&lt;Product&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putComplexValid(List<Product> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            Call<ResponseBody> call = service.putComplexValid(arrayBody);
            ServiceResponse<Void> response = putComplexValidDelegate(call.execute(), null);
            response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Put an array of complex type with values [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}]
     *
     * @param arrayBody the List&lt;Product&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putComplexValidAsync(List<Product> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        Call<ResponseBody> call = service.putComplexValid(arrayBody);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(putComplexValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> putComplexValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get a null array
     *
     * @return the List&lt;List&lt;String&gt;&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<List<String>> getArrayNull() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getArrayNull();
            ServiceResponse<List<List<String>>> response = getArrayNullDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get a null array
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getArrayNullAsync(final ServiceCallback<List<List<String>>> serviceCallback) {
        Call<ResponseBody> call = service.getArrayNull();
        call.enqueue(new ServiceResponseCallback<List<List<String>>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getArrayNullDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<List<String>>> getArrayNullDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<List<String>>>()
                .register(200, new TypeToken<List<List<String>>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get an empty array []
     *
     * @return the List&lt;List&lt;String&gt;&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<List<String>> getArrayEmpty() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getArrayEmpty();
            ServiceResponse<List<List<String>>> response = getArrayEmptyDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get an empty array []
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getArrayEmptyAsync(final ServiceCallback<List<List<String>>> serviceCallback) {
        Call<ResponseBody> call = service.getArrayEmpty();
        call.enqueue(new ServiceResponseCallback<List<List<String>>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getArrayEmptyDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<List<String>>> getArrayEmptyDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<List<String>>>()
                .register(200, new TypeToken<List<List<String>>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], null, ['7', '8', '9']]
     *
     * @return the List&lt;List&lt;String&gt;&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<List<String>> getArrayItemNull() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getArrayItemNull();
            ServiceResponse<List<List<String>>> response = getArrayItemNullDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], null, ['7', '8', '9']]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getArrayItemNullAsync(final ServiceCallback<List<List<String>>> serviceCallback) {
        Call<ResponseBody> call = service.getArrayItemNull();
        call.enqueue(new ServiceResponseCallback<List<List<String>>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getArrayItemNullDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<List<String>>> getArrayItemNullDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<List<String>>>()
                .register(200, new TypeToken<List<List<String>>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], [], ['7', '8', '9']]
     *
     * @return the List&lt;List&lt;String&gt;&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<List<String>> getArrayItemEmpty() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getArrayItemEmpty();
            ServiceResponse<List<List<String>>> response = getArrayItemEmptyDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], [], ['7', '8', '9']]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getArrayItemEmptyAsync(final ServiceCallback<List<List<String>>> serviceCallback) {
        Call<ResponseBody> call = service.getArrayItemEmpty();
        call.enqueue(new ServiceResponseCallback<List<List<String>>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getArrayItemEmptyDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<List<String>>> getArrayItemEmptyDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<List<String>>>()
                .register(200, new TypeToken<List<List<String>>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']]
     *
     * @return the List&lt;List&lt;String&gt;&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<List<String>> getArrayValid() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getArrayValid();
            ServiceResponse<List<List<String>>> response = getArrayValidDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get an array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getArrayValidAsync(final ServiceCallback<List<List<String>>> serviceCallback) {
        Call<ResponseBody> call = service.getArrayValid();
        call.enqueue(new ServiceResponseCallback<List<List<String>>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getArrayValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<List<String>>> getArrayValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<List<String>>>()
                .register(200, new TypeToken<List<List<String>>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Put An array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']]
     *
     * @param arrayBody the List&lt;List&lt;String&gt;&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putArrayValid(List<List<String>> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            Call<ResponseBody> call = service.putArrayValid(arrayBody);
            ServiceResponse<Void> response = putArrayValidDelegate(call.execute(), null);
            response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Put An array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']]
     *
     * @param arrayBody the List&lt;List&lt;String&gt;&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putArrayValidAsync(List<List<String>> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        Call<ResponseBody> call = service.putArrayValid(arrayBody);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(putArrayValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> putArrayValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get an array of Dictionaries with value null
     *
     * @return the List&lt;Map&lt;String, String&gt;&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Map<String, String>> getDictionaryNull() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getDictionaryNull();
            ServiceResponse<List<Map<String, String>>> response = getDictionaryNullDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get an array of Dictionaries with value null
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getDictionaryNullAsync(final ServiceCallback<List<Map<String, String>>> serviceCallback) {
        Call<ResponseBody> call = service.getDictionaryNull();
        call.enqueue(new ServiceResponseCallback<List<Map<String, String>>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getDictionaryNullDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Map<String, String>>> getDictionaryNullDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Map<String, String>>>()
                .register(200, new TypeToken<List<Map<String, String>>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value []
     *
     * @return the List&lt;Map&lt;String, String&gt;&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Map<String, String>> getDictionaryEmpty() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getDictionaryEmpty();
            ServiceResponse<List<Map<String, String>>> response = getDictionaryEmptyDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value []
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getDictionaryEmptyAsync(final ServiceCallback<List<Map<String, String>>> serviceCallback) {
        Call<ResponseBody> call = service.getDictionaryEmpty();
        call.enqueue(new ServiceResponseCallback<List<Map<String, String>>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getDictionaryEmptyDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Map<String, String>>> getDictionaryEmptyDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Map<String, String>>>()
                .register(200, new TypeToken<List<Map<String, String>>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, null, {'7': 'seven', '8': 'eight', '9': 'nine'}]
     *
     * @return the List&lt;Map&lt;String, String&gt;&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Map<String, String>> getDictionaryItemNull() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getDictionaryItemNull();
            ServiceResponse<List<Map<String, String>>> response = getDictionaryItemNullDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, null, {'7': 'seven', '8': 'eight', '9': 'nine'}]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getDictionaryItemNullAsync(final ServiceCallback<List<Map<String, String>>> serviceCallback) {
        Call<ResponseBody> call = service.getDictionaryItemNull();
        call.enqueue(new ServiceResponseCallback<List<Map<String, String>>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getDictionaryItemNullDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Map<String, String>>> getDictionaryItemNullDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Map<String, String>>>()
                .register(200, new TypeToken<List<Map<String, String>>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {}, {'7': 'seven', '8': 'eight', '9': 'nine'}]
     *
     * @return the List&lt;Map&lt;String, String&gt;&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Map<String, String>> getDictionaryItemEmpty() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getDictionaryItemEmpty();
            ServiceResponse<List<Map<String, String>>> response = getDictionaryItemEmptyDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {}, {'7': 'seven', '8': 'eight', '9': 'nine'}]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getDictionaryItemEmptyAsync(final ServiceCallback<List<Map<String, String>>> serviceCallback) {
        Call<ResponseBody> call = service.getDictionaryItemEmpty();
        call.enqueue(new ServiceResponseCallback<List<Map<String, String>>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getDictionaryItemEmptyDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Map<String, String>>> getDictionaryItemEmptyDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Map<String, String>>>()
                .register(200, new TypeToken<List<Map<String, String>>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}]
     *
     * @return the List&lt;Map&lt;String, String&gt;&gt; object if successful.
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public List<Map<String, String>> getDictionaryValid() throws ServiceException {
        try {
            Call<ResponseBody> call = service.getDictionaryValid();
            ServiceResponse<List<Map<String, String>>> response = getDictionaryValidDelegate(call.execute(), null);
            return response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}]
     *
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> getDictionaryValidAsync(final ServiceCallback<List<Map<String, String>>> serviceCallback) {
        Call<ResponseBody> call = service.getDictionaryValid();
        call.enqueue(new ServiceResponseCallback<List<Map<String, String>>>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(getDictionaryValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<List<Map<String, String>>> getDictionaryValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<List<Map<String, String>>>()
                .register(200, new TypeToken<List<Map<String, String>>>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}]
     *
     * @param arrayBody the List&lt;Map&lt;String, String&gt;&gt; value
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void putDictionaryValid(List<Map<String, String>> arrayBody) throws ServiceException {
        if (arrayBody == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null."));
        }
        Validator.validate(arrayBody);
        try {
            Call<ResponseBody> call = service.putDictionaryValid(arrayBody);
            ServiceResponse<Void> response = putDictionaryValidDelegate(call.execute(), null);
            response.getBody();
        } catch (ServiceException ex) {
            throw ex;
        } catch (Exception ex) {
            throw new ServiceException(ex);
        }
    }

    /**
     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}]
     *
     * @param arrayBody the List&lt;Map&lt;String, String&gt;&gt; value
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public Call<ResponseBody> putDictionaryValidAsync(List<Map<String, String>> arrayBody, final ServiceCallback<Void> serviceCallback) {
        if (arrayBody == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter arrayBody is required and cannot be null.")));
        }
        Validator.validate(arrayBody, serviceCallback);
        Call<ResponseBody> call = service.putDictionaryValid(arrayBody);
        call.enqueue(new ServiceResponseCallback<Void>(serviceCallback) {
            @Override
            public void onResponse(Response<ResponseBody> response, Retrofit retrofit) {
                try {
                    serviceCallback.success(putDictionaryValidDelegate(response, retrofit));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
        return call;
    }

    private ServiceResponse<Void> putDictionaryValidDelegate(Response<ResponseBody> response, Retrofit retrofit) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, retrofit);
    }

}
