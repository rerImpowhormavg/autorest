/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 * 
 * Code generated by Microsoft (R) AutoRest Code Generator 0.11.0.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package fixtures.url;

import com.google.gson.reflect.TypeToken;
import com.microsoft.rest.ServiceCallback;
import com.microsoft.rest.ServiceException;
import com.microsoft.rest.ServiceResponse;
import com.microsoft.rest.ServiceResponseBuilder;
import com.microsoft.rest.ServiceResponseCallback;
import retrofit.RestAdapter;
import retrofit.RetrofitError;
import retrofit.client.Response;
import fixtures.url.models.Error;

public class PathItemsImpl implements PathItems {
    private PathItemsService service;
    AutoRestUrlTestService client;

    public PathItemsImpl(RestAdapter restAdapter, AutoRestUrlTestService client) {
        this.service = restAdapter.create(PathItemsService.class);
        this.client = client;
    }

    /**
     * send globalStringPath='globalStringPath', pathItemStringPath='pathItemStringPath', localStringPath='localStringPath', globalStringQuery='globalStringQuery', pathItemStringQuery='pathItemStringQuery', localStringQuery='localStringQuery'
     *
     * @param localStringPath should contain value 'localStringPath'
     * @param pathItemStringPath A string value 'pathItemStringPath' that appears in the path
     * @param localStringQuery should contain value 'localStringQuery'
     * @param pathItemStringQuery A string value 'pathItemStringQuery' that appears as a query parameter
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void getAllWithValues(String localStringPath, String pathItemStringPath, String localStringQuery, String pathItemStringQuery) throws ServiceException {
        if (localStringPath == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter localStringPath is required and cannot be null."));
        }
        if (pathItemStringPath == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter pathItemStringPath is required and cannot be null."));
        }
        if (this.client.getGlobalStringPath() == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter this.client.getGlobalStringPath() is required and cannot be null."));
        }
        try {
            ServiceResponse<Void> response = getAllWithValuesDelegate(service.getAllWithValues(localStringPath, localStringQuery, pathItemStringPath, pathItemStringQuery, this.client.getGlobalStringPath(), this.client.getGlobalStringQuery()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = getAllWithValuesDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * send globalStringPath='globalStringPath', pathItemStringPath='pathItemStringPath', localStringPath='localStringPath', globalStringQuery='globalStringQuery', pathItemStringQuery='pathItemStringQuery', localStringQuery='localStringQuery'
     *
     * @param localStringPath should contain value 'localStringPath'
     * @param pathItemStringPath A string value 'pathItemStringPath' that appears in the path
     * @param localStringQuery should contain value 'localStringQuery'
     * @param pathItemStringQuery A string value 'pathItemStringQuery' that appears as a query parameter
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getAllWithValuesAsync(String localStringPath, String pathItemStringPath, String localStringQuery, String pathItemStringQuery, final ServiceCallback<Void> serviceCallback) {
        if (localStringPath == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter localStringPath is required and cannot be null.")));
        }
        if (pathItemStringPath == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter pathItemStringPath is required and cannot be null.")));
        }
        if (this.client.getGlobalStringPath() == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter this.client.getGlobalStringPath() is required and cannot be null.")));
        }
        service.getAllWithValuesAsync(localStringPath, localStringQuery, pathItemStringPath, pathItemStringQuery, this.client.getGlobalStringPath(), this.client.getGlobalStringQuery(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getAllWithValuesDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> getAllWithValuesDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * send globalStringPath='globalStringPath', pathItemStringPath='pathItemStringPath', localStringPath='localStringPath', globalStringQuery=null, pathItemStringQuery='pathItemStringQuery', localStringQuery='localStringQuery'
     *
     * @param localStringPath should contain value 'localStringPath'
     * @param pathItemStringPath A string value 'pathItemStringPath' that appears in the path
     * @param localStringQuery should contain value 'localStringQuery'
     * @param pathItemStringQuery A string value 'pathItemStringQuery' that appears as a query parameter
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void getGlobalQueryNull(String localStringPath, String pathItemStringPath, String localStringQuery, String pathItemStringQuery) throws ServiceException {
        if (localStringPath == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter localStringPath is required and cannot be null."));
        }
        if (pathItemStringPath == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter pathItemStringPath is required and cannot be null."));
        }
        if (this.client.getGlobalStringPath() == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter this.client.getGlobalStringPath() is required and cannot be null."));
        }
        try {
            ServiceResponse<Void> response = getGlobalQueryNullDelegate(service.getGlobalQueryNull(localStringPath, localStringQuery, pathItemStringPath, pathItemStringQuery, this.client.getGlobalStringPath(), this.client.getGlobalStringQuery()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = getGlobalQueryNullDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * send globalStringPath='globalStringPath', pathItemStringPath='pathItemStringPath', localStringPath='localStringPath', globalStringQuery=null, pathItemStringQuery='pathItemStringQuery', localStringQuery='localStringQuery'
     *
     * @param localStringPath should contain value 'localStringPath'
     * @param pathItemStringPath A string value 'pathItemStringPath' that appears in the path
     * @param localStringQuery should contain value 'localStringQuery'
     * @param pathItemStringQuery A string value 'pathItemStringQuery' that appears as a query parameter
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getGlobalQueryNullAsync(String localStringPath, String pathItemStringPath, String localStringQuery, String pathItemStringQuery, final ServiceCallback<Void> serviceCallback) {
        if (localStringPath == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter localStringPath is required and cannot be null.")));
        }
        if (pathItemStringPath == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter pathItemStringPath is required and cannot be null.")));
        }
        if (this.client.getGlobalStringPath() == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter this.client.getGlobalStringPath() is required and cannot be null.")));
        }
        service.getGlobalQueryNullAsync(localStringPath, localStringQuery, pathItemStringPath, pathItemStringQuery, this.client.getGlobalStringPath(), this.client.getGlobalStringQuery(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getGlobalQueryNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> getGlobalQueryNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * send globalStringPath=globalStringPath, pathItemStringPath='pathItemStringPath', localStringPath='localStringPath', globalStringQuery=null, pathItemStringQuery='pathItemStringQuery', localStringQuery=null
     *
     * @param localStringPath should contain value 'localStringPath'
     * @param pathItemStringPath A string value 'pathItemStringPath' that appears in the path
     * @param localStringQuery should contain null value
     * @param pathItemStringQuery A string value 'pathItemStringQuery' that appears as a query parameter
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void getGlobalAndLocalQueryNull(String localStringPath, String pathItemStringPath, String localStringQuery, String pathItemStringQuery) throws ServiceException {
        if (localStringPath == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter localStringPath is required and cannot be null."));
        }
        if (pathItemStringPath == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter pathItemStringPath is required and cannot be null."));
        }
        if (this.client.getGlobalStringPath() == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter this.client.getGlobalStringPath() is required and cannot be null."));
        }
        try {
            ServiceResponse<Void> response = getGlobalAndLocalQueryNullDelegate(service.getGlobalAndLocalQueryNull(localStringPath, localStringQuery, pathItemStringPath, pathItemStringQuery, this.client.getGlobalStringPath(), this.client.getGlobalStringQuery()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = getGlobalAndLocalQueryNullDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * send globalStringPath=globalStringPath, pathItemStringPath='pathItemStringPath', localStringPath='localStringPath', globalStringQuery=null, pathItemStringQuery='pathItemStringQuery', localStringQuery=null
     *
     * @param localStringPath should contain value 'localStringPath'
     * @param pathItemStringPath A string value 'pathItemStringPath' that appears in the path
     * @param localStringQuery should contain null value
     * @param pathItemStringQuery A string value 'pathItemStringQuery' that appears as a query parameter
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getGlobalAndLocalQueryNullAsync(String localStringPath, String pathItemStringPath, String localStringQuery, String pathItemStringQuery, final ServiceCallback<Void> serviceCallback) {
        if (localStringPath == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter localStringPath is required and cannot be null.")));
        }
        if (pathItemStringPath == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter pathItemStringPath is required and cannot be null.")));
        }
        if (this.client.getGlobalStringPath() == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter this.client.getGlobalStringPath() is required and cannot be null.")));
        }
        service.getGlobalAndLocalQueryNullAsync(localStringPath, localStringQuery, pathItemStringPath, pathItemStringQuery, this.client.getGlobalStringPath(), this.client.getGlobalStringQuery(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getGlobalAndLocalQueryNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> getGlobalAndLocalQueryNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

    /**
     * send globalStringPath='globalStringPath', pathItemStringPath='pathItemStringPath', localStringPath='localStringPath', globalStringQuery='globalStringQuery', pathItemStringQuery=null, localStringQuery=null
     *
     * @param localStringPath should contain value 'localStringPath'
     * @param pathItemStringPath A string value 'pathItemStringPath' that appears in the path
     * @param localStringQuery should contain value null
     * @param pathItemStringQuery should contain value null
     * @throws ServiceException the exception wrapped in ServiceException if failed.
     */
    public void getLocalPathItemQueryNull(String localStringPath, String pathItemStringPath, String localStringQuery, String pathItemStringQuery) throws ServiceException {
        if (localStringPath == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter localStringPath is required and cannot be null."));
        }
        if (pathItemStringPath == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter pathItemStringPath is required and cannot be null."));
        }
        if (this.client.getGlobalStringPath() == null) {
            throw new ServiceException(
                new IllegalArgumentException("Parameter this.client.getGlobalStringPath() is required and cannot be null."));
        }
        try {
            ServiceResponse<Void> response = getLocalPathItemQueryNullDelegate(service.getLocalPathItemQueryNull(localStringPath, localStringQuery, pathItemStringPath, pathItemStringQuery, this.client.getGlobalStringPath(), this.client.getGlobalStringQuery()), null);
            response.getBody();
        } catch (RetrofitError error) {
            ServiceResponse<Void> response = getLocalPathItemQueryNullDelegate(error.getResponse(), error);
            response.getBody();
        }
    }

    /**
     * send globalStringPath='globalStringPath', pathItemStringPath='pathItemStringPath', localStringPath='localStringPath', globalStringQuery='globalStringQuery', pathItemStringQuery=null, localStringQuery=null
     *
     * @param localStringPath should contain value 'localStringPath'
     * @param pathItemStringPath A string value 'pathItemStringPath' that appears in the path
     * @param localStringQuery should contain value null
     * @param pathItemStringQuery should contain value null
     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.
     */
    public void getLocalPathItemQueryNullAsync(String localStringPath, String pathItemStringPath, String localStringQuery, String pathItemStringQuery, final ServiceCallback<Void> serviceCallback) {
        if (localStringPath == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter localStringPath is required and cannot be null.")));
        }
        if (pathItemStringPath == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter pathItemStringPath is required and cannot be null.")));
        }
        if (this.client.getGlobalStringPath() == null) {
            serviceCallback.failure(new ServiceException(
                new IllegalArgumentException("Parameter this.client.getGlobalStringPath() is required and cannot be null.")));
        }
        service.getLocalPathItemQueryNullAsync(localStringPath, localStringQuery, pathItemStringPath, pathItemStringQuery, this.client.getGlobalStringPath(), this.client.getGlobalStringQuery(), new ServiceResponseCallback() {
            @Override
            public void response(Response response, RetrofitError error) {
                try {
                    serviceCallback.success(getLocalPathItemQueryNullDelegate(response, error));
                } catch (ServiceException exception) {
                    serviceCallback.failure(exception);
                }
            }
        });
    }

    private ServiceResponse<Void> getLocalPathItemQueryNullDelegate(Response response, RetrofitError error) throws ServiceException {
        return new ServiceResponseBuilder<Void>()
                .register(200, new TypeToken<Void>(){}.getType())
                .registerError(new TypeToken<Error>(){}.getType())
                .build(response, error);
    }

}
