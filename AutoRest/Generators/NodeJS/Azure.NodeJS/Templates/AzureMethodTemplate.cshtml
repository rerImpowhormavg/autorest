@using Microsoft.Rest.Generator.NodeJS
@using Microsoft.Rest.Generator.NodeJS.Templates
@using Microsoft.Rest.Generator.NodeJS.TemplateModels
@using Microsoft.Rest.Generator.Azure.NodeJS
@using Microsoft.Rest.Generator.Azure.NodeJS.Templates
@using Microsoft.Rest.Generator.Utilities
@using Microsoft.Rest.Generator.ClientModel
@using System.Linq
@inherits Microsoft.Rest.Generator.Template<Microsoft.Rest.Generator.Azure.NodeJS.AzureMethodTemplateModel>

@if (!Model.IsLongRunningOperation)
{
@:@(Include( new MethodTemplate(), Model as MethodTemplateModel))
}
else if (Model.HttpMethod == HttpMethod.Post || Model.HttpMethod == HttpMethod.Delete)
{
<text>
/**
 *
@WrapComment(" * ", Model.Documentation)
@foreach (var parameter in Model.DocumentationParameters)
{
 @:* @@param {@MethodTemplateModel.GetParameterDocumentationType(parameter)} @MethodTemplateModel.GetParameterDocumentationName(parameter) @parameter.Documentation
 @:*
}
@WrapComment(" * ", " @param {object} [options]")
 *
@WrapComment(" * ", " @param {object} [options.customHeaders] headers that will be added to request")
 *
@WrapComment(" * ", " @param {function} callback")
 *
@WrapComment(" * ", " @returns {function} callback(err, result, request, response)")
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
@(Model.OperationName).prototype.@(Model.Name) = function (@(Model.MethodParameterDeclarationWithCallback)) {
  var self = @(Model.ClientReference);
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  // Send request
  this.begin@(Model.Name.ToPascalCase())(@(Model.MethodParameterDeclaration)function (err, result){
    if (err) return callback(err);
    self.getPostOrDeleteOperationResult(result, options, callback);
  });
};
</text>
}
else if (Model.HttpMethod == HttpMethod.Put || Model.HttpMethod == HttpMethod.Patch)
{
<text>
/**
 *
@WrapComment(" * ", Model.Documentation)
@foreach (var parameter in Model.DocumentationParameters)
{
 @:* @@param {@MethodTemplateModel.GetParameterDocumentationType(parameter)} @MethodTemplateModel.GetParameterDocumentationName(parameter) @parameter.Documentation
 @:* 
}
@WrapComment(" * ", " @param {object} [options]")
 *
@WrapComment(" * ", " @param {object} [options.customHeaders] headers that will be added to request")
 *
@WrapComment(" * ", " @param {function} callback")
 *
@WrapComment(" * ", " @returns {function} callback(err, result, request, response)")
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
@(Model.OperationName).prototype.@(Model.Name) = function (@(Model.MethodParameterDeclarationWithCallback)) {
  var client = @(Model.ClientReference);
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Send request
  this.begin@(Model.Name.ToPascalCase())(@(Model.MethodParameterDeclaration)function (err, result){
    if (err) return callback(err);
    client.getPutOrPatchOperationResult(result, options, callback);
  });
};
</text>
}